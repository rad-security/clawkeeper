#!/bin/bash
# ============================================================================
# CLAW Keeper Setup Wizard
# Harden your host. Deploy OpenClaw securely.
#
# By RAD Security — https://rad.security
#
# This file is auto-generated by scripts/bundle.sh — do not edit directly.
# ============================================================================

set -uo pipefail

# === Shared Helpers ======================================================

# ============================================================================
# Clawkeeper — Shared Helpers
# JSON output functions for check scripts + parsing for the orchestrator
# ============================================================================

# --- JSON Output Helpers (used by check.sh / remediate.sh scripts) ----------
# These emit structured JSON lines to stdout. Both the CLI orchestrator and
# the Tauri backend parse this output.

# Escape a string for safe JSON embedding
_json_escape() {
    local s="$1"
    s="${s//\\/\\\\}"
    s="${s//\"/\\\"}"
    s="${s//$'\t'/\\t}"
    s="${s//$'\n'/\\n}"
    printf '%s' "$s"
}

emit_pass() {
    local detail="$1"
    local check_name="${2:-}"
    printf '{"status":"PASS","check_name":"%s","detail":"%s"}\n' \
        "$(_json_escape "$check_name")" "$(_json_escape "$detail")"
}

emit_fail() {
    local detail="$1"
    local check_name="${2:-}"
    printf '{"status":"FAIL","check_name":"%s","detail":"%s"}\n' \
        "$(_json_escape "$check_name")" "$(_json_escape "$detail")"
}

emit_info() {
    local message="$1"
    printf '{"type":"info","message":"%s"}\n' "$(_json_escape "$message")"
}

emit_warn() {
    local message="$1"
    printf '{"type":"warn","message":"%s"}\n' "$(_json_escape "$message")"
}

emit_skipped() {
    local detail="$1"
    local check_name="${2:-}"
    printf '{"status":"SKIPPED","check_name":"%s","detail":"%s"}\n' \
        "$(_json_escape "$check_name")" "$(_json_escape "$detail")"
}

# Emit a remediation prompt. The orchestrator will ask the user and call
# remediate.sh if accepted. fail_detail is used when the user declines in
# scan mode; skip_detail when they decline in setup mode.
emit_prompt() {
    local message="$1"
    local remediation_id="$2"
    local fail_detail="${3:-}"
    local skip_detail="${4:-}"
    printf '{"action":"prompt","message":"%s","remediation_id":"%s","fail_detail":"%s","skip_detail":"%s"}\n' \
        "$(_json_escape "$message")" \
        "$(_json_escape "$remediation_id")" \
        "$(_json_escape "$fail_detail")" \
        "$(_json_escape "$skip_detail")"
}

# --- JSON Parsing Helper (used by the orchestrator) -------------------------
# Extract a value from a simple flat JSON object. No jq dependency.
# Usage: _jval '{"key":"value"}' "key"  → prints "value"
_jval() {
    local json="$1" key="$2"
    local pattern="\"${key}\":\""
    local rest="${json#*$pattern}"
    if [ "$rest" = "$json" ]; then
        echo ""
        return
    fi
    # Handle escaped quotes in value
    local value=""
    local i=0
    local len=${#rest}
    local prev=""
    while [ $i -lt "$len" ]; do
        local ch="${rest:$i:1}"
        if [ "$ch" = '"' ] && [ "$prev" != '\' ]; then
            break
        fi
        value="${value}${ch}"
        prev="$ch"
        i=$((i + 1))
    done
    # Unescape
    value="${value//\\n/$'\n'}"
    value="${value//\\t/$'\t'}"
    value="${value//\\\"/\"}"
    value="${value//\\\\/\\}"
    printf '%s' "$value"
}

# === UI (colors, formatting, output) =====================================

# ============================================================================
# Clawkeeper UI — Colors, formatting, gum integration, styled output
# Concatenated by bundle.sh — do NOT add a shebang here.
#
# By RAD Security — https://rad.security
# ============================================================================

# --- Colors & Formatting ---------------------------------------------------
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

# --- Gum Theme Constants ---------------------------------------------------
HAS_GUM=false
GUM_GREEN="34"
GUM_RED="196"
GUM_YELLOW="220"
GUM_BLUE="33"
GUM_CYAN="45"
GUM_DIM="245"
GUM_BOLD_WHITE="15"
GUM_BORDER="rounded"
GUM_BORDER_FG="45"
GUM_SPINNER="dot"

# Pre-computed gum styled icons (populated by init_gum_icons)
_GUM_PASS_ICON=""
_GUM_FAIL_ICON=""
_GUM_WARN_ICON=""
_GUM_SKIP_ICON=""
_GUM_INFO_ICON=""
_GUM_FIXED_SUFFIX=""
_GUM_SKIPPED_SUFFIX=""

# --- Counters ---------------------------------------------------------------
PASS=0
FAIL=0
FIXED=0
SKIPPED=0
TOTAL=0

# --- State ------------------------------------------------------------------
NEEDS_SUDO=false
SUDO_AUTHENTICATED=false
INTERACTIVE=true
SCAN_ONLY=false
REPORT_FILE=""
REPORT_LINES=()
HOMEBREW_FAILED=false
CAN_INSTALL_SOFTWARE=true

# --- Compact Output --------------------------------------------------------
COMPACT_OUTPUT=false
_COMPACT_THIS_CHECK=false
_COMPACT_STEP_NAME=""
_COMPACT_COL=0
_COMPACT_BUF=""

# --- Platform Detection -----------------------------------------------------
PLATFORM=""
ARCH=""
MACOS_VERSION=""
DEPLOY_MODE=""
LINUX_DISTRO=""
LINUX_DISTRO_VERSION=""
LINUX_DISTRO_NAME=""
IS_VPS=false

# --- Gum Installation & Icons -----------------------------------------------

ensure_gum() {
    # Skip when stdout is not a TTY (piped output, scheduled jobs)
    if ! [ -t 1 ]; then
        return
    fi

    # Already available in PATH
    if command -v gum &>/dev/null; then
        HAS_GUM=true
        return
    fi

    # Check our local install location
    if [ -x "$HOME/.local/bin/gum" ]; then
        export PATH="$HOME/.local/bin:$PATH"
        HAS_GUM=true
        return
    fi

    # Auto-install gum binary
    local gum_version="0.15.2"
    local os_name arch_name
    os_name=$(uname -s)
    arch_name=$(uname -m)

    case "$os_name" in
        Darwin) ;;
        Linux)  ;;
        *)      return ;;
    esac

    case "$arch_name" in
        arm64|aarch64) arch_name="arm64" ;;
        x86_64)        ;;
        *)             return ;;
    esac

    local url="https://github.com/charmbracelet/gum/releases/download/v${gum_version}/gum_${gum_version}_${os_name}_${arch_name}.tar.gz"
    local tmp_dir dest_dir="$HOME/.local/bin"
    tmp_dir=$(mktemp -d)

    echo -e "  ${DIM}Installing gum for styled output...${RESET}"

    if curl -fsSL "$url" -o "$tmp_dir/gum.tar.gz" 2>/dev/null; then
        tar -xzf "$tmp_dir/gum.tar.gz" -C "$tmp_dir" 2>/dev/null || { rm -rf "$tmp_dir"; return; }
        mkdir -p "$dest_dir"
        # Find the gum binary in extracted contents
        local gum_bin=""
        for candidate in "$tmp_dir/gum" "$tmp_dir"/gum_*/gum; do
            if [ -f "$candidate" ]; then
                gum_bin="$candidate"
                break
            fi
        done
        if [ -n "$gum_bin" ]; then
            mv "$gum_bin" "$dest_dir/gum"
            chmod +x "$dest_dir/gum"
            export PATH="$dest_dir:$PATH"
            if command -v gum &>/dev/null; then
                HAS_GUM=true
                echo -e "  ${GREEN}✓${RESET} ${DIM}gum installed${RESET}"
            fi
        fi
    fi

    rm -rf "$tmp_dir"
}

init_gum_icons() {
    if [ "$HAS_GUM" != true ]; then
        return
    fi
    _GUM_PASS_ICON=$(gum style --foreground "$GUM_GREEN" "✓")
    _GUM_FAIL_ICON=$(gum style --foreground "$GUM_RED" "✗")
    _GUM_WARN_ICON=$(gum style --foreground "$GUM_YELLOW" "⚠")
    _GUM_SKIP_ICON=$(gum style --foreground "$GUM_YELLOW" "⊘")
    _GUM_INFO_ICON=$(gum style --foreground "$GUM_DIM" "→")
    _GUM_FIXED_SUFFIX=$(gum style --foreground "$GUM_DIM" "(just fixed)")
    _GUM_SKIPPED_SUFFIX=$(gum style --foreground "$GUM_DIM" "(accepted risk)")
}

# --- Styled Output Helpers (gum with ANSI fallback) -----------------------

ok_msg() {
    if [ "$HAS_GUM" = true ]; then echo "  ${_GUM_PASS_ICON} $*"
    else echo -e "  ${GREEN}✓${RESET} $*"; fi
}

fail_msg() {
    if [ "$HAS_GUM" = true ]; then echo "  ${_GUM_FAIL_ICON} $*"
    else echo -e "  ${RED}✗${RESET} $*"; fi
}

warn_msg() {
    if [ "$HAS_GUM" = true ]; then echo "  ${_GUM_WARN_ICON} $*"
    else echo -e "  ${YELLOW}⚠${RESET} $*"; fi
}

dim_msg() {
    if [ "$HAS_GUM" = true ]; then gum style --foreground "$GUM_DIM" -- "$*"
    else echo -e "${DIM}$*${RESET}"; fi
}

accent_msg() {
    if [ "$HAS_GUM" = true ]; then gum style --foreground "$GUM_CYAN" -- "$*"
    else echo -e "${CYAN}$*${RESET}"; fi
}

accent_bold_msg() {
    if [ "$HAS_GUM" = true ]; then gum style --bold --foreground "$GUM_CYAN" -- "$*"
    else echo -e "${CYAN}${BOLD}$*${RESET}"; fi
}

highlight_msg() {
    if [ "$HAS_GUM" = true ]; then gum style --bold --foreground "$GUM_YELLOW" -- "$*"
    else echo -e "${YELLOW}${BOLD}$*${RESET}"; fi
}

error_bold_msg() {
    if [ "$HAS_GUM" = true ]; then gum style --bold --foreground "$GUM_RED" -- "$*"
    else echo -e "${RED}${BOLD}$*${RESET}"; fi
}

bold_msg() {
    if [ "$HAS_GUM" = true ]; then gum style --bold --foreground "$GUM_BOLD_WHITE" -- "$*"
    else echo -e "${BOLD}$*${RESET}"; fi
}

phase_header() {
    echo ""
    if [ "$HAS_GUM" = true ]; then
        gum style --bold --foreground "$GUM_CYAN" --border normal --border-foreground "$GUM_BORDER_FG" --padding "0 2" -- "$1"
    else
        echo -e "${CYAN}${BOLD}$1${RESET}"
    fi
}

read_secret() {
    # $1 = prompt text, $2 = placeholder
    local prompt="$1" placeholder="${2:-}"
    if [ "$HAS_GUM" = true ]; then
        gum input --password --placeholder "$placeholder" --header "$prompt" </dev/tty
    else
        echo -ne "  ${BLUE}→${RESET} $prompt " >&2
        local key
        read -rs key </dev/tty
        echo "" >&2
        echo "$key"
    fi
}

# --- Helpers ----------------------------------------------------------------
print_platform_info() {
    local arch_label="$ARCH"
    if [ "$PLATFORM" = "macos" ]; then
        [ "$ARCH" = "arm64" ] && arch_label="Apple Silicon"
        [ "$ARCH" = "x86_64" ] && arch_label="Intel"
        dim_msg "  macOS $MACOS_VERSION ($arch_label)"
    elif [ "$PLATFORM" = "linux" ]; then
        dim_msg "  $LINUX_DISTRO_NAME ($arch_label)"
        if [ "$IS_VPS" = true ]; then
            local virt_type
            virt_type=$(systemd-detect-virt 2>/dev/null || echo "")
            dim_msg "  Virtualization: $virt_type (VPS/VM)"
        fi
    fi
    if [ -n "$DEPLOY_MODE" ]; then
        local mode_label="Docker"
        [ "$DEPLOY_MODE" = "native" ] && mode_label="Native (npm)"
        dim_msg "  Deployment mode: $mode_label"
    fi
}

print_banner() {
    echo ""
    if [ "$HAS_GUM" = true ]; then
        gum style --border "$GUM_BORDER" --border-foreground "$GUM_BORDER_FG" \
            --padding "1 4" --align center --bold --foreground "$GUM_CYAN" \
            "Clawkeeper Setup Wizard" "" "Harden your host. Deploy securely."
    else
        echo -e "${CYAN}${BOLD}"
        echo "   ┌────────────────────────────────────────┐"
        echo "   │                                        │"
        echo "   │        Clawkeeper Setup Wizard         │"
        echo "   │                                        │"
        echo "   │   Harden your host. Deploy securely.   │"
        echo "   │                                        │"
        echo "   └────────────────────────────────────────┘"
        echo -e "${RESET}"
    fi
    print_platform_info
}

print_scan_banner() {
    echo ""
    if [ "$HAS_GUM" = true ]; then
        gum style --border "$GUM_BORDER" --border-foreground "$GUM_BORDER_FG" \
            --padding "1 4" --align center --bold --foreground "$GUM_CYAN" \
            "Clawkeeper Security Scan"
    else
        echo -e "${CYAN}${BOLD}"
        echo "   ┌────────────────────────────────────────┐"
        echo "   │                                        │"
        echo "   │       Clawkeeper Security Scan         │"
        echo "   │                                        │"
        echo "   └────────────────────────────────────────┘"
        echo -e "${RESET}"
    fi
    print_platform_info
}

log_result() {
    # $1 = status (PASS, FAIL, FIXED, SKIPPED)
    # $2 = step name
    # $3 = detail
    REPORT_LINES+=("$1|$2|$3")
}

# Phase tracking for per-phase summaries
PHASE_PASS=0
PHASE_FAIL=0
PHASE_FIXED=0
PHASE_SKIPPED=0

reset_phase_counters() {
    PHASE_PASS=$PASS
    PHASE_FAIL=$FAIL
    PHASE_FIXED=$FIXED
    PHASE_SKIPPED=$SKIPPED
}

print_phase_summary() {
    local p=$((PASS - PHASE_PASS))
    local x=$((FAIL - PHASE_FAIL))
    local f=$((FIXED - PHASE_FIXED))
    local s=$((SKIPPED - PHASE_SKIPPED))
    local total_in_phase=$((p + x + f + s))

    # Don't print anything if no checks ran in this phase
    if [ "$total_in_phase" -eq 0 ]; then
        return
    fi

    echo ""
    if [ "$HAS_GUM" = true ]; then
        local summary="──"
        [ "$p" -gt 0 ] && summary="$summary $(gum style --foreground "$GUM_GREEN" "$p passed")"
        [ "$f" -gt 0 ] && summary="$summary $(gum style --foreground "$GUM_GREEN" "$f fixed")"
        [ "$x" -gt 0 ] && summary="$summary $(gum style --foreground "$GUM_RED" "$x failed")"
        [ "$s" -gt 0 ] && summary="$summary $(gum style --foreground "$GUM_YELLOW" "$s skipped")"
        summary="$summary ──"
        gum style --foreground "$GUM_DIM" -- "  $summary"
    else
        echo -ne "  ${DIM}──"
        [ "$p" -gt 0 ] && echo -ne " ${GREEN}$p passed${RESET}${DIM}"
        [ "$f" -gt 0 ] && echo -ne " ${GREEN}$f fixed${RESET}${DIM}"
        [ "$x" -gt 0 ] && echo -ne " ${RED}$x failed${RESET}${DIM}"
        [ "$s" -gt 0 ] && echo -ne " ${YELLOW}$s skipped${RESET}${DIM}"
        echo -e " ──${RESET}"
    fi
}

print_expectations() {
    echo ""
    if [ "$HAS_GUM" = true ]; then
        gum style --foreground "$GUM_DIM" -- \
            "  This wizard walks you through 5 phases:" \
            "    1. Host Hardening   — reduce your attack surface" \
            "    2. Network          — verify network security" \
            "    3. Prerequisites    — install required software" \
            "    4. OpenClaw         — deploy with hardened defaults" \
            "    5. Security Audit   — verify everything is locked down"
        echo ""
        echo "  $(gum style --foreground "$GUM_DIM" "Every change requires your approval. Nothing runs without") $(gum style --bold "[Y/n]")$(gum style --foreground "$GUM_DIM" ".")"
    else
        echo -e "  ${DIM}This wizard walks you through 5 phases:${RESET}"
        echo -e "  ${DIM}  1. Host Hardening   — reduce your attack surface${RESET}"
        echo -e "  ${DIM}  2. Network          — verify network security${RESET}"
        echo -e "  ${DIM}  3. Prerequisites    — install required software${RESET}"
        echo -e "  ${DIM}  4. OpenClaw         — deploy with hardened defaults${RESET}"
        echo -e "  ${DIM}  5. Security Audit   — verify everything is locked down${RESET}"
        echo ""
        echo -e "  ${DIM}Every change requires your approval. Nothing runs without ${RESET}${BOLD}[Y/n]${RESET}${DIM}.${RESET}"
    fi
}

_compact_emit() {
    local text="$1"
    if [ "$_COMPACT_COL" -eq 0 ]; then
        _COMPACT_BUF="$text"
        _COMPACT_COL=1
    else
        # Print both columns: first item, cursor to column 42, second item
        printf '%s\033[42G%s\n' "$_COMPACT_BUF" "$text"
        _COMPACT_BUF=""
        _COMPACT_COL=0
    fi
}

_compact_flush() {
    if [ "$_COMPACT_COL" -eq 1 ] && [ -n "$_COMPACT_BUF" ]; then
        printf '%s\n' "$_COMPACT_BUF"
        _COMPACT_BUF=""
        _COMPACT_COL=0
    fi
}

step_header() {
    TOTAL=$((TOTAL + 1))
    if [ "$COMPACT_OUTPUT" = true ] && [ "$_COMPACT_THIS_CHECK" = true ]; then
        _COMPACT_STEP_NAME="$1"
        return
    fi
    _compact_flush
    echo ""
    if [ "$HAS_GUM" = true ]; then
        gum style --bold --foreground "$GUM_BOLD_WHITE" -- "Step ${TOTAL}: $1"
    else
        echo -e "${BOLD}Step ${TOTAL}: $1${RESET}"
    fi
}

pass() {
    PASS=$((PASS + 1))
    if [ "$COMPACT_OUTPUT" = true ] && [ "$_COMPACT_THIS_CHECK" = true ]; then
        if [ "$HAS_GUM" = true ]; then
            _compact_emit "  ${_GUM_PASS_ICON} ${_COMPACT_STEP_NAME}"
        else
            _compact_emit "$(echo -e "  ${GREEN}✓${RESET} ${_COMPACT_STEP_NAME}")"
        fi
        log_result "PASS" "$2" "$1"
        return
    fi
    if [ "$HAS_GUM" = true ]; then
        echo "  ${_GUM_PASS_ICON} $1"
    else
        echo -e "  ${GREEN}✓${RESET} $1"
    fi
    log_result "PASS" "$2" "$1"
}

fail() {
    FAIL=$((FAIL + 1))
    if [ "$COMPACT_OUTPUT" = true ] && [ "$_COMPACT_THIS_CHECK" = true ]; then
        if [ "$HAS_GUM" = true ]; then
            _compact_emit "  ${_GUM_FAIL_ICON} ${_COMPACT_STEP_NAME}"
        else
            _compact_emit "$(echo -e "  ${RED}✗${RESET} ${_COMPACT_STEP_NAME}")"
        fi
        log_result "FAIL" "$2" "$1"
        return
    fi
    if [ "$HAS_GUM" = true ]; then
        echo "  ${_GUM_FAIL_ICON} $1"
    else
        echo -e "  ${RED}✗${RESET} $1"
    fi
    log_result "FAIL" "$2" "$1"
}

fixed() {
    FIXED=$((FIXED + 1))
    if [ "$COMPACT_OUTPUT" = true ] && [ "$_COMPACT_THIS_CHECK" = true ]; then
        if [ "$HAS_GUM" = true ]; then
            _compact_emit "  ${_GUM_PASS_ICON} ${_COMPACT_STEP_NAME} ${_GUM_FIXED_SUFFIX}"
        else
            _compact_emit "$(echo -e "  ${GREEN}✓${RESET} ${_COMPACT_STEP_NAME} ${DIM}(fixed)${RESET}")"
        fi
        log_result "FIXED" "$2" "$1"
        return
    fi
    if [ "$HAS_GUM" = true ]; then
        echo "  ${_GUM_PASS_ICON} $1 ${_GUM_FIXED_SUFFIX}"
    else
        echo -e "  ${GREEN}✓${RESET} $1 ${DIM}(just fixed)${RESET}"
    fi
    log_result "FIXED" "$2" "$1"
    # After the 3rd fix, a subtle monitoring hint (suppress in compact mode)
    if [ "$FIXED" -eq 3 ] && [ "$COMPACT_OUTPUT" != true ]; then
        if [ "$HAS_GUM" = true ]; then
            echo "  $(gum style --foreground "$GUM_DIM" "Re-run anytime to check for drift, or monitor continuously at") $(gum style --foreground "$GUM_CYAN" "clawkeeper.dev")"
        else
            echo -e "  ${DIM}Re-run anytime to check for drift, or monitor continuously at ${CYAN}clawkeeper.dev${RESET}"
        fi
    fi
}

skipped() {
    SKIPPED=$((SKIPPED + 1))
    if [ "$COMPACT_OUTPUT" = true ] && [ "$_COMPACT_THIS_CHECK" = true ]; then
        if [ "$HAS_GUM" = true ]; then
            _compact_emit "  ${_GUM_SKIP_ICON} ${_COMPACT_STEP_NAME} ${_GUM_SKIPPED_SUFFIX}"
        else
            _compact_emit "$(echo -e "  ${YELLOW}⊘${RESET} ${_COMPACT_STEP_NAME} ${DIM}(risk)${RESET}")"
        fi
        log_result "SKIPPED" "$2" "$1"
        return
    fi
    if [ "$HAS_GUM" = true ]; then
        echo "  ${_GUM_SKIP_ICON} $1 ${_GUM_SKIPPED_SUFFIX}"
    else
        echo -e "  ${YELLOW}⊘${RESET} $1 ${DIM}(accepted risk)${RESET}"
    fi
    log_result "SKIPPED" "$2" "$1"
}

warn() {
    if [ "$COMPACT_OUTPUT" = true ] && [ "$_COMPACT_THIS_CHECK" = true ]; then
        return
    fi
    if [ "$HAS_GUM" = true ]; then
        echo "  ${_GUM_WARN_ICON} $1"
    else
        echo -e "  ${YELLOW}⚠${RESET} $1"
    fi
}

info() {
    if [ "$COMPACT_OUTPUT" = true ] && [ "$_COMPACT_THIS_CHECK" = true ]; then
        return
    fi
    if [ "$HAS_GUM" = true ]; then
        echo "  ${_GUM_INFO_ICON} $1"
    else
        echo -e "  ${DIM}→ $1${RESET}"
    fi
}

ask_yn() {
    # $1 = prompt
    # Returns 0 for yes, 1 for no
    if [ "$INTERACTIVE" = false ] || [ "$SCAN_ONLY" = true ]; then
        return 1
    fi
    if [ "$HAS_GUM" = true ]; then
        gum confirm --default=yes --prompt.foreground="$GUM_BLUE" -- "  $1" </dev/tty
        return $?
    fi
    local answer
    echo -ne "  ${BLUE}→${RESET} $1 ${DIM}[Y/n]${RESET} "
    read -r answer </dev/tty
    case "$answer" in
        [nN]|[nN][oO]) return 1 ;;
        *) return 0 ;;
    esac
}

# === Scanner (check runner, detection, reporting) ========================

# ============================================================================
# Clawkeeper Scanner — Check runner, detection, grading, reporting
# Concatenated by bundle.sh — do NOT add a shebang here.
#
# By RAD Security — https://rad.security
# ============================================================================

# --- Sudo helper ------------------------------------------------------------

ensure_sudo() {
    if [ "$SUDO_AUTHENTICATED" = true ]; then
        return 0
    fi
    # Check if we already have sudo cached
    if sudo -n true 2>/dev/null; then
        SUDO_AUTHENTICATED=true
        return 0
    fi
    echo ""
    highlight_msg "  Some fixes require administrator privileges (sudo)."
    echo ""
    if sudo -v; then
        SUDO_AUTHENTICATED=true
        echo ""
        ok_msg "Sudo access granted"
        return 0
    else
        echo ""
        fail_msg "Could not get sudo access. Some fixes will be skipped."
        return 1
    fi
}

# --- Run Check (extracted checks dispatcher) --------------------------------
# Runs a check.sh from checks/<id>/, parses its JSON output, and renders
# terminal output using the standard pass/fail/fixed/skipped/info/warn helpers.
# For prompt actions, calls remediate.sh if the user accepts.

run_check() {
    local check_id="$1"
    local check_func="__check_${check_id}"
    local remediate_func="__remediate_${check_id}"

    # Read metadata from the __meta_<id> function (set by bundle) or fallback
    local check_name="$check_id"
    if type "__meta_${check_id}" &>/dev/null; then
        check_name=$("__meta_${check_id}" name)
    fi

    local mode="scan"
    [ "$SCAN_ONLY" != true ] && mode="setup"

    # Run the check function and capture JSON output
    local json_output
    json_output=$("$check_func" --mode "$mode" 2>/dev/null)

    # In compact mode, check if output contains any prompts
    _COMPACT_THIS_CHECK=false
    if [ "$COMPACT_OUTPUT" = true ]; then
        if ! echo "$json_output" | grep -q '"action":"prompt"'; then
            _COMPACT_THIS_CHECK=true
        else
            # Flush buffered compact output before verbose check
            _compact_flush
        fi
    fi

    step_header "$check_name"

    # Process each JSON line
    while IFS= read -r line; do
        [ -z "$line" ] && continue

        local j_status j_type j_detail j_action j_message j_rid j_fail j_skip j_check
        j_status=$(_jval "$line" "status")
        j_type=$(_jval "$line" "type")
        j_detail=$(_jval "$line" "detail")
        j_action=$(_jval "$line" "action")
        j_message=$(_jval "$line" "message")
        j_rid=$(_jval "$line" "remediation_id")
        j_fail=$(_jval "$line" "fail_detail")
        j_skip=$(_jval "$line" "skip_detail")
        j_check=$(_jval "$line" "check_name")
        [ -z "$j_check" ] && j_check="$check_name"

        if [ -n "$j_type" ]; then
            case "$j_type" in
                info) info "$j_message" ;;
                warn) warn "$j_message" ;;
            esac
        elif [ "$j_action" = "prompt" ]; then
            if ask_yn "$j_message"; then
                # Run remediation
                local rem_output
                rem_output=$("$remediate_func" "$j_rid" 2>/dev/null)
                while IFS= read -r rem_line; do
                    [ -z "$rem_line" ] && continue
                    local r_status r_type r_detail r_message r_check
                    r_status=$(_jval "$rem_line" "status")
                    r_type=$(_jval "$rem_line" "type")
                    r_detail=$(_jval "$rem_line" "detail")
                    r_message=$(_jval "$rem_line" "message")
                    r_check=$(_jval "$rem_line" "check_name")
                    [ -z "$r_check" ] && r_check="$j_check"

                    if [ -n "$r_type" ]; then
                        case "$r_type" in
                            info) info "$r_message" ;;
                            warn) warn "$r_message" ;;
                        esac
                    elif [ -n "$r_status" ]; then
                        case "$r_status" in
                            PASS)  fixed "$r_detail" "$r_check" ;;
                            FIXED) fixed "$r_detail" "$r_check" ;;
                            FAIL)  fail "$r_detail" "$r_check" ;;
                        esac
                    fi
                done <<< "$rem_output"
            else
                # User declined — FAIL in scan mode, SKIPPED in setup mode
                if [ "$SCAN_ONLY" = true ]; then
                    local fail_msg="${j_fail:-$j_message}"
                    fail "$fail_msg" "$j_check"
                else
                    local skip_msg="${j_skip:-${j_fail:-$j_message}}"
                    skipped "$skip_msg" "$j_check"
                fi
            fi
        elif [ -n "$j_status" ]; then
            case "$j_status" in
                PASS)    pass "$j_detail" "$j_check" ;;
                FAIL)    fail "$j_detail" "$j_check" ;;
                FIXED)   fixed "$j_detail" "$j_check" ;;
                SKIPPED) skipped "$j_detail" "$j_check" ;;
            esac
        fi
    done <<< "$json_output"
}

# --- Admin / Install Capability Check ---------------------------------------

detect_install_capability() {
    # Determines if the current user can install software (needs admin/sudo).
    # Called before Phase 3 to warn the user early instead of failing mid-install.
    CAN_INSTALL_SOFTWARE=true

    if [ "$PLATFORM" = "macos" ]; then
        local current_user
        current_user=$(whoami)
        if ! groups "$current_user" 2>/dev/null | grep -qw "admin"; then
            # Standard (non-admin) user on macOS — cannot install via Homebrew/sudo
            CAN_INSTALL_SOFTWARE=false
        fi
    elif [ "$PLATFORM" = "linux" ]; then
        # Check if user can sudo (member of sudo/wheel group, or has NOPASSWD)
        if ! sudo -n true 2>/dev/null; then
            local current_user
            current_user=$(whoami)
            if ! groups "$current_user" 2>/dev/null | grep -qwE "sudo|wheel|admin"; then
                CAN_INSTALL_SOFTWARE=false
            fi
        fi
    fi
}

print_install_capability_warning() {
    # Shows a clear warning when a standard user can't install software,
    # with actionable instructions for what to do.
    if [ "$CAN_INSTALL_SOFTWARE" = true ]; then
        return
    fi

    local current_user
    current_user=$(whoami)

    echo ""
    highlight_msg "  Note: You're running as standard user '$current_user' (no admin/sudo)."
    dim_msg "  This is good for security, but installing new software requires admin."
    echo ""

    if [ "$PLATFORM" = "macos" ]; then
        if [ "$DEPLOY_MODE" = "native" ]; then
            dim_msg "  To install prerequisites, ask an admin to run:"
            accent_msg "    1. Install Homebrew:  /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\""
            accent_msg "    2. Install Node.js:   brew install node@22 && brew link --overwrite node@22"
        else
            dim_msg "  To install Docker, ask an admin to either:"
            accent_msg "    • Download Docker Desktop from https://docker.com/products/docker-desktop"
            accent_msg "    • Or install via Homebrew: brew install --cask docker"
        fi
        echo ""
        dim_msg "  Then re-run this script as '$current_user' — the security checks will pass."
    elif [ "$PLATFORM" = "linux" ]; then
        dim_msg "  Ask an admin to install prerequisites, then re-run as '$current_user'."
    fi

    echo ""
    dim_msg "  Checking what's already available..."
}

# --- Deployment Mode Selection -----------------------------------------------

select_deployment_mode() {
    # For scan mode, auto-detect based on what's present
    if [ "$SCAN_ONLY" = true ]; then
        if command -v docker &>/dev/null && docker ps --format '{{.Names}}' 2>/dev/null | grep -q "openclaw"; then
            DEPLOY_MODE="docker"
        elif pgrep -f "openclaw (gateway|server|start)" >/dev/null 2>&1; then
            DEPLOY_MODE="native"
        else
            DEPLOY_MODE="docker"  # default for scan
        fi
        return
    fi

    echo ""
    if [ "$HAS_GUM" = true ]; then
        local choice
        choice=$(gum choose --header "  How would you like to run OpenClaw?" \
            "Docker (recommended) — isolated container, limits agent access" \
            "Native (npm) — runs directly on your OS, simpler setup" </dev/tty)
        case "$choice" in
            Native*)
                DEPLOY_MODE="native"
                ok_msg "Selected: Native (npm) deployment"
                ;;
            *)
                DEPLOY_MODE="docker"
                ok_msg "Selected: Docker deployment"
                ;;
        esac
    else
        echo -e "  ${BOLD}How would you like to run OpenClaw?${RESET}"
        echo ""
        echo -e "  ${CYAN}1)${RESET} Native ${DIM}(npm)${RESET}"
        echo -e "     ${DIM}Runs directly on your OS. Simpler setup, shares your filesystem.${RESET}"
        echo ""
        echo -e "  ${CYAN}2)${RESET} Docker ${DIM}(recommended)${RESET}"
        echo -e "     ${DIM}Runs in an isolated container. Limits what a compromised agent can access.${RESET}"
        echo ""
        local choice
        echo -ne "  ${BLUE}→${RESET} Enter 1 or 2 ${DIM}(default: 2)${RESET}: "
        read -r choice </dev/tty

        case "$choice" in
            1)
                DEPLOY_MODE="native"
                echo -e "  ${GREEN}✓${RESET} Selected: ${BOLD}Native (npm)${RESET} deployment"
                ;;
            *)
                DEPLOY_MODE="docker"
                echo -e "  ${GREEN}✓${RESET} Selected: ${BOLD}Docker${RESET} deployment"
                ;;
        esac
    fi
}

# --- OpenClaw Installation Detection -----------------------------------------

OPENCLAW_INSTALLED=false
OPENCLAW_INSTALL_TYPE=""

detect_openclaw_installed() {
    OPENCLAW_INSTALLED=false
    OPENCLAW_INSTALL_TYPE=""
    OPENCLAW_DETECT_METHOD=""

    # Check for Docker-based installation
    if command -v docker >/dev/null 2>&1 && docker info >/dev/null 2>&1; then
        # Running container
        if docker ps --format '{{.Names}}' 2>/dev/null | grep -q "openclaw"; then
            OPENCLAW_INSTALLED=true
            OPENCLAW_INSTALL_TYPE="docker"
            OPENCLAW_DETECT_METHOD="running container"
            return
        fi
        # Stopped container
        if docker ps -a --format '{{.Names}}' 2>/dev/null | grep -q "openclaw"; then
            OPENCLAW_INSTALLED=true
            OPENCLAW_INSTALL_TYPE="docker"
            OPENCLAW_DETECT_METHOD="stopped container"
            return
        fi
        # Image present
        if docker images --format '{{.Repository}}' 2>/dev/null | grep -qi "openclaw"; then
            OPENCLAW_INSTALLED=true
            OPENCLAW_INSTALL_TYPE="docker"
            OPENCLAW_DETECT_METHOD="docker image"
            return
        fi
    fi

    # Check for Docker Compose setup file
    if [ -f "$HOME/openclaw-docker/docker-compose.yml" ]; then
        OPENCLAW_INSTALLED=true
        OPENCLAW_INSTALL_TYPE="docker"
        OPENCLAW_DETECT_METHOD="compose file"
        return
    fi

    # Check for native npm installation
    if command -v openclaw >/dev/null 2>&1; then
        OPENCLAW_INSTALLED=true
        OPENCLAW_INSTALL_TYPE="native"
        OPENCLAW_DETECT_METHOD="command: $(command -v openclaw 2>/dev/null)"
        return
    fi

    # Check for running OpenClaw process (match gateway/server, not stray
    # grep/tee/pipe commands that happen to contain the word "openclaw")
    if pgrep -f "openclaw (gateway|server|start)" >/dev/null 2>&1; then
        OPENCLAW_INSTALLED=true
        OPENCLAW_INSTALL_TYPE="native"
        OPENCLAW_DETECT_METHOD="running process"
        return
    fi

    # Stale LaunchAgent plist without a working binary is not a real install.
    # Clean it up silently so it doesn't confuse future scans.
    if [ -f "$HOME/Library/LaunchAgents/com.openclaw.agent.plist" ]; then
        launchctl unload "$HOME/Library/LaunchAgents/com.openclaw.agent.plist" 2>/dev/null || true
        rm -f "$HOME/Library/LaunchAgents/com.openclaw.agent.plist"
    fi
}

# --- Report -----------------------------------------------------------------

print_report() {
    echo ""
    if [ "$HAS_GUM" = true ]; then
        gum style --bold --foreground "$GUM_CYAN" --border double --border-foreground "$GUM_BORDER_FG" --padding "0 2" -- ""
    else
        echo -e "${CYAN}${BOLD}════════════════════════════════════════════════════${RESET}"
    fi
    echo ""

    # Calculate grade — SKIPPED = accepted risk (not penalized like FAIL)
    local scored_checks=$((PASS + FAIL + FIXED))
    local effective_pass=$((PASS + FIXED))
    local score=0

    if [ "$scored_checks" -gt 0 ]; then
        score=$(( (effective_pass * 100) / scored_checks ))
    fi

    local grade="F"
    local grade_color="$RED"
    local gum_grade_color="$GUM_RED"
    if [ "$score" -ge 95 ]; then
        grade="A"; grade_color="$GREEN"; gum_grade_color="$GUM_GREEN"
    elif [ "$score" -ge 85 ]; then
        grade="B"; grade_color="$GREEN"; gum_grade_color="$GUM_GREEN"
    elif [ "$score" -ge 70 ]; then
        grade="C"; grade_color="$YELLOW"; gum_grade_color="$GUM_YELLOW"
    elif [ "$score" -ge 50 ]; then
        grade="D"; grade_color="$YELLOW"; gum_grade_color="$GUM_YELLOW"
    fi

    if [ "$HAS_GUM" = true ]; then
        echo "  $(gum style --bold "Security Grade:") $(gum style --bold --foreground "$gum_grade_color" "$grade") $(gum style --foreground "$GUM_DIM" "(${score}% of checks passing)")"
    else
        echo -e "  ${BOLD}Security Grade: ${grade_color}${BOLD}$grade${RESET} ${DIM}(${score}% of checks passing)${RESET}"
    fi
    echo ""

    if [ "$HAS_GUM" = true ]; then
        echo "  $(gum style --foreground "$GUM_GREEN" "✓ Passed:")  $PASS"
        if [ "$FIXED" -gt 0 ]; then
            echo "  $(gum style --foreground "$GUM_GREEN" "✓ Fixed:")   $FIXED $(gum style --foreground "$GUM_DIM" "(improved during this session)")"
        fi
        echo "  $(gum style --foreground "$GUM_RED" "✗ Failed:")  $FAIL"
        if [ "$SKIPPED" -gt 0 ]; then
            echo "  $(gum style --foreground "$GUM_YELLOW" "⊘ Accepted:") $SKIPPED $(gum style --foreground "$GUM_DIM" "(conscious risk decisions)")"
        fi
    else
        echo -e "  ${GREEN}✓ Passed:${RESET}  $PASS"
        if [ "$FIXED" -gt 0 ]; then
            echo -e "  ${GREEN}✓ Fixed:${RESET}   $FIXED ${DIM}(improved during this session)${RESET}"
        fi
        echo -e "  ${RED}✗ Failed:${RESET}  $FAIL"
        if [ "$SKIPPED" -gt 0 ]; then
            echo -e "  ${YELLOW}⊘ Accepted:${RESET} $SKIPPED ${DIM}(conscious risk decisions)${RESET}"
        fi
    fi
    echo ""

    if [ "$FAIL" -gt 0 ]; then
        error_bold_msg "  Failed checks:"
        for line in "${REPORT_LINES[@]}"; do
            local status step detail
            status=$(echo "$line" | cut -d'|' -f1)
            step=$(echo "$line" | cut -d'|' -f2)
            detail=$(echo "$line" | cut -d'|' -f3)
            if [ "$status" = "FAIL" ]; then
                if [ "$HAS_GUM" = true ]; then
                    echo "    ${_GUM_FAIL_ICON} $(gum style --bold "[$step]") $detail"
                else
                    echo -e "    ${RED}✗${RESET} ${BOLD}[$step]${RESET} $detail"
                fi
            fi
        done
        echo ""
    fi

    if [ "$SKIPPED" -gt 0 ]; then
        if [ "$HAS_GUM" = true ]; then
            gum style --foreground "$GUM_YELLOW" -- "  Accepted risks:"
        else
            echo -e "  ${YELLOW}Accepted risks:${RESET}"
        fi
        for line in "${REPORT_LINES[@]}"; do
            local status step detail
            status=$(echo "$line" | cut -d'|' -f1)
            step=$(echo "$line" | cut -d'|' -f2)
            detail=$(echo "$line" | cut -d'|' -f3)
            if [ "$status" = "SKIPPED" ]; then
                if [ "$HAS_GUM" = true ]; then
                    echo "    ${_GUM_SKIP_ICON} [$step] $detail"
                else
                    echo -e "    ${YELLOW}⊘${RESET} [$step] $detail"
                fi
            fi
        done
        echo ""
    fi

    if [ "$HAS_GUM" = true ]; then
        gum style --bold --foreground "$GUM_CYAN" --border double --border-foreground "$GUM_BORDER_FG" --padding "0 2" -- ""
    else
        echo -e "${CYAN}${BOLD}════════════════════════════════════════════════════${RESET}"
    fi

    if [ "$FAIL" -gt 0 ]; then
        echo ""
        if [ "$HAS_GUM" = true ]; then
            echo "  Run $(gum style --bold --foreground "$GUM_CYAN" "$(basename "$0") setup") to fix failed checks interactively."
        else
            echo -e "  Run ${CYAN}${BOLD}$(basename "$0") setup${RESET} to fix failed checks interactively."
        fi
    fi

    if [ "$PLATFORM" = "linux" ] && [ "$IS_VPS" = true ]; then
        echo ""
        local vps_ip
        vps_ip=$(curl -sf --max-time 3 https://ifconfig.me 2>/dev/null || echo "your-vps-ip")
        if [ "$HAS_GUM" = true ]; then
            echo "  $(gum style --foreground "$GUM_CYAN" "VPS access:") $(gum style --foreground "$GUM_DIM" "ssh -N -L 18789:127.0.0.1:18789 user@${vps_ip}")"
        else
            echo -e "  ${CYAN}VPS access:${RESET} ${DIM}ssh -N -L 18789:127.0.0.1:18789 user@${vps_ip}${RESET}"
        fi
    fi

    # CTA: check if agent is actually connected with a valid API key
    echo ""
    local has_api_key=false
    if [ -f "$AGENT_CONFIG_FILE" ]; then
        local stored_key
        stored_key=$(grep '^CLAWKEEPER_API_KEY=' "$AGENT_CONFIG_FILE" 2>/dev/null | head -1 | sed 's/^CLAWKEEPER_API_KEY="//' | sed 's/"$//')
        if [ -n "$stored_key" ] && echo "$stored_key" | grep -qE '^ck_live_.{12,}'; then
            has_api_key=true
        fi
    fi

    if [ "$has_api_key" = true ] && [ "$SCAN_ONLY" = true ]; then
        if [ "$HAS_GUM" = true ]; then
            echo "  ${_GUM_PASS_ICON} Agent connected — view your dashboard at $(gum style --foreground "$GUM_CYAN" "clawkeeper.dev")"
        else
            echo -e "  ${GREEN}✓${RESET} Agent connected — view your dashboard at ${CYAN}clawkeeper.dev${RESET}"
        fi
    elif [ "$has_api_key" != true ]; then
        if [ "$HAS_GUM" = true ]; then
            echo "  $(gum style --foreground "$GUM_DIM" "Monitor this host over time →") $(gum style --foreground "$GUM_CYAN" "clawkeeper.dev")"
        else
            echo -e "  ${DIM}Monitor this host over time →${RESET} ${CYAN}clawkeeper.dev${RESET}"
        fi
    fi
    echo ""
}

save_report() {
    if [ -z "$REPORT_FILE" ]; then
        return
    fi

    local os_info
    if [ "$PLATFORM" = "macos" ]; then
        os_info="macOS $(sw_vers -productVersion 2>/dev/null || echo 'unknown')"
    elif [ "$PLATFORM" = "linux" ]; then
        os_info="$LINUX_DISTRO_NAME"
    else
        os_info="$PLATFORM"
    fi

    local scored_checks=$((PASS + FAIL + FIXED))
    local effective_pass=$((PASS + FIXED))
    local score=0
    if [ "$scored_checks" -gt 0 ]; then
        score=$(( (effective_pass * 100) / scored_checks ))
    fi

    {
        echo "CLAW Keeper Security Report"
        echo "Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        echo "Hostname: $(hostname)"
        echo "OS: $os_info"
        echo "User: $(whoami)"
        echo ""
        echo "---"
        echo ""
        echo "Score: ${score}%"
        echo "Passed: $PASS"
        echo "Fixed: $FIXED"
        echo "Failed: $FAIL"
        echo "Accepted risks: $SKIPPED"
        echo ""
        echo "---"
        echo ""

        for line in "${REPORT_LINES[@]}"; do
            local status step detail
            status=$(echo "$line" | cut -d'|' -f1)
            step=$(echo "$line" | cut -d'|' -f2)
            detail=$(echo "$line" | cut -d'|' -f3)
            printf "%-8s | %-25s | %s\n" "$status" "$step" "$detail"
        done

        echo ""
        echo "---"
        echo ""
        echo "This is a point-in-time snapshot. Settings can drift over time."
        echo "Re-run scans regularly or set up continuous monitoring at clawkeeper.dev"
    } > "$REPORT_FILE"

    dim_msg "  Report saved to: $REPORT_FILE"
}

# === Agent (SaaS integration) ============================================

# ============================================================================
# Clawkeeper Agent — SaaS integration, scheduling, scan upload
# Concatenated by bundle.sh — do NOT add a shebang here.
#
# By RAD Security — https://rad.security
# ============================================================================

AGENT_VERSION="1.0.0"
AGENT_CONFIG_DIR="$HOME/.clawkeeper"
AGENT_CONFIG_FILE="$AGENT_CONFIG_DIR/config"
AGENT_PLIST_LABEL="com.clawkeeper.agent"
AGENT_API_URL="https://clawkeeper.dev/api/v1/scans"

agent_log() {
    echo "[$(date -u +"%Y-%m-%dT%H:%M:%SZ")] $*"
}

# Report a lifecycle event to the Clawkeeper API (fire-and-forget)
report_event() {
    local event_type="$1"
    local event_hostname="${2:-$(hostname)}"

    # Load config if not already loaded
    local api_key="${CLAWKEEPER_API_KEY:-}"
    local api_url="${CLAWKEEPER_API_URL:-$AGENT_API_URL}"

    if [ -z "$api_key" ] && [ -f "$AGENT_CONFIG_FILE" ]; then
        # shellcheck disable=SC1090
        source "$AGENT_CONFIG_FILE"
        api_key="${CLAWKEEPER_API_KEY:-}"
        api_url="${CLAWKEEPER_API_URL:-$AGENT_API_URL}"
    fi

    # Silently skip if no API key
    [ -z "$api_key" ] && return 0

    # Derive events URL from scans URL
    local events_url="${api_url%/scans}/events"

    curl -s -o /dev/null \
        -X POST "$events_url" \
        -H "Authorization: Bearer $api_key" \
        -H "Content-Type: application/json" \
        -d "{\"event_type\":\"$event_type\",\"hostname\":\"$event_hostname\"}" \
        2>/dev/null &
}

agent_load_config() {
    if [ ! -f "$AGENT_CONFIG_FILE" ]; then
        error_bold_msg "Error: Agent not configured. Run: clawkeeper.sh agent --install"
        exit 1
    fi
    # shellcheck disable=SC1090
    source "$AGENT_CONFIG_FILE"
}

agent_generate_plist() {
    local script_path="$1"
    local dest="$HOME/Library/LaunchAgents/$AGENT_PLIST_LABEL.plist"
    mkdir -p "$HOME/Library/LaunchAgents"
    cat > "$dest" <<PLISTEOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>$AGENT_PLIST_LABEL</string>
    <key>ProgramArguments</key>
    <array>
        <string>$script_path</string>
        <string>agent</string>
        <string>run</string>
    </array>
    <key>StartInterval</key>
    <integer>3600</integer>
    <key>RunAtLoad</key>
    <true/>
    <key>StandardOutPath</key>
    <string>$HOME/.clawkeeper/agent.log</string>
    <key>StandardErrorPath</key>
    <string>$HOME/.clawkeeper/agent.err</string>
    <key>EnvironmentVariables</key>
    <dict>
        <key>PATH</key>
        <string>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</string>
    </dict>
</dict>
</plist>
PLISTEOF
    echo "$dest"
}

agent_generate_systemd() {
    local script_path="$1"
    local service_dir="$HOME/.config/systemd/user"
    mkdir -p "$service_dir"

    cat > "$service_dir/clawkeeper-agent.service" <<SVCEOF
[Unit]
Description=Clawkeeper Security Agent
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=$script_path agent run
Environment=PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin

[Install]
WantedBy=default.target
SVCEOF

    cat > "$service_dir/clawkeeper-agent.timer" <<TMREOF
[Unit]
Description=Run Clawkeeper agent hourly

[Timer]
OnBootSec=5min
OnUnitActiveSec=1h
Persistent=true

[Install]
WantedBy=timers.target
TMREOF

    systemctl --user daemon-reload 2>/dev/null || true
    systemctl --user enable --now clawkeeper-agent.timer 2>/dev/null || true
    echo "$service_dir/clawkeeper-agent.timer"
}

agent_install() {
    echo ""
    accent_bold_msg "  Clawkeeper Agent Setup"
    echo ""

    # Prompt for API key (with helpful fallback if skipped)
    echo "  To upload scan results to your dashboard, you need an API key."
    if [ "$HAS_GUM" = true ]; then
        echo "  Get one free at: $(gum style --foreground "$GUM_CYAN" "https://clawkeeper.dev/signup")"
        echo ""
        api_key=$(gum input --placeholder "ck_live_..." --header "  Enter your API key (or press Enter to skip):" </dev/tty)
    else
        echo -e "  Get one free at: ${CYAN}https://clawkeeper.dev/signup${RESET}"
        echo ""
        echo "  Enter your API key (or press Enter to scan locally without uploading):"
        printf "  > "
        read -r api_key </dev/tty
    fi

    if [ -z "$api_key" ]; then
        echo ""
        dim_msg "  No API key entered. To connect later:"
        if [ "$HAS_GUM" = true ]; then
            dim_msg "    1. Sign up at $(gum style --foreground "$GUM_CYAN" "https://clawkeeper.dev/signup")"
            dim_msg "    2. Run $(gum style --foreground "$GUM_CYAN" "clawkeeper.sh agent --install")"
            echo ""
            echo "  $(gum style --foreground "$GUM_DIM" "To scan locally without uploading:") $(gum style --foreground "$GUM_CYAN" "clawkeeper.sh scan")"
        else
            echo -e "  ${DIM}  1. Sign up at ${RESET}${CYAN}https://clawkeeper.dev/signup${RESET}"
            echo -e "  ${DIM}  2. Run ${RESET}${CYAN}clawkeeper.sh agent --install${RESET}"
            echo ""
            echo -e "  ${DIM}To scan locally without uploading:${RESET} ${CYAN}clawkeeper.sh scan${RESET}"
        fi
        echo ""
        exit 0
    fi

    # Validate key format
    if [[ ! "$api_key" =~ ^ck_live_ ]]; then
        if [ "$HAS_GUM" = true ]; then
            warn_msg "Key doesn't start with ck_live_ — are you sure this is correct?"
            if ! gum confirm --default=no "  Continue?" </dev/tty; then
                exit 1
            fi
        else
            echo -e "  ${YELLOW}Warning:${RESET} Key doesn't start with ck_live_ — are you sure this is correct?"
            printf "  Continue? [y/N] "
            read -r confirm </dev/tty
            if [[ ! "$confirm" =~ ^[yY] ]]; then
                exit 1
            fi
        fi
    fi

    # Optional: custom API URL
    local api_url="${CLAWKEEPER_API_URL:-$AGENT_API_URL}"
    echo ""
    dim_msg "  API endpoint: $api_url"
    dim_msg "  (Set CLAWKEEPER_API_URL env var to override)"

    # Create config directory
    mkdir -p "$AGENT_CONFIG_DIR"

    # Write config
    cat > "$AGENT_CONFIG_FILE" <<EOF
# Clawkeeper Agent Configuration
# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
CLAWKEEPER_API_KEY="$api_key"
CLAWKEEPER_API_URL="$api_url"
EOF
    chmod 600 "$AGENT_CONFIG_FILE"

    echo ""
    ok_msg "Config saved to $AGENT_CONFIG_FILE"

    # Resolve our own path for the scheduler
    local self_path
    self_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

    # Platform-specific scheduler
    if [ "$(uname -s)" = "Darwin" ]; then
        local plist_dest
        plist_dest=$(agent_generate_plist "$self_path")
        launchctl unload "$plist_dest" 2>/dev/null || true
        launchctl load "$plist_dest"
        ok_msg "LaunchAgent installed and loaded"
        dim_msg "    Runs hourly. Plist: $plist_dest"
    elif [ "$(uname -s)" = "Linux" ]; then
        local timer_path
        timer_path=$(agent_generate_systemd "$self_path")
        ok_msg "Systemd user timer installed and enabled"
        dim_msg "    Runs hourly. Timer: $timer_path"
    else
        warn_msg "Unsupported platform for scheduled scans."
        dim_msg "    The agent still works manually: clawkeeper.sh agent run"
    fi

    # Run first scan
    echo ""
    accent_msg "  Running first scan..."
    echo ""
    agent_run

    report_event "agent.installed"

    echo ""
    if [ "$HAS_GUM" = true ]; then
        gum style --bold --foreground "$GUM_GREEN" -- "  Agent installed successfully!"
        echo "  $(gum style --foreground "$GUM_DIM" "View your dashboard at") $(gum style --foreground "$GUM_CYAN" "clawkeeper.dev")"
    else
        echo -e "  ${GREEN}${BOLD}Agent installed successfully!${RESET}"
        echo -e "  ${DIM}View your dashboard at ${RESET}${CYAN}clawkeeper.dev${RESET}"
    fi
    echo ""
}

agent_run() {
    agent_load_config

    local api_url="${CLAWKEEPER_API_URL:-$AGENT_API_URL}"
    local api_key="${CLAWKEEPER_API_KEY:-}"

    if [ -z "$api_key" ]; then
        agent_log "ERROR: No API key configured"
        exit 1
    fi

    # Resolve our own path
    local self_path
    self_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

    # Run scan and capture report
    local report_file
    report_file=$(mktemp /tmp/clawkeeper-report.XXXXXX)

    report_event "agent.started"

    agent_log "Running clawkeeper scan..."

    # Run scan in non-interactive mode, capture output
    "$self_path" scan --report "$report_file" --non-interactive 2>/dev/null || true

    if [ ! -f "$report_file" ]; then
        agent_log "ERROR: Scan did not produce a report file"
        exit 1
    fi

    # Parse the report file
    local hostname platform os_version
    hostname=$(hostname)
    platform="unknown"
    os_version="unknown"

    case "$(uname -s)" in
        Darwin)
            platform="macos"
            os_version=$(sw_vers -productVersion 2>/dev/null || echo "unknown")
            ;;
        Linux)
            platform="linux"
            os_version=$(grep -oP 'VERSION_ID="\K[^"]+' /etc/os-release 2>/dev/null || echo "unknown")
            ;;
    esac

    # Extract metrics from the report
    local score=0 passed=0 failed=0 fixed_count=0 skipped_count=0 grade="F"

    if grep -q "^Score:" "$report_file"; then
        score=$(grep "^Score:" "$report_file" | head -1 | sed 's/Score: *\([0-9]*\).*/\1/')
    fi
    if grep -q "^Passed:" "$report_file"; then
        passed=$(grep "^Passed:" "$report_file" | head -1 | sed 's/Passed: *//')
    fi
    if grep -q "^Failed:" "$report_file"; then
        failed=$(grep "^Failed:" "$report_file" | head -1 | sed 's/Failed: *//')
    fi
    if grep -q "^Fixed:" "$report_file"; then
        fixed_count=$(grep "^Fixed:" "$report_file" | head -1 | sed 's/Fixed: *//')
    fi
    if grep -q "^Accepted risks:" "$report_file"; then
        skipped_count=$(grep "^Accepted risks:" "$report_file" | head -1 | sed 's/Accepted risks: *//')
    fi

    # Calculate grade
    if [ "$score" -ge 95 ]; then grade="A"
    elif [ "$score" -ge 85 ]; then grade="B"
    elif [ "$score" -ge 70 ]; then grade="C"
    elif [ "$score" -ge 50 ]; then grade="D"
    else grade="F"
    fi

    # Parse individual checks from report (STATUS | CHECK_NAME | DETAIL)
    local checks_json="["
    local first=true
    while IFS='|' read -r status check_name detail; do
        # Trim whitespace
        status=$(echo "$status" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        check_name=$(echo "$check_name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        detail=$(echo "$detail" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # Skip empty or header lines
        [ -z "$status" ] && continue
        case "$status" in PASS|FAIL|FIXED|SKIPPED) ;; *) continue ;; esac

        # Escape JSON special characters
        detail=$(printf '%s' "$detail" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g')
        check_name=$(printf '%s' "$check_name" | sed 's/\\/\\\\/g; s/"/\\"/g')

        if [ "$first" = true ]; then
            first=false
        else
            checks_json="$checks_json,"
        fi

        checks_json="$checks_json{\"status\":\"$status\",\"check_name\":\"$check_name\",\"detail\":\"$detail\"}"
    done < <(grep -E '^\s*(PASS|FAIL|FIXED|SKIPPED)\s*\|' "$report_file" || true)
    checks_json="$checks_json]"

    # Read raw report — escape for JSON embedding
    local raw_report
    raw_report=$(sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g' "$report_file" | awk '{printf "%s\\n", $0}' | sed 's/\\n$//')

    local scanned_at
    scanned_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Build JSON payload (no jq dependency)
    # Use heredoc to avoid printf interpretation of % in report content
    local payload
    payload="{
  \"hostname\": \"$hostname\",
  \"platform\": \"$platform\",
  \"os_version\": \"$os_version\",
  \"score\": $score,
  \"grade\": \"$grade\",
  \"passed\": $passed,
  \"failed\": $failed,
  \"fixed\": $fixed_count,
  \"skipped\": $skipped_count,
  \"checks\": $checks_json,
  \"raw_report\": \"$raw_report\",
  \"scanned_at\": \"$scanned_at\",
  \"agent_version\": \"$AGENT_VERSION\",
  \"shield_active\": $([ -d "$HOME/.openclaw/skills/runtime-shield" ] && echo "true" || echo "false")
}"

    # Upload
    agent_log "Uploading scan to $api_url..."

    local http_code
    http_code=$(curl -s -o /tmp/clawkeeper-upload-response.json -w "%{http_code}" \
        -X POST "$api_url" \
        -H "Authorization: Bearer $api_key" \
        -H "Content-Type: application/json" \
        -d "$payload" 2>/dev/null || echo "000")

    if [ "$http_code" = "200" ]; then
        agent_log "Upload successful (HTTP $http_code)"
        ok_msg "Scan uploaded successfully"
    else
        agent_log "Upload failed (HTTP $http_code)"
        fail_msg "Upload failed (HTTP $http_code)"
        if [ -f /tmp/clawkeeper-upload-response.json ]; then
            local err_body
            err_body=$(cat /tmp/clawkeeper-upload-response.json)
            agent_log "Response: $err_body"
            # Try to extract "error" field from JSON response
            local err_msg
            err_msg=$(echo "$err_body" | sed -n 's/.*"error" *: *"\([^"]*\)".*/\1/p')
            if [ -n "$err_msg" ]; then
                dim_msg "  $err_msg"
            fi
        fi
    fi

    report_event "agent.stopped"

    # Cleanup
    rm -f "$report_file" /tmp/clawkeeper-upload-response.json
}

agent_uninstall() {
    echo ""
    accent_bold_msg "  Clawkeeper Agent Uninstall"
    echo ""

    report_event "agent.uninstalled"

    # Remove scheduler
    if [ "$(uname -s)" = "Darwin" ]; then
        local plist="$HOME/Library/LaunchAgents/$AGENT_PLIST_LABEL.plist"
        if [ -f "$plist" ]; then
            launchctl unload "$plist" 2>/dev/null || true
            rm -f "$plist"
            ok_msg "LaunchAgent unloaded and removed"
        else
            dim_msg "  → No LaunchAgent found"
        fi
    elif [ "$(uname -s)" = "Linux" ]; then
        systemctl --user disable --now clawkeeper-agent.timer 2>/dev/null || true
        rm -f "$HOME/.config/systemd/user/clawkeeper-agent.service" \
              "$HOME/.config/systemd/user/clawkeeper-agent.timer"
        systemctl --user daemon-reload 2>/dev/null || true
        ok_msg "Systemd timer disabled and removed"
    fi

    # Remove config
    if [ -f "$AGENT_CONFIG_FILE" ]; then
        rm -f "$AGENT_CONFIG_FILE"
        ok_msg "Agent config removed"
    fi

    echo ""
    ok_msg "Clawkeeper agent uninstalled"
    echo ""
}

agent_status() {
    echo ""
    accent_bold_msg "  Clawkeeper Agent Status"
    echo ""

    # Config
    if [ -f "$AGENT_CONFIG_FILE" ]; then
        ok_msg "Config: $AGENT_CONFIG_FILE"
        local api_url
        api_url=$(grep 'CLAWKEEPER_API_URL=' "$AGENT_CONFIG_FILE" 2>/dev/null | cut -d'"' -f2)
        [ -n "$api_url" ] && dim_msg "    API: $api_url"
        if grep -q 'CLAWKEEPER_API_KEY="ck_' "$AGENT_CONFIG_FILE" 2>/dev/null; then
            ok_msg "API key: configured"
        else
            fail_msg "API key: not found"
        fi
    else
        fail_msg "Config: not found (run: clawkeeper.sh agent --install)"
    fi

    # Scheduler
    echo ""
    if [ "$(uname -s)" = "Darwin" ]; then
        local plist="$HOME/Library/LaunchAgents/$AGENT_PLIST_LABEL.plist"
        if [ -f "$plist" ]; then
            ok_msg "LaunchAgent: installed"
            if launchctl list 2>/dev/null | grep -q "$AGENT_PLIST_LABEL"; then
                ok_msg "Scheduler: loaded and active"
            else
                warn_msg "Scheduler: installed but not loaded"
                dim_msg "    Fix: launchctl load $plist"
            fi
        else
            fail_msg "LaunchAgent: not installed"
        fi
    elif [ "$(uname -s)" = "Linux" ]; then
        if systemctl --user is-enabled clawkeeper-agent.timer &>/dev/null; then
            ok_msg "Systemd timer: enabled"
            if systemctl --user is-active clawkeeper-agent.timer &>/dev/null; then
                ok_msg "Scheduler: active"
            else
                warn_msg "Scheduler: enabled but not active"
            fi
        else
            fail_msg "Systemd timer: not installed"
        fi
    fi

    # Last run
    echo ""
    local log_file="$AGENT_CONFIG_DIR/agent.log"
    if [ -f "$log_file" ]; then
        local last_line
        last_line=$(tail -1 "$log_file" 2>/dev/null)
        dim_msg "  Last log entry: $last_line"
    else
        dim_msg "  No agent log found"
    fi
    echo ""
}

agent_main() {
    local subcmd="${1:-}"
    shift 2>/dev/null || true

    case "$subcmd" in
        --install|install)
            agent_install
            ;;
        run)
            agent_run
            ;;
        --uninstall|uninstall)
            agent_uninstall
            ;;
        --status|status)
            agent_status
            ;;
        --help|help|"")
            echo "Usage: clawkeeper.sh agent [--install|run|--uninstall|--status]"
            echo ""
            echo "  --install     Configure API key and install scheduled scans"
            echo "  run           Run scan and upload (used by scheduler)"
            echo "  --uninstall   Remove agent and config"
            echo "  --status      Show agent status"
            exit 1
            ;;
    esac
}

# === Deploy (OpenClaw installation) ======================================

# ============================================================================
# Clawkeeper Deploy — OpenClaw installation and deployment (native + Docker)
# Concatenated by bundle.sh — do NOT add a shebang here.
#
# By RAD Security — https://rad.security
# ============================================================================

# --- Native (npm/npx) Deployment -------------------------------------------

OPENCLAW_NATIVE_DIR="$HOME/.openclaw"
OPENCLAW_NATIVE_WORKSPACE="$HOME/openclaw/workspace"

# Direct OpenClaw global install — bypasses the check/remediation JSON pipeline
# so we get a real binary in PATH before creating the LaunchAgent.
install_openclaw_global() {
    step_header "Install OpenClaw (npm)"

    # Already installed globally?
    if command -v openclaw >/dev/null 2>&1; then
        local ver
        ver=$(openclaw --version 2>/dev/null || echo "unknown")
        pass "OpenClaw is already installed globally ($ver)" "OpenClaw npm"
        return 0
    fi

    if ! command -v npm >/dev/null 2>&1; then
        fail "npm not available — install Node.js first" "OpenClaw npm"
        return 1
    fi

    info "Installing openclaw globally via npm..."
    local npm_output npm_rc
    npm_output=$(npm install -g openclaw@latest 2>&1)
    npm_rc=$?

    if [ $npm_rc -ne 0 ]; then
        warn "npm install -g failed (exit $npm_rc). Output:"
        echo "$npm_output" | tail -10 | while IFS= read -r line; do
            dim_msg "    $line"
        done
        # Try with sudo as fallback
        info "Retrying with sudo..."
        npm_output=$(sudo npm install -g openclaw@latest 2>&1)
        npm_rc=$?
        if [ $npm_rc -ne 0 ]; then
            fail "OpenClaw installation failed even with sudo" "OpenClaw npm"
            echo "$npm_output" | tail -5 | while IFS= read -r line; do
                dim_msg "    $line"
            done
            return 1
        fi
    fi

    # Refresh shell hash table so command -v sees the new binary
    hash -r 2>/dev/null || true

    if command -v openclaw >/dev/null 2>&1; then
        local new_ver
        new_ver=$(openclaw --version 2>/dev/null || echo "installed")
        fixed "OpenClaw $new_ver installed globally" "OpenClaw npm"
        info "Binary at: $(command -v openclaw)"
        return 0
    else
        fail "OpenClaw installed but not found in PATH" "OpenClaw npm"
        info "You may need to restart your terminal or add npm's global bin to PATH."
        # Try to find where npm put it
        local npm_bin
        npm_bin=$(npm config get prefix 2>/dev/null)/bin
        if [ -x "$npm_bin/openclaw" ]; then
            info "Found at: $npm_bin/openclaw"
            info "Add to PATH: export PATH=\"$npm_bin:\$PATH\""
        fi
        return 1
    fi
}

setup_native_openclaw_directories() {
    step_header "OpenClaw Directory Structure (Native)"
    info "Creating directories with secure permissions."

    for dir in "$OPENCLAW_NATIVE_DIR" "$OPENCLAW_NATIVE_WORKSPACE"; do
        if [ -d "$dir" ]; then
            local perms
            perms=$(stat -f "%OLp" "$dir" 2>/dev/null || stat -c "%a" "$dir" 2>/dev/null || echo "unknown")
            if [ "$perms" = "700" ]; then
                ok_msg "$dir exists (permissions: 700)"
            else
                warn_msg "$dir exists but permissions are $perms"
                chmod 700 "$dir"
                ok_msg "Fixed permissions to 700"
            fi
        else
            mkdir -p "$dir"
            chmod 700 "$dir"
            ok_msg "Created $dir (permissions: 700)"
        fi
    done

    pass "Directory structure ready" "Native Directories"
}

setup_native_env_file() {
    step_header "Environment & Secrets (.env)"
    info "API keys and tokens should live in the .env file, never in config files."

    local env_file="$OPENCLAW_NATIVE_DIR/.env"

    if [ -f "$env_file" ]; then
        info ".env file already exists at $env_file"
        local perms
        perms=$(stat -f "%OLp" "$env_file" 2>/dev/null || stat -c "%a" "$env_file" 2>/dev/null || echo "unknown")
        if [ "$perms" != "600" ]; then
            chmod 600 "$env_file"
            info "Fixed .env permissions to 600"
        fi

        if grep -q "GATEWAY_TOKEN=" "$env_file" 2>/dev/null; then
            pass ".env file exists with gateway token" "Native .env"
        else
            warn ".env exists but has no GATEWAY_TOKEN"
            local token
            token=$(generate_gateway_token)
            if [ -n "$token" ]; then
                echo "GATEWAY_TOKEN=$token" >> "$env_file"
                fixed "Generated and added GATEWAY_TOKEN" "Native .env"
                echo ""
                highlight_msg "  SAVE THIS TOKEN — you need it to connect clients:"
                accent_msg "  $token"
                echo ""
            fi
        fi

        if grep -qE "(ANTHROPIC_API_KEY|OPENAI_API_KEY)=" "$env_file" 2>/dev/null; then
            pass "LLM API key configured in .env" "Native API Key"
        else
            warn "No LLM API key found in .env"
            if ask_yn "Add your Anthropic API key now?"; then
                local api_key
                api_key=$(read_secret "Paste your Anthropic API key (sk-ant-...):" "sk-ant-...")
                if [ -n "$api_key" ]; then
                    echo "ANTHROPIC_API_KEY=$api_key" >> "$env_file"
                    fixed "Anthropic API key added to .env" "Native API Key"
                    unset api_key
                else
                    fail "No key provided" "Native API Key"
                fi
            else
                info "You can add it later: echo 'ANTHROPIC_API_KEY=sk-ant-...' >> $env_file"
                skipped "No LLM API key configured" "Native API Key"
            fi
        fi
        return
    fi

    # Create new .env file
    info "Creating .env file with gateway token..."
    local token
    token=$(generate_gateway_token)

    if [ -z "$token" ]; then
        fail "Could not generate gateway token" "Native .env"
        return
    fi

    {
        echo "# CLAW Keeper — OpenClaw native environment"
        echo "# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        echo ""
        echo "# Gateway authentication token (required)"
        echo "GATEWAY_TOKEN=$token"
        echo ""
        echo "# LLM API key — uncomment and fill in your provider"
        echo "# ANTHROPIC_API_KEY=sk-ant-..."
        echo "# OPENAI_API_KEY=sk-..."
    } > "$env_file"

    chmod 600 "$env_file"

    echo ""
    highlight_msg "  SAVE THIS GATEWAY TOKEN — you need it to connect clients:"
    accent_msg "  $token"
    echo ""

    if ask_yn "Add your Anthropic API key now?"; then
        local api_key
        api_key=$(read_secret "Paste your Anthropic API key (sk-ant-...):" "sk-ant-...")
        if [ -n "$api_key" ]; then
            sed -i.bak "s|# ANTHROPIC_API_KEY=sk-ant-...|ANTHROPIC_API_KEY=$api_key|" "$env_file" 2>/dev/null || {
                echo "ANTHROPIC_API_KEY=$api_key" >> "$env_file"
            }
            rm -f "${env_file}.bak"
            fixed "Anthropic API key added" "Native API Key"
            unset api_key
        else
            info "Skipped — add it later by editing $env_file"
        fi
    else
        info "Add your API key later: edit $env_file"
    fi

    fixed ".env file created (permissions: 600)" "Native .env"
}

setup_native_launchd() {
    step_header "Auto-Start (launchd)"
    info "A LaunchAgent can start OpenClaw automatically when you log in."

    local plist_dir="$HOME/Library/LaunchAgents"
    local plist_file="$plist_dir/com.openclaw.agent.plist"

    if [ -f "$plist_file" ]; then
        pass "LaunchAgent already exists at $plist_file" "LaunchAgent"
        return
    fi

    if ! ask_yn "Create a LaunchAgent to auto-start OpenClaw on login?"; then
        skipped "LaunchAgent not created" "LaunchAgent"
        return
    fi

    mkdir -p "$plist_dir"

    local openclaw_bin
    openclaw_bin=$(command -v openclaw 2>/dev/null || echo "")

    if [ -z "$openclaw_bin" ] || [ ! -x "$openclaw_bin" ]; then
        fail "Cannot create LaunchAgent — openclaw binary not found in PATH" "LaunchAgent"
        info "Run 'npm install -g openclaw@latest' first, then re-run setup."
        return
    fi

    local env_file="$OPENCLAW_NATIVE_DIR/.env"
    local gateway_token=""
    if [ -f "$env_file" ]; then
        gateway_token=$(grep "^GATEWAY_TOKEN=" "$env_file" 2>/dev/null | cut -d= -f2 || echo "")
    fi

    cat > "$plist_file" << PLIST_EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.openclaw.agent</string>
    <key>ProgramArguments</key>
    <array>
        <string>${openclaw_bin}</string>
        <string>gateway</string>
        <string>--port</string>
        <string>18789</string>
    </array>
    <key>WorkingDirectory</key>
    <string>${OPENCLAW_NATIVE_WORKSPACE}</string>
    <key>EnvironmentVariables</key>
    <dict>
        <key>OPENCLAW_DISABLE_BONJOUR</key>
        <string>1</string>
        <key>GATEWAY_TOKEN</key>
        <string>${gateway_token}</string>
    </dict>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
    <key>StandardOutPath</key>
    <string>${HOME}/.openclaw/openclaw.log</string>
    <key>StandardErrorPath</key>
    <string>${HOME}/.openclaw/openclaw-error.log</string>
</dict>
</plist>
PLIST_EOF

    chmod 644 "$plist_file"
    fixed "LaunchAgent created at $plist_file" "LaunchAgent"
    info "It will auto-start OpenClaw next time you log in."

    if ask_yn "Load and start OpenClaw now?"; then
        # Verify binary one more time right before loading
        if [ ! -x "$openclaw_bin" ]; then
            fail "Binary not found at $openclaw_bin — cannot start" "LaunchAgent Start"
            return
        fi

        info "Loading LaunchAgent..."
        if ! launchctl load "$plist_file" 2>&1; then
            fail "launchctl load failed" "LaunchAgent Start"
            info "Try manually: launchctl load $plist_file"
            return
        fi

        info "Waiting for OpenClaw to start (up to 20 seconds)..."
        local waited=0
        local oc_started=false
        while [ $waited -lt 20 ]; do
            if pgrep -f "openclaw (gateway|server|start)" >/dev/null 2>&1; then
                oc_started=true
                break
            fi
            # Also check if the port is listening (gateway default 18789)
            if command -v lsof >/dev/null 2>&1 && lsof -i :18789 >/dev/null 2>&1; then
                oc_started=true
                break
            fi
            sleep 2
            waited=$((waited + 2))
            echo -ne "  ${DIM}  Waiting... (${waited}s)${RESET}\r"
        done
        echo ""
        if [ "$oc_started" = true ]; then
            fixed "OpenClaw is running" "LaunchAgent Start"
        else
            # Check launchctl for the real error
            local lctl_status
            lctl_status=$(launchctl list 2>/dev/null | grep "openclaw" || echo "")
            if [ -n "$lctl_status" ]; then
                local exit_code
                exit_code=$(echo "$lctl_status" | awk '{print $1}')
                if [ "$exit_code" != "0" ] && [ "$exit_code" != "-" ]; then
                    fail "OpenClaw crashed on startup (exit code: $exit_code)" "LaunchAgent Start"
                    info "Binary path in plist: $openclaw_bin"
                    if [ -s "$HOME/.openclaw/openclaw-error.log" ]; then
                        info "Error log:"
                        tail -5 "$HOME/.openclaw/openclaw-error.log" | while read -r line; do
                            dim_msg "    $line"
                        done
                    else
                        info "No error log found — the binary may not exist at the configured path."
                    fi
                else
                    warn "LaunchAgent is loaded but OpenClaw hasn't started yet."
                    info "Check logs: cat ~/.openclaw/openclaw.log"
                fi
            else
                fail "LaunchAgent not found in launchctl — load may have failed silently" "LaunchAgent Start"
                info "Try: launchctl load $plist_file"
            fi
        fi
    fi
}

# --- Docker -----------------------------------------------------------------

harden_docker_desktop() {
    # Check and fix Docker Desktop settings
    local docker_settings="$HOME/Library/Group Containers/group.com.docker/settings.json"

    if [ ! -f "$docker_settings" ]; then
        info "Docker Desktop settings file not found — using defaults"
        return
    fi

    local issues=()

    # Check telemetry
    if grep -q '"analyticsEnabled".*true' "$docker_settings" 2>/dev/null; then
        issues+=("telemetry")
    fi

    # Check resource limits (warn if very high or unlimited)
    local mem_limit
    mem_limit=$(grep -o '"memoryMiB"[[:space:]]*:[[:space:]]*[0-9]*' "$docker_settings" 2>/dev/null | grep -o '[0-9]*' || echo "0")
    if [ "$mem_limit" -gt 8192 ] 2>/dev/null; then
        issues+=("memory")
    fi

    local cpu_limit
    cpu_limit=$(grep -o '"cpus"[[:space:]]*:[[:space:]]*[0-9]*' "$docker_settings" 2>/dev/null | grep -o '[0-9]*' || echo "0")
    if [ "$cpu_limit" -gt 4 ] 2>/dev/null; then
        issues+=("cpu")
    fi

    if [ ${#issues[@]} -eq 0 ]; then
        pass "Docker Desktop settings look reasonable" "Docker Settings"
        return
    fi

    echo ""
    accent_msg "  Docker Desktop hardening:"

    for issue in "${issues[@]}"; do
        case "$issue" in
            telemetry)
                warn "Docker Desktop analytics/telemetry is enabled"
                info "Disable: Docker Desktop → Settings → General → uncheck 'Send usage statistics'"
                ;;
            memory)
                warn "Docker memory limit is high (${mem_limit}MB)"
                info "Recommend 4096MB max: Docker Desktop → Settings → Resources → Memory"
                ;;
            cpu)
                warn "Docker CPU limit is high (${cpu_limit} CPUs)"
                info "Recommend 2 CPUs max: Docker Desktop → Settings → Resources → CPUs"
                ;;
        esac
    done

    fail "Docker Desktop settings need hardening (adjust manually in Docker Desktop → Settings)" "Docker Settings"
}

# --- OpenClaw Docker Deployment ---------------------------------------------

OPENCLAW_DIR="$HOME/openclaw-docker"
OPENCLAW_CONFIG_DIR="$HOME/.openclaw"
OPENCLAW_WORKSPACE="$HOME/openclaw/workspace"

setup_openclaw_directories() {
    step_header "OpenClaw Directory Structure"
    info "Creating directories with secure permissions."

    local dirs_ok=true

    for dir in "$OPENCLAW_CONFIG_DIR" "$OPENCLAW_WORKSPACE" "$OPENCLAW_DIR"; do
        if [ -d "$dir" ]; then
            local perms
            perms=$(stat -f "%OLp" "$dir" 2>/dev/null || stat -c "%a" "$dir" 2>/dev/null || echo "unknown")
            if [ "$perms" = "700" ]; then
                ok_msg "$dir exists (permissions: 700)"
            else
                warn_msg "$dir exists but permissions are $perms"
                chmod 700 "$dir"
                ok_msg "Fixed permissions to 700"
            fi
        else
            mkdir -p "$dir"
            chmod 700 "$dir"
            ok_msg "Created $dir (permissions: 700)"
        fi
    done

    pass "Directory structure ready" "Directories"
}

generate_gateway_token() {
    # Generate a cryptographically strong token
    local token
    token=$(openssl rand -hex 24 2>/dev/null || LC_ALL=C tr -dc 'a-f0-9' < /dev/urandom | head -c 48 2>/dev/null || echo "")

    if [ -z "$token" ]; then
        warn "Could not generate random token"
        return 1
    fi

    echo "$token"
}

setup_env_file() {
    step_header "Environment & Secrets (.env)"
    info "API keys and tokens should live in the .env file, never in config files."

    local env_file="$OPENCLAW_DIR/.env"

    if [ -f "$env_file" ]; then
        info ".env file already exists at $env_file"
        local perms
        perms=$(stat -f "%OLp" "$env_file" 2>/dev/null || stat -c "%a" "$env_file" 2>/dev/null || echo "unknown")
        if [ "$perms" != "600" ]; then
            chmod 600 "$env_file"
            info "Fixed .env permissions to 600"
        fi

        # Check if GATEWAY_TOKEN exists
        if grep -q "GATEWAY_TOKEN=" "$env_file" 2>/dev/null; then
            pass ".env file exists with gateway token" ".env Setup"
        else
            warn ".env exists but has no GATEWAY_TOKEN"
            local token
            token=$(generate_gateway_token)
            if [ -n "$token" ]; then
                echo "GATEWAY_TOKEN=$token" >> "$env_file"
                fixed "Generated and added GATEWAY_TOKEN" ".env Setup"
                echo ""
                highlight_msg "  SAVE THIS TOKEN — you need it to connect clients:"
                accent_msg "  $token"
                echo ""
            fi
        fi

        # Check for API key
        if grep -qE "(ANTHROPIC_API_KEY|OPENAI_API_KEY)=" "$env_file" 2>/dev/null; then
            pass "LLM API key configured in .env" "API Key"
        else
            warn "No LLM API key found in .env"
            if ask_yn "Add your Anthropic API key now?"; then
                local api_key
                api_key=$(read_secret "Paste your Anthropic API key (sk-ant-...):" "sk-ant-...")
                if [ -n "$api_key" ]; then
                    echo "ANTHROPIC_API_KEY=$api_key" >> "$env_file"
                    fixed "Anthropic API key added to .env" "API Key"
                    unset api_key
                else
                    fail "No key provided" "API Key"
                fi
            else
                info "You can add it later: echo 'ANTHROPIC_API_KEY=sk-ant-...' >> $env_file"
                skipped "No LLM API key configured" "API Key"
            fi
        fi
        return
    fi

    # Create new .env file
    info "Creating .env file with gateway token..."
    local token
    token=$(generate_gateway_token)

    if [ -z "$token" ]; then
        fail "Could not generate gateway token" ".env Setup"
        return
    fi

    echo "# CLAW Keeper — OpenClaw Docker environment" > "$env_file"
    echo "# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> "$env_file"
    echo "" >> "$env_file"
    echo "# Gateway authentication token (required)" >> "$env_file"
    echo "GATEWAY_TOKEN=$token" >> "$env_file"
    echo "" >> "$env_file"
    echo "# LLM API key — uncomment and fill in your provider" >> "$env_file"
    echo "# ANTHROPIC_API_KEY=sk-ant-..." >> "$env_file"
    echo "# OPENAI_API_KEY=sk-..." >> "$env_file"

    chmod 600 "$env_file"

    echo ""
    highlight_msg "  SAVE THIS GATEWAY TOKEN — you need it to connect clients:"
    accent_msg "  $token"
    echo ""

    if ask_yn "Add your Anthropic API key now?"; then
        local api_key
        api_key=$(read_secret "Paste your Anthropic API key (sk-ant-...):" "sk-ant-...")
        if [ -n "$api_key" ]; then
            # Replace the placeholder line
            sed -i.bak "s|# ANTHROPIC_API_KEY=sk-ant-...|ANTHROPIC_API_KEY=$api_key|" "$env_file" 2>/dev/null || {
                echo "ANTHROPIC_API_KEY=$api_key" >> "$env_file"
            }
            rm -f "${env_file}.bak"
            fixed "Anthropic API key added" "API Key"
            unset api_key
        else
            info "Skipped — add it later by editing $env_file"
        fi
    else
        info "Add your API key later: edit $env_file"
    fi

    fixed ".env file created (permissions: 600)" ".env Setup"
}

setup_docker_compose() {
    step_header "Docker Compose Configuration"
    info "Generating hardened docker-compose.yml for OpenClaw."

    local compose_file="$OPENCLAW_DIR/docker-compose.yml"

    if [ -f "$compose_file" ]; then
        info "docker-compose.yml already exists at $compose_file"

        if ask_yn "Overwrite with hardened configuration? (backup will be saved)"; then
            cp "$compose_file" "${compose_file}.backup.$(date +%s)"
            info "Backup saved"
        else
            pass "Existing docker-compose.yml kept" "Docker Compose"
            return
        fi
    fi

    # --- Image selection ---
    local openclaw_image="us-docker.pkg.dev/prod-375107/minimus-public/openclaw:latest"

    echo ""
    accent_msg "  Which OpenClaw Docker image would you like to use?"
    echo ""
    dim_msg "    1) Minimus hardened (recommended) — 99% fewer CVEs"
    dim_msg "       us-docker.pkg.dev/prod-375107/minimus-public/openclaw:latest"
    echo ""
    dim_msg "    2) Official"
    dim_msg "       ghcr.io/openclaw/openclaw:latest"
    echo ""

    local image_choice
    if [ "$HAS_GUM" = true ]; then
        image_choice=$(gum choose "1) Minimus hardened (recommended)" "2) Official")
        case "$image_choice" in
            2*) openclaw_image="ghcr.io/openclaw/openclaw:latest" ;;
        esac
    else
        read -r -p "  Choose [1/2] (default: 1): " image_choice < /dev/tty
        case "$image_choice" in
            2) openclaw_image="ghcr.io/openclaw/openclaw:latest" ;;
        esac
    fi

    info "Using image: $openclaw_image"

    cat > "$compose_file" << 'COMPOSE_EOF'
services:
  openclaw:
    image: ghcr.io/openclaw/openclaw:latest
    container_name: openclaw
    restart: unless-stopped

    # --- Security: Run as non-root ---
    user: "1000:1000"

    # --- Security: Drop all capabilities, add only what's needed ---
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE

    # --- Security: Prevent privilege escalation ---
    security_opt:
      - no-new-privileges:true

    # --- Security: Read-only root filesystem ---
    read_only: true

    # --- Security: Resource limits (prevent runaway agent behavior) ---
    deploy:
      resources:
        limits:
          cpus: "2.0"
          memory: 4g
        reservations:
          cpus: "0.25"
          memory: 512m

    # --- Security: Bind to localhost ONLY ---
    ports:
      - "127.0.0.1:18789:18789"
      - "127.0.0.1:18790:18790"

    # --- Volumes ---
    volumes:
      - ${HOME}/.openclaw:/home/node/.openclaw:rw
      - ${HOME}/openclaw/workspace:/home/node/.openclaw/workspace:rw

    # --- Writable tmpfs for paths that need it (read-only root FS) ---
    tmpfs:
      - /tmp:size=100m,noexec,nosuid
      - /home/node/.npm:size=100m,noexec,nosuid

    # --- Environment: Secrets injected from .env ---
    environment:
      - OPENCLAW_DISABLE_BONJOUR=1
      - OPENCLAW_GATEWAY_TOKEN=${GATEWAY_TOKEN}
      # Uncomment your LLM provider:
      # - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      # - OPENAI_API_KEY=${OPENAI_API_KEY}

    # --- Security: Isolated Docker network ---
    networks:
      - openclaw-isolated

    # --- Health check ---
    healthcheck:
      test: ["CMD", "curl", "-sf", "http://localhost:18789/health", "-o", "/dev/null"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s

networks:
  openclaw-isolated:
    driver: bridge
    internal: false  # Needs internet for LLM APIs
COMPOSE_EOF

    # Replace image with user's selection
    if [ "$openclaw_image" != "ghcr.io/openclaw/openclaw:latest" ]; then
        sed -i.bak "s|image: ghcr.io/openclaw/openclaw:latest|image: $openclaw_image|" "$compose_file" 2>/dev/null || true
        rm -f "${compose_file}.bak"
    fi

    # Dynamically uncomment the correct API key line based on .env
    local env_file="$OPENCLAW_DIR/.env"
    if [ -f "$env_file" ]; then
        if grep -q "^ANTHROPIC_API_KEY=" "$env_file" 2>/dev/null; then
            sed -i.bak 's|# - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}|- ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}|' "$compose_file" 2>/dev/null || true
            rm -f "${compose_file}.bak"
        fi
        if grep -q "^OPENAI_API_KEY=" "$env_file" 2>/dev/null; then
            sed -i.bak 's|# - OPENAI_API_KEY=${OPENAI_API_KEY}|- OPENAI_API_KEY=${OPENAI_API_KEY}|' "$compose_file" 2>/dev/null || true
            rm -f "${compose_file}.bak"
        fi
    fi

    fixed "Hardened docker-compose.yml generated" "Docker Compose"

    echo ""
    accent_msg "  Security features enabled:"
    dim_msg "    • Non-root user (1000:1000)"
    dim_msg "    • All capabilities dropped (only NET_BIND_SERVICE added)"
    dim_msg "    • no-new-privileges enforced"
    dim_msg "    • Read-only root filesystem"
    dim_msg "    • CPU (2) and memory (4GB) limits"
    dim_msg "    • Ports bound to 127.0.0.1 only"
    dim_msg "    • tmpfs with noexec,nosuid"
    dim_msg "    • Bonjour/mDNS disabled"
    dim_msg "    • Isolated Docker network"
}

setup_openclaw_config() {
    step_header "OpenClaw Security Configuration"
    info "Generating hardened openclaw.json."

    local config_file="$OPENCLAW_CONFIG_DIR/openclaw.json"

    if [ -f "$config_file" ]; then
        info "openclaw.json already exists at $config_file"

        if ask_yn "Overwrite with hardened configuration? (backup will be saved)"; then
            cp "$config_file" "${config_file}.backup.$(date +%s)"
            info "Backup saved"
        else
            pass "Existing openclaw.json kept" "OpenClaw Config"
            return
        fi
    fi

    cat > "$config_file" << 'CONFIG_EOF'
{
  "gateway": {
    "port": 18789,
    "bind": "loopback",
    "auth": {
      "mode": "token",
      "allowTailscale": false
    },
    "controlUI": false,
    "discover": {
      "mode": "off"
    }
  },
  "exec": {
    "ask": "on"
  },
  "tools": {
    "exec": {
      "applyPatch": {
        "workspaceOnly": true
      }
    }
  },
  "logging": {
    "redactSensitive": "tools"
  }
}
CONFIG_EOF

    chmod 600 "$config_file"
    fixed "Hardened openclaw.json generated (permissions: 600)" "OpenClaw Config"

    echo ""
    accent_msg "  Configuration:"
    dim_msg "    • gateway.bind = loopback (localhost only)"
    dim_msg "    • gateway.auth.mode = token (required for every connection)"
    dim_msg "    • gateway.controlUI = false (web UI disabled)"
    dim_msg "    • gateway.discover.mode = off (no mDNS broadcast)"
    dim_msg "    • exec.ask = on (agent asks before every command)"
    dim_msg "    • applyPatch.workspaceOnly = true (agent can't write outside workspace)"
    dim_msg "    • logging.redactSensitive = tools (keys redacted in logs)"
}

deploy_openclaw_docker() {
    step_header "Deploy OpenClaw Container"

    if ! command -v docker &>/dev/null || ! docker info &>/dev/null; then
        fail "Docker is not available — install and start Docker first" "Deploy"
        return
    fi

    local compose_file="$OPENCLAW_DIR/docker-compose.yml"
    if [ ! -f "$compose_file" ]; then
        fail "No docker-compose.yml found — run setup steps first" "Deploy"
        return
    fi

    # Check if already running
    if docker ps --format '{{.Names}}' 2>/dev/null | grep -q "^openclaw$"; then
        warn "OpenClaw container is already running"

        if ask_yn "Restart with current configuration?"; then
            info "Restarting container..."
            cd "$OPENCLAW_DIR" && docker compose down 2>/dev/null || true
            cd "$OPENCLAW_DIR" && docker compose up -d 2>&1 | tail -5
            fixed "OpenClaw container restarted" "Deploy"
        else
            pass "OpenClaw container running (not restarted)" "Deploy"
        fi
        return
    fi

    if ask_yn "Pull the latest OpenClaw image and start the container?"; then
        if [ "$HAS_GUM" = true ]; then
            gum spin --spinner "$GUM_SPINNER" --title "  Pulling latest OpenClaw image..." -- \
                bash -c "cd '$OPENCLAW_DIR' && docker compose pull 2>&1 | tail -3"
        else
            info "Pulling latest OpenClaw image..."
            cd "$OPENCLAW_DIR" && docker compose pull 2>&1 | tail -3
        fi

        info "Starting container..."
        cd "$OPENCLAW_DIR" && docker compose up -d 2>&1 | tail -5

        # Wait for healthy
        if [ "$HAS_GUM" = true ]; then
            gum spin --spinner "$GUM_SPINNER" --title "  Waiting for OpenClaw to start..." -- \
                bash -c 'waited=0; while [ $waited -lt 30 ]; do docker ps --format "{{.Names}} {{.Status}}" 2>/dev/null | grep "openclaw" | grep -qi "healthy\|Up" && exit 0; sleep 3; waited=$((waited + 3)); done; exit 1'
            if [ $? -eq 0 ]; then
                echo ""
                fixed "OpenClaw container is running" "Deploy"
                echo ""
                accent_msg "  Recent container logs:"
                docker logs --tail 10 openclaw 2>&1 | while read -r line; do
                    dim_msg "    $line"
                done
                return
            fi
        else
            info "Waiting for OpenClaw to start (up to 30 seconds)..."
            local waited=0
            while [ $waited -lt 30 ]; do
                if docker ps --format '{{.Names}} {{.Status}}' 2>/dev/null | grep "openclaw" | grep -qi "healthy\|Up"; then
                    echo ""
                    fixed "OpenClaw container is running" "Deploy"

                    # Show logs briefly
                    echo ""
                    accent_msg "  Recent container logs:"
                    docker logs --tail 10 openclaw 2>&1 | while read -r line; do
                        dim_msg "    $line"
                    done
                    return
                fi
                sleep 3
                waited=$((waited + 3))
                echo -ne "  ${DIM}  Waiting... (${waited}s)${RESET}\r"
            done
        fi
        echo ""
        warn "Container started but may still be initializing"
        info "Check logs: docker logs -f openclaw"
        pass "OpenClaw container started (verify with docker logs)" "Deploy"
    else
        skipped "OpenClaw container not started" "Deploy"
    fi
}

# === Uninstall (secure removal) ==========================================

# ============================================================================
# Clawkeeper Uninstall — Secure removal of OpenClaw
# Concatenated by bundle.sh — do NOT add a shebang here.
#
# By RAD Security — https://rad.security
# ============================================================================

uninstall_openclaw() {
    print_banner
    echo ""
    error_bold_msg "  OpenClaw Secure Removal"
    echo ""
    dim_msg "  This will permanently remove OpenClaw and securely wipe sensitive data."
    if [ "$HAS_GUM" = true ]; then
        echo "  $(gum style --foreground "$GUM_DIM" "Every step requires your confirmation. Nothing runs without") $(gum style --bold "[Y/n]")$(gum style --foreground "$GUM_DIM" ".")"
    else
        echo -e "  ${DIM}Every step requires your confirmation. Nothing runs without ${RESET}${BOLD}[Y/n]${RESET}${DIM}.${RESET}"
    fi
    echo ""

    detect_platform

    # Detect what's installed
    detect_openclaw_installed

    if [ "$OPENCLAW_INSTALLED" = false ]; then
        warn_msg "No OpenClaw installation detected."
        echo ""
        dim_msg "  Checked: Docker containers/images, npm global, LaunchAgents, processes"
        echo ""
        if ! ask_yn "Continue anyway to clean up leftover config/data files?"; then
            dim_msg "  Nothing to do. Exiting."
            exit 0
        fi
    fi

    local removed_something=false

    # ── Step 1: Stop running instances ──
    echo ""
    accent_bold_msg "  ── Step 1: Stop Running Instances ──"

    # Docker containers
    if command -v docker &>/dev/null && docker info &>/dev/null 2>&1; then
        local running_containers
        running_containers=$(docker ps --format '{{.Names}}' 2>/dev/null | grep -i "openclaw" || true)
        if [ -n "$running_containers" ]; then
            warn_msg "Found running OpenClaw containers:"
            echo "$running_containers" | while read -r c; do dim_msg "    $c"; done
            if ask_yn "Stop these containers?"; then
                echo "$running_containers" | while read -r c; do
                    docker stop "$c" 2>/dev/null && ok_msg "Stopped container: $c"
                done
                removed_something=true
            fi
        else
            dim_msg "  → No running OpenClaw containers"
        fi
    fi

    # Native processes
    local oc_pids
    oc_pids=$(pgrep -f "openclaw" 2>/dev/null || true)
    if [ -n "$oc_pids" ]; then
        warn_msg "Found OpenClaw processes:"
        ps -p "$(echo "$oc_pids" | tr '\n' ',')" -o pid,command 2>/dev/null | tail -n +2 | while read -r line; do
            dim_msg "    $line"
        done
        if ask_yn "Kill these processes?"; then
            echo "$oc_pids" | while read -r pid; do
                kill "$pid" 2>/dev/null && ok_msg "Killed PID $pid"
            done
            sleep 1
            # Force kill any survivors
            local remaining
            remaining=$(pgrep -f "openclaw" 2>/dev/null || true)
            if [ -n "$remaining" ]; then
                echo "$remaining" | while read -r pid; do
                    kill -9 "$pid" 2>/dev/null || true
                done
                ok_msg "Force-killed remaining processes"
            fi
            removed_something=true
        fi
    else
        dim_msg "  → No running OpenClaw processes"
    fi

    # ── Step 2: Remove LaunchAgent (macOS) ──
    if [ "$PLATFORM" = "macos" ]; then
        echo ""
        accent_bold_msg "  ── Step 2: Remove LaunchAgents ──"

        local plist_file="$HOME/Library/LaunchAgents/com.openclaw.agent.plist"
        if [ -f "$plist_file" ]; then
            warn_msg "Found LaunchAgent: $plist_file"
            if ask_yn "Unload and remove this LaunchAgent?"; then
                launchctl unload "$plist_file" 2>/dev/null || true
                rm -f "$plist_file"
                ok_msg "LaunchAgent unloaded and removed"
                removed_something=true
            fi
        else
            dim_msg "  → No OpenClaw LaunchAgent found"
        fi
    fi

    # ── Step 3: Remove Docker resources ──
    if command -v docker &>/dev/null && docker info &>/dev/null 2>&1; then
        echo ""
        accent_bold_msg "  ── Step 3: Remove Docker Resources ──"

        # Containers (stopped)
        local all_containers
        all_containers=$(docker ps -a --format '{{.Names}}' 2>/dev/null | grep -i "openclaw" || true)
        if [ -n "$all_containers" ]; then
            warn_msg "Found OpenClaw containers (including stopped):"
            echo "$all_containers" | while read -r c; do dim_msg "    $c"; done
            if ask_yn "Remove these containers?"; then
                echo "$all_containers" | while read -r c; do
                    docker rm -f "$c" 2>/dev/null && ok_msg "Removed container: $c"
                done
                removed_something=true
            fi
        else
            dim_msg "  → No OpenClaw containers to remove"
        fi

        # Images
        local oc_images
        oc_images=$(docker images --format '{{.Repository}}:{{.Tag}} ({{.ID}})' 2>/dev/null | grep -i "openclaw" || true)
        if [ -n "$oc_images" ]; then
            warn_msg "Found OpenClaw images:"
            echo "$oc_images" | while read -r img; do dim_msg "    $img"; done
            if ask_yn "Remove these images?"; then
                docker images --format '{{.ID}} {{.Repository}}' 2>/dev/null | grep -i "openclaw" | awk '{print $1}' | while read -r id; do
                    docker rmi -f "$id" 2>/dev/null && ok_msg "Removed image: $id"
                done
                removed_something=true
            fi
        else
            dim_msg "  → No OpenClaw images to remove"
        fi

        # Volumes
        local oc_volumes
        oc_volumes=$(docker volume ls --format '{{.Name}}' 2>/dev/null | grep -i "openclaw" || true)
        if [ -n "$oc_volumes" ]; then
            warn_msg "Found OpenClaw volumes:"
            echo "$oc_volumes" | while read -r v; do dim_msg "    $v"; done
            if ask_yn "Remove these volumes? (DATA WILL BE LOST)"; then
                echo "$oc_volumes" | while read -r v; do
                    docker volume rm "$v" 2>/dev/null && ok_msg "Removed volume: $v"
                done
                removed_something=true
            fi
        else
            dim_msg "  → No OpenClaw volumes to remove"
        fi
    fi

    # ── Step 4: Remove npm global package ──
    echo ""
    accent_bold_msg "  ── Step 4: Remove npm Package ──"

    if command -v openclaw &>/dev/null; then
        warn_msg "OpenClaw is installed globally via npm"
        if ask_yn "Uninstall openclaw npm package?"; then
            npm uninstall -g openclaw 2>&1 | tail -3
            if ! command -v openclaw &>/dev/null; then
                ok_msg "OpenClaw npm package removed"
            else
                warn_msg "openclaw still in PATH — may need manual removal"
            fi
            removed_something=true
        fi
    else
        dim_msg "  → No global OpenClaw npm package found"
    fi

    # ── Step 5: Securely wipe data directories ──
    echo ""
    accent_bold_msg "  ── Step 5: Secure Data Wipe ──"
    echo ""
    dim_msg "  The following directories may contain secrets, session logs, and config:"

    local data_dirs=(
        "$HOME/.openclaw"
        "$HOME/openclaw-docker"
        "$HOME/openclaw"
    )

    local dirs_to_wipe=()
    for dir in "${data_dirs[@]}"; do
        if [ -d "$dir" ]; then
            local dir_size
            dir_size=$(du -sh "$dir" 2>/dev/null | awk '{print $1}' || echo "?")
            warn_msg "$dir (${dir_size})"
            dirs_to_wipe+=("$dir")
        fi
    done

    if [ ${#dirs_to_wipe[@]} -eq 0 ]; then
        dim_msg "  → No OpenClaw data directories found"
    else
        echo ""
        error_bold_msg "  WARNING: This permanently deletes all OpenClaw data including:"
        dim_msg "    • Configuration files (openclaw.json, .env)"
        dim_msg "    • Session logs and conversation history"
        dim_msg "    • MEMORY.md, SOUL.md, skills"
        dim_msg "    • API keys and credentials stored in these directories"
        echo ""

        if ask_yn "Securely wipe these directories? (THIS CANNOT BE UNDONE)"; then
            for dir in "${dirs_to_wipe[@]}"; do
                dim_msg "  → Wiping $dir..."

                # Overwrite sensitive files before deletion
                # Find files that likely contain secrets and overwrite them
                while IFS= read -r sensitive_file; do
                    [ -z "$sensitive_file" ] && continue
                    if [ -f "$sensitive_file" ]; then
                        local fsize
                        fsize=$(wc -c < "$sensitive_file" 2>/dev/null | tr -d ' ')
                        if [ "$fsize" -gt 0 ] 2>/dev/null; then
                            dd if=/dev/urandom bs=1 count="$fsize" of="$sensitive_file" conv=notrunc 2>/dev/null || true
                        fi
                    fi
                done < <(find "$dir" -type f \( \
                    -name "*.json" -o -name "*.jsonl" -o -name ".env" -o \
                    -name "*.md" -o -name "*.yml" -o -name "*.yaml" -o \
                    -name "*.pem" -o -name "*.key" -o -name "*.token" -o \
                    -name "*.log" -o -name "*.sqlite" -o -name "*.db" \
                \) 2>/dev/null)

                # Remove the directory
                rm -rf "$dir"

                if [ ! -d "$dir" ]; then
                    ok_msg "Securely wiped: $dir"
                else
                    fail_msg "Failed to remove: $dir"
                fi
            done
            removed_something=true
        else
            dim_msg "  → Data directories preserved"
        fi
    fi

    # ── Step 6: Clean up docker-compose file ──
    local compose_file="$HOME/openclaw-docker/docker-compose.yml"
    if [ -f "$compose_file" ]; then
        # Already handled above in data dirs, but just in case
        :
    fi

    # ── Summary ──
    echo ""
    if [ "$HAS_GUM" = true ]; then
        gum style --bold --foreground "$GUM_CYAN" --border double --border-foreground "$GUM_BORDER_FG" --padding "0 2" -- ""
    else
        echo -e "  ${CYAN}${BOLD}════════════════════════════════════════════════════${RESET}"
    fi
    echo ""
    if [ "$removed_something" = true ]; then
        if [ "$HAS_GUM" = true ]; then
            gum style --bold --foreground "$GUM_GREEN" -- "  OpenClaw removal complete."
        else
            echo -e "  ${GREEN}${BOLD}OpenClaw removal complete.${RESET}"
        fi
        echo ""
        dim_msg "  What was cleaned:"
        dim_msg "    • Running processes and containers stopped"
        dim_msg "    • Docker images/volumes/containers removed"
        dim_msg "    • LaunchAgents unloaded"
        dim_msg "    • Sensitive files overwritten before deletion"
        dim_msg "    • Data directories removed"
    else
        dim_msg "  No changes were made."
    fi
    echo ""
    dim_msg "  Remaining manual steps (if applicable):"
    dim_msg "    • Check shell history for pasted API keys: history | grep sk-"
    dim_msg "    • Revoke any API keys generated for OpenClaw"
    dim_msg "    • Remove any firewall rules added for OpenClaw"
    echo ""
}

# === Shield (Runtime Shield management) ==================================

# ============================================================================
# Clawkeeper Shield — Runtime Shield skill management
# Concatenated by bundle.sh — do NOT add a shebang here.
#
# By RAD Security — https://rad.security
# ============================================================================

SHIELD_SKILL_DIR="$HOME/.openclaw/skills/runtime-shield"
SHIELD_CONFIG_DIR="$HOME/.clawkeeper"
SHIELD_LOG_DIR="$HOME/.clawkeeper/shield-logs"

shield_log() {
    echo "[$(date -u +"%Y-%m-%dT%H:%M:%SZ")] [shield] $*"
}

shield_is_installed() {
    [ -d "$SHIELD_SKILL_DIR" ] && [ -f "$SHIELD_SKILL_DIR/SKILL.md" ]
}

shield_check_npm() {
    if ! command -v npm &>/dev/null; then
        error_bold_msg "Error: npm is required to install the Runtime Shield skill."
        echo -e "  ${DIM}Install Node.js from https://nodejs.org${RESET}"
        return 1
    fi
}

shield_install() {
    echo ""
    echo -e "  ${CYAN}${BOLD}Runtime Shield Installation${RESET}"
    echo ""

    # Check prerequisites
    shield_check_npm || return 1

    if ! command -v openclaw &>/dev/null && [ ! -d "$HOME/.openclaw" ]; then
        error_bold_msg "Error: OpenClaw does not appear to be installed."
        echo -e "  ${DIM}Install OpenClaw first, then install the shield.${RESET}"
        return 1
    fi

    # Check if already installed
    if shield_is_installed; then
        success_msg "Runtime Shield is already installed."
        echo -e "  ${DIM}Location: $SHIELD_SKILL_DIR${RESET}"
        echo -e "  ${DIM}To reinstall: clawkeeper.sh shield uninstall && clawkeeper.sh shield install${RESET}"
        return 0
    fi

    # Create skill directory
    mkdir -p "$SHIELD_SKILL_DIR"

    # Find the runtime-shield source
    local source_dir=""
    local script_dir
    script_dir="$(cd "$(dirname "${BASH_SOURCE[0]:-$0}")" && pwd)"

    if [ -d "$script_dir/../runtime-shield" ]; then
        source_dir="$script_dir/../runtime-shield"
    elif [ -d "$script_dir/runtime-shield" ]; then
        source_dir="$script_dir/runtime-shield"
    fi

    if [ -z "$source_dir" ] || [ ! -f "$source_dir/SKILL.md" ]; then
        # Download from web
        echo -e "  ${DIM}Downloading Runtime Shield...${RESET}"
        local download_url="https://clawkeeper.dev/downloads/runtime-shield.tar.gz"
        if curl -fsSL "$download_url" | tar xz -C "$SHIELD_SKILL_DIR" 2>/dev/null; then
            shield_log "Downloaded Runtime Shield from $download_url"
        else
            error_bold_msg "Failed to download Runtime Shield."
            rm -rf "$SHIELD_SKILL_DIR"
            return 1
        fi
    else
        # Copy from local source
        echo -e "  ${DIM}Installing from local source...${RESET}"
        cp -R "$source_dir/"* "$SHIELD_SKILL_DIR/"
    fi

    # Install npm dependencies
    echo -e "  ${DIM}Installing dependencies...${RESET}"
    if ! (cd "$SHIELD_SKILL_DIR" && npm install --production --silent 2>/dev/null); then
        warn_msg "npm install failed — skill may still work if pre-built."
    fi

    # Build if needed
    if [ -f "$SHIELD_SKILL_DIR/tsconfig.json" ] && [ ! -d "$SHIELD_SKILL_DIR/dist" ]; then
        echo -e "  ${DIM}Building...${RESET}"
        (cd "$SHIELD_SKILL_DIR" && npx tsc 2>/dev/null) || true
    fi

    # Configure API key
    local api_key=""
    if [ -f "$SHIELD_CONFIG_DIR/config" ]; then
        # shellcheck disable=SC1090
        source "$SHIELD_CONFIG_DIR/config"
        api_key="${CLAWKEEPER_API_KEY:-}"
    fi

    if [ -z "$api_key" ]; then
        echo ""
        echo -e "  ${YELLOW}No API key found.${RESET} The shield will work in local-only mode."
        echo -e "  ${DIM}To connect to the dashboard, set CLAWKEEPER_API_KEY in:${RESET}"
        echo -e "  ${DIM}  $SHIELD_CONFIG_DIR/config${RESET}"
    else
        echo -e "  ${DIM}Using API key from existing agent configuration.${RESET}"
    fi

    # Create log directory
    mkdir -p "$SHIELD_LOG_DIR"

    # Report installation event
    report_event "shield.installed" "$(hostname)" 2>/dev/null || true

    echo ""
    success_msg "Runtime Shield installed successfully!"
    echo -e "  ${DIM}Location: $SHIELD_SKILL_DIR${RESET}"
    echo -e "  ${DIM}Logs: $SHIELD_LOG_DIR${RESET}"
    echo ""
    echo -e "  ${CYAN}The shield will activate automatically on next OpenClaw session.${RESET}"
    echo -e "  ${DIM}Use /shield status inside OpenClaw to check.${RESET}"
}

shield_uninstall() {
    echo ""
    echo -e "  ${CYAN}${BOLD}Runtime Shield Removal${RESET}"
    echo ""

    if ! shield_is_installed; then
        dim_msg "  Runtime Shield is not installed."
        return 0
    fi

    rm -rf "$SHIELD_SKILL_DIR"
    success_msg "Runtime Shield uninstalled."
    echo -e "  ${DIM}Shield logs preserved at: $SHIELD_LOG_DIR${RESET}"
    echo -e "  ${DIM}To remove logs too: rm -rf $SHIELD_LOG_DIR${RESET}"

    report_event "shield.uninstalled" "$(hostname)" 2>/dev/null || true
}

shield_status() {
    echo ""
    echo -e "  ${CYAN}${BOLD}Runtime Shield Status${RESET}"
    echo ""

    if shield_is_installed; then
        echo -e "  ${GREEN}Installed${RESET}: $SHIELD_SKILL_DIR"

        # Check if SKILL.md is valid
        if [ -f "$SHIELD_SKILL_DIR/SKILL.md" ]; then
            local version
            version=$(grep '^version:' "$SHIELD_SKILL_DIR/SKILL.md" 2>/dev/null | head -1 | sed 's/version: *//')
            echo -e "  ${DIM}Version: ${version:-unknown}${RESET}"
        fi

        # Check for built output
        if [ -d "$SHIELD_SKILL_DIR/dist" ]; then
            echo -e "  ${DIM}Built: yes${RESET}"
        else
            echo -e "  ${YELLOW}Built: no (run npm run build in $SHIELD_SKILL_DIR)${RESET}"
        fi

        # Check API key
        local api_key=""
        if [ -f "$SHIELD_CONFIG_DIR/config" ]; then
            # shellcheck disable=SC1090
            source "$SHIELD_CONFIG_DIR/config"
            api_key="${CLAWKEEPER_API_KEY:-}"
        fi

        if [ -n "$api_key" ]; then
            echo -e "  ${DIM}Dashboard: connected (API key configured)${RESET}"
        else
            echo -e "  ${YELLOW}Dashboard: local-only (no API key)${RESET}"
        fi

        # Check log dir
        if [ -d "$SHIELD_LOG_DIR" ]; then
            local log_count
            log_count=$(find "$SHIELD_LOG_DIR" -name "*.jsonl" 2>/dev/null | wc -l | tr -d ' ')
            echo -e "  ${DIM}Log files: $log_count${RESET}"
        fi
    else
        echo -e "  ${YELLOW}Not installed${RESET}"
        echo -e "  ${DIM}Install: clawkeeper.sh shield install${RESET}"
    fi
    echo ""
}

shield_main() {
    local subcommand="${1:-status}"
    shift 2>/dev/null || true

    case "$subcommand" in
        install|--install)
            shield_install
            ;;
        uninstall|--uninstall|remove|--remove)
            shield_uninstall
            ;;
        status|--status)
            shield_status
            ;;
        help|--help|-h)
            echo "Usage: clawkeeper.sh shield <command>"
            echo ""
            echo "Commands:"
            echo "  install     Install the Runtime Shield skill"
            echo "  uninstall   Remove the Runtime Shield skill"
            echo "  status      Check installation status"
            echo "  help        Show this help"
            ;;
        *)
            echo "Unknown shield command: $subcommand"
            echo "Run: clawkeeper.sh shield help"
            return 1
            ;;
    esac
}

# === Extracted Checks ====================================================

# --- Check: admin_user ---

__meta_admin_user() {
    case "$1" in
        name) echo "User Account" ;;
        id)   echo "admin_user" ;;
    esac
}

__check_admin_user() {
# ============================================================================
# Clawkeeper Check: User Account
# Detects whether the current user is an admin, and whether a dedicated
# 'openclaw' standard user exists.
# Info-only — creating a user requires interactive password input which
# cannot be handled via the JSON protocol.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "OpenClaw should run under a standard (non-admin) user to limit blast radius."

current_user=$(whoami)

# Check if current user is admin
if groups "$current_user" 2>/dev/null | grep -qw "admin"; then
    emit_warn "You are running as admin user: $current_user"
    emit_info "A compromised agent under an admin account has much broader access."

    # Check if an 'openclaw' user already exists
    if id "openclaw" &>/dev/null; then
        emit_info "A dedicated 'openclaw' user already exists."
        emit_info "Log into that account for OpenClaw usage."
        emit_fail "Currently running as admin (switch to 'openclaw' user)" "User Account"
    else
        emit_info "To create a dedicated 'openclaw' standard user, run the following manually:"
        emit_info "  sudo dscl . -create /Users/openclaw"
        emit_info "  sudo dscl . -create /Users/openclaw UserShell /bin/zsh"
        emit_info "  sudo dscl . -create /Users/openclaw RealName \"OpenClaw\""
        emit_info "  sudo dscl . -create /Users/openclaw UniqueID <NEXT_UID>"
        emit_info "  sudo dscl . -create /Users/openclaw PrimaryGroupID 20"
        emit_info "  sudo dscl . -create /Users/openclaw NFSHomeDirectory /Users/openclaw"
        emit_info "  sudo dscl . -passwd /Users/openclaw <PASSWORD>"
        emit_info "  sudo createhomedir -c -u openclaw"
        emit_info "Do NOT add the user to the admin group — it should be a standard account."
        emit_info "Then log into that account for all OpenClaw operations."
        emit_fail "Running as admin user (create a dedicated 'openclaw' standard user)" "User Account"
    fi
else
    emit_pass "Running as standard (non-admin) user: $current_user" "User Account"
fi
}

# --- Check: airdrop ---

__meta_airdrop() {
    case "$1" in
        name) echo "AirDrop & Handoff" ;;
        id)   echo "airdrop" ;;
    esac
}

__check_airdrop() {
# ============================================================================
# Clawkeeper Check: AirDrop & Handoff
# Detects whether AirDrop and Handoff are enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Both create network-discoverable services. AirDrop makes this machine visible nearby."

airdrop_issue=false
handoff_issue=false

# AirDrop
airdrop_status=$(defaults read com.apple.NetworkBrowser DisableAirDrop 2>/dev/null || echo "0")
if [ "$airdrop_status" != "1" ]; then
    airdrop_issue=true
fi

# Handoff
handoff_status=$(defaults read ~/Library/Preferences/ByHost/com.apple.coreservices.useractivityd ActivityAdvertisingAllowed 2>/dev/null || echo "1")
if [ "$handoff_status" != "0" ]; then
    handoff_issue=true
fi

if [ "$airdrop_issue" = false ] && [ "$handoff_issue" = false ]; then
    emit_pass "AirDrop and Handoff are disabled" "AirDrop & Handoff"
return 0
fi

[ "$airdrop_issue" = true ] && emit_warn "AirDrop is not disabled"
[ "$handoff_issue" = true ] && emit_warn "Handoff is not disabled"

emit_prompt "Disable AirDrop and Handoff?" "disable_airdrop_handoff" \
    "AirDrop/Handoff not fully disabled" \
    "AirDrop/Handoff left as-is"
}

__remediate_airdrop() {
# ============================================================================
# Clawkeeper Remediation: AirDrop & Handoff
# Disables AirDrop and Handoff on macOS (no sudo required).
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_airdrop_handoff)
        defaults write com.apple.NetworkBrowser DisableAirDrop -bool true 2>/dev/null || true
        defaults write ~/Library/Preferences/ByHost/com.apple.coreservices.useractivityd ActivityAdvertisingAllowed -bool false 2>/dev/null || true
        defaults write ~/Library/Preferences/ByHost/com.apple.coreservices.useractivityd ActivityReceivingAllowed -bool false 2>/dev/null || true
        emit_pass "AirDrop and Handoff disabled" "AirDrop & Handoff"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "AirDrop & Handoff"
        ;;
esac
}

# --- Check: analytics ---

__meta_analytics() {
    case "$1" in
        name) echo "Analytics & Telemetry" ;;
        id)   echo "analytics" ;;
    esac
}

__check_analytics() {
# ============================================================================
# Clawkeeper Check: Analytics & Telemetry
# Detects whether analytics and telemetry settings are enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Diagnostic data from this machine shouldn't go to Apple or third parties."

analytics_issue=false

# Check crash reporter auto-submit
auto_submit=$(defaults read "/Library/Application Support/CrashReporter/DiagnosticMessagesHistory.plist" AutoSubmit 2>/dev/null || echo "unknown")
if [ "$auto_submit" = "1" ] || [ "$auto_submit" = "unknown" ]; then
    analytics_issue=true
fi

# Check Siri analytics
siri_analytics=$(defaults read com.apple.assistant.support "Siri Data Sharing Opt-In Status" 2>/dev/null || echo "unknown")
if [ "$siri_analytics" = "2" ]; then
    analytics_issue=true
fi

if [ "$analytics_issue" = false ]; then
    emit_pass "Analytics and telemetry appear disabled" "Analytics & Telemetry"
return 0
fi

emit_warn "Some analytics/telemetry settings may be enabled"
emit_prompt "Disable all analytics and telemetry?" "disable_analytics" \
    "Analytics/telemetry may be enabled" \
    "Analytics left as-is"
}

__remediate_analytics() {
# ============================================================================
# Clawkeeper Remediation: Analytics & Telemetry
# Disables analytics and telemetry on macOS (partially requires sudo).
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_analytics)
        # Disable crash reporter auto-submit (requires sudo)
        sudo defaults write "/Library/Application Support/CrashReporter/DiagnosticMessagesHistory.plist" AutoSubmit -bool false 2>/dev/null || true
        # Disable Siri data sharing
        defaults write com.apple.assistant.support "Siri Data Sharing Opt-In Status" -int 0 2>/dev/null || true
        # Disable app analytics
        defaults write com.apple.appanalyticsd policy -int 0 2>/dev/null || true
        emit_pass "Analytics and telemetry disabled" "Analytics & Telemetry"
        emit_info "Verify in System Settings → Privacy & Security → Analytics & Improvements"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Analytics & Telemetry"
        ;;
esac
}

# --- Check: automatic_login ---

__meta_automatic_login() {
    case "$1" in
        name) echo "Automatic Login" ;;
        id)   echo "automatic_login" ;;
    esac
}

__check_automatic_login() {
# ============================================================================
# Clawkeeper Check: Automatic Login
# Detects whether automatic login is enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Automatic login bypasses the login screen — anyone with physical access gets in."

auto_login=$(defaults read /Library/Preferences/com.apple.loginwindow autoLoginUser 2>/dev/null || echo "")

if [ -z "$auto_login" ]; then
    emit_pass "Automatic login is disabled" "Automatic Login"
return 0
fi

emit_warn "Automatic login is enabled for user: $auto_login"
emit_prompt "Disable automatic login?" "disable_automatic_login" \
    "Automatic login is enabled" \
    "Automatic login left enabled"
}

__remediate_automatic_login() {
# ============================================================================
# Clawkeeper Remediation: Automatic Login
# Disables automatic login by removing the autoLoginUser preference.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_automatic_login)
        sudo defaults delete /Library/Preferences/com.apple.loginwindow autoLoginUser 2>/dev/null || true
        emit_pass "Automatic login disabled" "Automatic Login"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Automatic Login"
        ;;
esac
}

# --- Check: bluetooth ---

__meta_bluetooth() {
    case "$1" in
        name) echo "Bluetooth" ;;
        id)   echo "bluetooth" ;;
    esac
}

__check_bluetooth() {
# ============================================================================
# Clawkeeper Check: Bluetooth
# Detects whether Bluetooth is enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Unnecessary radio interface. Exposes the machine to proximity-based attacks."

bt_on=false

# Check via defaults
bt_status=$(defaults read /Library/Preferences/com.apple.Bluetooth ControllerPowerState 2>/dev/null || echo "unknown")

if [ "$bt_status" = "1" ]; then
    bt_on=true
elif [ "$bt_status" = "0" ]; then
    bt_on=false
else
    # Try system_profiler as fallback
    if system_profiler SPBluetoothDataType 2>/dev/null | grep -q "State: On"; then
        bt_on=true
    fi
fi

if [ "$bt_on" = false ]; then
    emit_pass "Bluetooth is off" "Bluetooth"
return 0
fi

emit_warn "Bluetooth is ON"
emit_info "If you're using a wireless keyboard/mouse, you may need Bluetooth."
emit_prompt "Disable Bluetooth? (skip if you need wireless peripherals)" "disable_bluetooth" \
    "Bluetooth is on" \
    "Bluetooth left on (wireless peripherals)"
}

__remediate_bluetooth() {
# ============================================================================
# Clawkeeper Remediation: Bluetooth
# Disables Bluetooth on macOS (requires sudo).
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_bluetooth)
        sudo defaults write /Library/Preferences/com.apple.Bluetooth ControllerPowerState -int 0 2>/dev/null || true
        emit_pass "Bluetooth disabled" "Bluetooth"
        emit_info "Note: If using wireless peripherals, re-enable in System Settings → Bluetooth"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Bluetooth"
        ;;
esac
}

# --- Check: container_security ---

__meta_container_security() {
    case "$1" in
        name) echo "Container Security Audit" ;;
        id)   echo "container_security" ;;
    esac
}

__check_container_security() {
# ============================================================================
# Clawkeeper Check: Container Security Audit
# Audits a running OpenClaw Docker container for: user (non-root),
# capabilities (cap_drop ALL), privileged mode, no-new-privileges,
# read-only root filesystem, port binding, resource limits (memory/CPU),
# network mode, Bonjour env var, and volume mounts.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

# ---------- Check if OpenClaw container is running ----------
if ! command -v docker &>/dev/null; then
    emit_info "Docker not installed — skipping container audit"
return 0
fi

if ! docker ps --format '{{.Names}}' 2>/dev/null | grep -q "^openclaw$"; then
    emit_info "OpenClaw container is not running — skipping container audit"
return 0
fi

emit_info "Auditing running container:"

# ---------- Check 1: Running as non-root ----------
container_user=$(docker exec openclaw id -u 2>/dev/null || echo "unknown")
if [ "$container_user" = "0" ]; then
    emit_fail "Container is running as ROOT (uid 0)" "Container User"
elif [ "$container_user" = "unknown" ]; then
    emit_warn "Could not determine container user"
else
    emit_pass "Container running as non-root (uid: $container_user)" "Container User"
fi

# ---------- Check 2: Capabilities ----------
cap_info=$(docker inspect --format='{{.HostConfig.CapDrop}}' openclaw 2>/dev/null || echo "")
if echo "$cap_info" | grep -qi "all"; then
    emit_pass "All capabilities dropped (cap_drop: ALL)" "Capabilities"
else
    emit_fail "Capabilities not fully dropped — add cap_drop: ALL" "Capabilities"
fi

cap_add=$(docker inspect --format='{{.HostConfig.CapAdd}}' openclaw 2>/dev/null || echo "")
if echo "$cap_add" | grep -qi "NET_BIND_SERVICE" && [ "$(echo "$cap_add" | tr -cd ',' | wc -c)" -le 0 ]; then
    emit_pass "Only NET_BIND_SERVICE capability added back" "Cap Add"
elif [ -z "$cap_add" ] || echo "$cap_add" | grep -q "\[\]"; then
    emit_pass "No extra capabilities added" "Cap Add"
else
    emit_warn "Additional capabilities added: $cap_add"
    emit_fail "Minimize added capabilities — only NET_BIND_SERVICE should be needed" "Cap Add"
fi

# ---------- Check 3: Privileged mode ----------
privileged=$(docker inspect --format='{{.HostConfig.Privileged}}' openclaw 2>/dev/null || echo "unknown")
if [ "$privileged" = "false" ]; then
    emit_pass "Container is NOT privileged" "Privileged Mode"
elif [ "$privileged" = "true" ]; then
    emit_fail "CRITICAL: Container is running in PRIVILEGED mode" "Privileged Mode"
    emit_info "Remove --privileged immediately — this gives full host access"
fi

# ---------- Check 4: no-new-privileges ----------
no_new_priv=$(docker inspect --format='{{index .HostConfig.SecurityOpt}}' openclaw 2>/dev/null || echo "")
if echo "$no_new_priv" | grep -qi "no-new-privileges"; then
    emit_pass "no-new-privileges is set" "No New Privileges"
else
    emit_fail "no-new-privileges not set — add security_opt: no-new-privileges:true" "No New Privileges"
fi

# ---------- Check 5: Read-only root filesystem ----------
readonly_fs=$(docker inspect --format='{{.HostConfig.ReadonlyRootfs}}' openclaw 2>/dev/null || echo "unknown")
if [ "$readonly_fs" = "true" ]; then
    emit_pass "Root filesystem is read-only" "Read-Only FS"
else
    emit_fail "Root filesystem is writable — add read_only: true to compose" "Read-Only FS"
fi

# ---------- Check 6: Port binding ----------
port_bindings=$(docker inspect --format='{{range $p, $conf := .NetworkSettings.Ports}}{{$p}}={{(index $conf 0).HostIp}}:{{(index $conf 0).HostPort}} {{end}}' openclaw 2>/dev/null || echo "")

port_ok=true
if echo "$port_bindings" | grep -q "0.0.0.0"; then
    emit_fail "CRITICAL: Ports bound to 0.0.0.0 (all interfaces)" "Port Binding"
    emit_info "Change to 127.0.0.1:<port>:<port> in docker-compose.yml"
    port_ok=false
fi
if [ "$port_ok" = true ] && [ -n "$port_bindings" ]; then
    emit_pass "All ports bound to localhost only" "Port Binding"
fi

# ---------- Check 7: Resource limits ----------
mem_limit=$(docker inspect --format='{{.HostConfig.Memory}}' openclaw 2>/dev/null || echo "0")
if [ "$mem_limit" -gt 0 ] 2>/dev/null; then
    mem_mb=$((mem_limit / 1024 / 1024))
    emit_pass "Memory limit set (${mem_mb}MB)" "Memory Limit"
else
    emit_fail "No memory limit set — container can consume all host memory" "Memory Limit"
fi

cpu_limit=$(docker inspect --format='{{.HostConfig.NanoCpus}}' openclaw 2>/dev/null || echo "0")
if [ "$cpu_limit" -gt 0 ] 2>/dev/null; then
    cpu_cores=$((cpu_limit / 1000000000))
    emit_pass "CPU limit set (~${cpu_cores} cores)" "CPU Limit"
else
    emit_fail "No CPU limit set — runaway agent can consume all CPUs" "CPU Limit"
fi

# ---------- Check 8: Network mode ----------
net_mode=$(docker inspect --format='{{.HostConfig.NetworkMode}}' openclaw 2>/dev/null || echo "unknown")
if [ "$net_mode" = "host" ]; then
    emit_fail "CRITICAL: Container using host network mode — no network isolation" "Network Mode"
else
    emit_pass "Container using isolated network ($net_mode)" "Network Mode"
fi

# ---------- Check 9: Bonjour environment variable ----------
bonjour_disabled=$(docker exec openclaw printenv OPENCLAW_DISABLE_BONJOUR 2>/dev/null || echo "")
if [ "$bonjour_disabled" = "1" ]; then
    emit_pass "OPENCLAW_DISABLE_BONJOUR=1 is set" "Container Bonjour"
else
    emit_fail "OPENCLAW_DISABLE_BONJOUR not set in container environment" "Container Bonjour"
fi

# ---------- Check 10: Volume mounts — warn on sensitive paths ----------
mounts=$(docker inspect --format='{{range .Mounts}}{{.Source}}:{{.Destination}}:{{.Mode}} {{end}}' openclaw 2>/dev/null || echo "")

mount_issue=false
for sensitive_path in "/etc" "/var" "/root" "/Users" "/home"; do
    if echo "$mounts" | grep -q "^${sensitive_path}:"; then
        emit_warn "Sensitive host path mounted: $sensitive_path"
        mount_issue=true
    fi
done

if [ "$mount_issue" = false ]; then
    emit_pass "No sensitive host paths mounted" "Volume Mounts"
else
    emit_fail "Sensitive host paths are mounted into the container" "Volume Mounts"
fi

# ---------- Check 11: Image source (hardened vs official) ----------
image_name=$(docker inspect --format='{{.Config.Image}}' openclaw 2>/dev/null || echo "unknown")
if echo "$image_name" | grep -qi "minimus"; then
    emit_pass "Using Minimus hardened image (99% fewer CVEs)" "Container Image"
elif echo "$image_name" | grep -qi "ghcr.io/openclaw"; then
    emit_warn "Using official OpenClaw image — consider switching to the Minimus hardened image for 99% fewer CVEs"
    emit_info "Image: us-docker.pkg.dev/prod-375107/minimus-public/openclaw:latest"
    emit_info "Details: https://www.minimus.io"
else
    emit_info "Using custom image: $image_name"
fi
}

# --- Check: credential_exposure ---

__meta_credential_exposure() {
    case "$1" in
        name) echo "Credential Exposure Scan" ;;
        id)   echo "credential_exposure" ;;
    esac
}

__check_credential_exposure() {
# ============================================================================
# Clawkeeper Check: Credential Exposure Scan
# Scans openclaw.json, shell history, MEMORY.md, and session logs for
# common credential patterns. Never echoes actual credentials — truncates
# to first 4 characters.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

# Patterns that match common credential formats
# NEVER echo actual credentials — truncate to first 4 chars
cred_patterns='(sk-ant-api[A-Za-z0-9]{10,}|sk-[A-Za-z0-9]{20,}|ghp_[A-Za-z0-9]{36}|xoxb-[0-9]{10,}|AKIA[0-9A-Z]{16}|AIza[A-Za-z0-9_-]{35})'

config_file="$HOME/.openclaw/openclaw.json"

# ---- 1. Config file: detect resolved ${VAR} env vars (config.patch bug) ----
if [ -f "$config_file" ]; then
    config_matches=$(grep -oE "$cred_patterns" "$config_file" 2>/dev/null || true)
    if [ -n "$config_matches" ]; then
        truncated=$(echo "$config_matches" | head -1 | cut -c1-4)
        emit_fail "CRITICAL: Credential found in openclaw.json (${truncated}****)" "Credential Exposure Config"
        emit_info "Likely caused by env-var resolution bug — remove and use .env instead"
    else
        emit_pass "No credentials detected in openclaw.json" "Credential Exposure Config"
    fi
else
    emit_info "No openclaw.json found — skipping config credential scan"
fi

# ---- 2. Shell history ----
history_files=(
    "$HOME/.bash_history"
    "$HOME/.zsh_history"
)
history_hit=false
for hfile in "${history_files[@]}"; do
    if [ -f "$hfile" ]; then
        hist_match=$(grep -oE "$cred_patterns" "$hfile" 2>/dev/null | head -1 || true)
        if [ -n "$hist_match" ]; then
            history_hit=true
            truncated=$(echo "$hist_match" | cut -c1-4)
            emit_fail "Credential found in shell history: $(basename "$hfile") (${truncated}****)" "Credential Exposure History"
            emit_info "Run: history -c or remove matching lines from $hfile"
        fi
    fi
done
if [ "$history_hit" = false ]; then
    emit_pass "No credentials found in shell history" "Credential Exposure History"
fi

# ---- 3. MEMORY.md ----
memory_file="$HOME/.openclaw/MEMORY.md"
if [ -f "$memory_file" ]; then
    # Check permissions
    mem_perms=$(stat -f "%OLp" "$memory_file" 2>/dev/null || stat -c "%a" "$memory_file" 2>/dev/null || echo "unknown")
    if [ "$mem_perms" != "600" ] && [ "$mem_perms" != "700" ]; then
        emit_fail "MEMORY.md permissions are $mem_perms (should be 600)" "Credential Exposure Memory"
    fi
    # Content scan
    mem_match=$(grep -oE "$cred_patterns" "$memory_file" 2>/dev/null | head -1 || true)
    if [ -n "$mem_match" ]; then
        truncated=$(echo "$mem_match" | cut -c1-4)
        emit_fail "Credential found in MEMORY.md (${truncated}****)" "Credential Exposure Memory"
        emit_info "OpenClaw may have memorized a secret — edit ~/.openclaw/MEMORY.md"
    else
        emit_pass "No credentials detected in MEMORY.md" "Credential Exposure Memory"
    fi
else
    emit_info "No MEMORY.md found — skipping memory credential scan"
fi

# ---- 4. Session logs (sample scan — check permissions + first few files) ----
sessions_dir="$HOME/.openclaw/agents"
if [ -d "$sessions_dir" ]; then
    session_files=$(find "$sessions_dir" -name "*.jsonl" -type f 2>/dev/null | head -5)
    if [ -n "$session_files" ]; then
        # Check directory permissions
        sess_perms=$(stat -f "%OLp" "$sessions_dir" 2>/dev/null || stat -c "%a" "$sessions_dir" 2>/dev/null || echo "unknown")
        if [ "$sess_perms" != "700" ]; then
            emit_fail "Session logs directory permissions are $sess_perms (should be 700)" "Credential Exposure Sessions"
        fi
        # Sample content scan
        sess_hit=false
        while IFS= read -r sfile; do
            [ -z "$sfile" ] && continue
            s_match=$(grep -oE "$cred_patterns" "$sfile" 2>/dev/null | head -1 || true)
            if [ -n "$s_match" ]; then
                sess_hit=true
                truncated=$(echo "$s_match" | cut -c1-4)
                emit_fail "Credential found in session log (${truncated}****)" "Credential Exposure Sessions"
                emit_info "File: $sfile"
                break
            fi
        done <<< "$session_files"
        if [ "$sess_hit" = false ]; then
            emit_pass "No credentials detected in sampled session logs" "Credential Exposure Sessions"
        fi
    else
        emit_info "No session log files found"
    fi
else
    emit_info "No agents directory found — skipping session log scan"
fi
}

# --- Check: credential_store ---

__meta_credential_store() {
    case "$1" in
        name) echo "Credential Store Security" ;;
        id)   echo "credential_store" ;;
    esac
}

__check_credential_store() {
# ============================================================================
# Clawkeeper Check: Credential Store Security
# Checks permissions on ~/.openclaw/credentials/, OAuth profiles,
# session transcript directories, and log files.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
REMEDIATION_ID=""
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        --remediation-id) REMEDIATION_ID="$2"; shift 2 ;;
        *) shift ;;
    esac
done

openclaw_dir="$HOME/.openclaw"

if [ ! -d "$openclaw_dir" ]; then
    emit_info "No ~/.openclaw directory found — skipping credential store checks"
return 0
fi

# --- Remediation handler ---
if [ -n "$REMEDIATION_ID" ]; then
    case "$REMEDIATION_ID" in
        fix_credentials_perms)
            creds_dir="$openclaw_dir/credentials"
            if [ -d "$creds_dir" ]; then
                chmod 700 "$creds_dir"
                find "$creds_dir" -type f -exec chmod 600 {} \;
                emit_pass "Credentials directory and files set to 700/600" "Credential Directory"
            else
                emit_fail "Credentials directory not found" "Credential Directory"
            fi
            ;;
        fix_oauth_perms)
            find "$openclaw_dir/agents" -name "auth-profiles.json" -exec chmod 600 {} \; 2>/dev/null
            emit_pass "OAuth profile files set to 600" "OAuth Profiles"
            ;;
        fix_sessions_perms)
            find "$openclaw_dir/agents" -name "sessions" -type d -exec chmod 700 {} \; 2>/dev/null
            find "$openclaw_dir/agents" -path "*/sessions/*.jsonl" -exec chmod 600 {} \; 2>/dev/null
            emit_pass "Session directories and logs set to 700/600" "Session Transcripts"
            ;;
        fix_log_perms)
            log_dir="/tmp/openclaw"
            if [ -d "$log_dir" ]; then
                chmod 700 "$log_dir"
                find "$log_dir" -name "*.log" -exec chmod 600 {} \; 2>/dev/null
                emit_pass "Log directory and files set to 700/600" "Log Files"
            else
                emit_fail "Log directory not found: $log_dir" "Log Files"
            fi
            ;;
        *)
            emit_fail "Unknown remediation: $REMEDIATION_ID" "Credential Store"
            ;;
    esac
return 0
fi

emit_info "Credential store security checks:"

# ---------- Credentials directory ----------
creds_dir="$openclaw_dir/credentials"
if [ -d "$creds_dir" ]; then
    creds_perms=$(stat -f "%Lp" "$creds_dir" 2>/dev/null || stat -c "%a" "$creds_dir" 2>/dev/null)
    if [ "$creds_perms" = "700" ]; then
        emit_pass "Credentials directory permissions are 700" "Credential Directory"
    else
        emit_prompt "Credentials directory permissions are $creds_perms — fix to 700?" \
            "fix_credentials_perms" \
            "Credentials directory permissions are $creds_perms (should be 700)" \
            "Credentials directory left at $creds_perms"
    fi

    # Check individual credential files
    cred_file_issues=0
    while IFS= read -r cred_file; do
        [ -z "$cred_file" ] && continue
        fperms=$(stat -f "%Lp" "$cred_file" 2>/dev/null || stat -c "%a" "$cred_file" 2>/dev/null)
        if [ "$fperms" != "600" ] && [ "$fperms" != "400" ]; then
            cred_file_issues=$((cred_file_issues + 1))
        fi
    done < <(find "$creds_dir" -type f 2>/dev/null)

    if [ "$cred_file_issues" -gt 0 ]; then
        emit_fail "$cred_file_issues credential file(s) have incorrect permissions (should be 600)" "Credential Files"
    else
        emit_pass "All credential files have correct permissions" "Credential Files"
    fi
else
    emit_pass "No credentials directory found (no channel credentials stored)" "Credential Directory"
fi

# ---------- OAuth profiles ----------
oauth_issues=0
oauth_count=0
while IFS= read -r profile_file; do
    [ -z "$profile_file" ] && continue
    oauth_count=$((oauth_count + 1))
    fperms=$(stat -f "%Lp" "$profile_file" 2>/dev/null || stat -c "%a" "$profile_file" 2>/dev/null)
    if [ "$fperms" != "600" ] && [ "$fperms" != "400" ]; then
        oauth_issues=$((oauth_issues + 1))
    fi
done < <(find "$openclaw_dir/agents" -name "auth-profiles.json" 2>/dev/null)

if [ "$oauth_count" -eq 0 ]; then
    emit_pass "No OAuth profiles found" "OAuth Profiles"
elif [ "$oauth_issues" -gt 0 ]; then
    emit_prompt "$oauth_issues OAuth profile(s) have incorrect permissions — fix to 600?" \
        "fix_oauth_perms" \
        "$oauth_issues OAuth profile(s) have incorrect permissions" \
        "OAuth profiles left with current permissions"
else
    emit_pass "All $oauth_count OAuth profile(s) have correct permissions (600)" "OAuth Profiles"
fi

# ---------- Session transcripts ----------
session_dir_issues=0
session_file_issues=0
session_count=0

while IFS= read -r sess_dir; do
    [ -z "$sess_dir" ] && continue
    session_count=$((session_count + 1))
    dperms=$(stat -f "%Lp" "$sess_dir" 2>/dev/null || stat -c "%a" "$sess_dir" 2>/dev/null)
    if [ "$dperms" != "700" ]; then
        session_dir_issues=$((session_dir_issues + 1))
    fi
    # Sample check session files
    while IFS= read -r sess_file; do
        [ -z "$sess_file" ] && continue
        fperms=$(stat -f "%Lp" "$sess_file" 2>/dev/null || stat -c "%a" "$sess_file" 2>/dev/null)
        if [ "$fperms" != "600" ] && [ "$fperms" != "400" ]; then
            session_file_issues=$((session_file_issues + 1))
        fi
    done < <(find "$sess_dir" -name "*.jsonl" -maxdepth 1 2>/dev/null | head -5)
done < <(find "$openclaw_dir/agents" -name "sessions" -type d 2>/dev/null)

if [ "$session_count" -eq 0 ]; then
    emit_pass "No session transcript directories found" "Session Transcripts"
elif [ "$session_dir_issues" -gt 0 ] || [ "$session_file_issues" -gt 0 ]; then
    total_issues=$((session_dir_issues + session_file_issues))
    emit_prompt "$total_issues session store permission issue(s) — fix to 700/600?" \
        "fix_sessions_perms" \
        "Session transcript permissions are too permissive" \
        "Session transcript permissions left as-is"
else
    emit_pass "Session transcript stores have correct permissions" "Session Transcripts"
fi

# ---------- Log files ----------
log_dir="/tmp/openclaw"
if [ -d "$log_dir" ]; then
    log_perms=$(stat -f "%Lp" "$log_dir" 2>/dev/null || stat -c "%a" "$log_dir" 2>/dev/null)
    if [ "$log_perms" = "700" ]; then
        emit_pass "Log directory permissions are 700" "Log Files"
    else
        emit_prompt "Log directory permissions are $log_perms — fix to 700?" \
            "fix_log_perms" \
            "Log directory permissions are $log_perms (should be 700)" \
            "Log directory left at $log_perms"
    fi
else
    emit_pass "No OpenClaw log directory found at /tmp/openclaw" "Log Files"
fi
}

# --- Check: cve_audit ---

__meta_cve_audit() {
    case "$1" in
        name) echo "OpenClaw CVE Audit" ;;
        id)   echo "cve_audit" ;;
    esac
}

__check_cve_audit() {
# ============================================================================
# Clawkeeper Check: OpenClaw CVE Audit (Live Feed)
# Fetches the OpenClaw CVE feed from jgamblin/OpenClawCVEs and checks the
# installed version against all known vulnerabilities.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

# --- CVE feed URLs ---
CVE_FEED_URL="https://raw.githubusercontent.com/jgamblin/OpenClawCVEs/main/cves.json"
GHSA_FEED_URL="https://raw.githubusercontent.com/jgamblin/OpenClawCVEs/main/ghsa-advisories.json"

# --- Detect OpenClaw version ---
oc_version=""
if command -v openclaw &>/dev/null; then
    oc_version=$(openclaw --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
elif command -v npx &>/dev/null; then
    oc_version=$(npx openclaw --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
fi

if [ -z "$oc_version" ]; then
    emit_skipped "OpenClaw not detected — CVE audit skipped" "CVE Audit"
return 0
fi

emit_info "Detected OpenClaw version: $oc_version"

# --- Fetch CVE feed into temp files ---
cve_tmp=$(mktemp)
ghsa_tmp=$(mktemp)
result_tmp=$(mktemp)
trap 'rm -f "$cve_tmp" "$ghsa_tmp" "$result_tmp"' EXIT

if command -v curl &>/dev/null; then
    curl -sf --connect-timeout 10 --max-time 30 "$CVE_FEED_URL" > "$cve_tmp" 2>/dev/null
    curl -sf --connect-timeout 10 --max-time 30 "$GHSA_FEED_URL" > "$ghsa_tmp" 2>/dev/null
elif command -v wget &>/dev/null; then
    wget -qO- --timeout=30 "$CVE_FEED_URL" > "$cve_tmp" 2>/dev/null
    wget -qO- --timeout=30 "$GHSA_FEED_URL" > "$ghsa_tmp" 2>/dev/null
fi

if [ ! -s "$cve_tmp" ]; then
    emit_skipped "Could not fetch CVE feed (no network or API unavailable)" "CVE Audit"
return 0
fi

# --- Use python3 to parse feed and check version ---
# python3 is pre-installed on macOS (since Catalina) and virtually all Linux distros
if ! command -v python3 &>/dev/null; then
    emit_skipped "python3 not available — CVE feed parsing skipped" "CVE Audit"
return 0
fi

# Python script reads JSON from temp files (avoids argument length limits)
# Outputs one line per result:
#   VULN|CVE-ID|SEVERITY|CVSS|DESCRIPTION|PACKAGES|FIX_VERSION
#   CLEAN  (if no vulnerabilities found)
#   ERROR|message  (if parsing failed)
python3 - "$cve_tmp" "$ghsa_tmp" "$oc_version" > "$result_tmp" 2>/dev/null <<'PYEOF'
import json, sys, re, os

def parse_version(v):
    try:
        parts = v.strip().split(".")
        return tuple(int(p) for p in parts[:3])
    except (ValueError, IndexError):
        return (0, 0, 0)

def check_constraint(installed, constraint):
    constraint = constraint.strip()
    m = re.match(r"^(<=?|>=?)\s*(\d+\.\d+\.\d+)", constraint)
    if not m:
        return False
    op, ver_str = m.group(1), m.group(2)
    target = parse_version(ver_str)
    if op == "<":
        return installed < target
    elif op == "<=":
        return installed <= target
    elif op == ">":
        return installed > target
    elif op == ">=":
        return installed >= target
    return False

def is_affected(installed, affected_versions):
    for constraint_group in affected_versions:
        parts = [c.strip() for c in constraint_group.split(",")]
        all_match = True
        for part in parts:
            if not check_constraint(installed, part):
                all_match = False
                break
        if all_match:
            return True
    return False

def extract_fix_version(affected_versions):
    for constraint_group in affected_versions:
        parts = [c.strip() for c in constraint_group.split(",")]
        for part in parts:
            m = re.match(r"^<[=]?\s*(\d+\.\d+\.\d+)", part)
            if m:
                return m.group(1)
    return "latest"

try:
    cve_file = sys.argv[1]
    ghsa_file = sys.argv[2]
    version_str = sys.argv[3]

    with open(cve_file, "r") as f:
        cve_data = json.load(f)
    try:
        with open(ghsa_file, "r") as f:
            ghsa_data = json.load(f)
    except (json.JSONDecodeError, FileNotFoundError):
        ghsa_data = []
except Exception as e:
    print(f"ERROR|Failed to parse CVE feed: {e}")
    sys.exit(0)

installed = parse_version(version_str)

ghsa_map = {}
for g in ghsa_data:
    cve_id = g.get("cve_id", "")
    if cve_id:
        ghsa_map[cve_id] = g

vuln_count = 0
for cve in cve_data:
    cve_id = cve.get("cve_id", "")
    if not cve_id:
        continue
    advisory = ghsa_map.get(cve_id, {})
    affected = advisory.get("affected_versions", [])
    if not affected:
        continue
    if is_affected(installed, affected):
        severity = cve.get("severity", "MEDIUM").upper()
        cvss = cve.get("cvss", 0)
        title = cve.get("title", cve_id)
        packages = advisory.get("packages", [])
        pkg_str = ", ".join(packages) if packages else "openclaw"
        fix_ver = extract_fix_version(affected)
        title = title.replace("|", "-")
        print(f"VULN|{cve_id}|{severity}|{cvss}|{title}|{pkg_str}|{fix_ver}")
        vuln_count += 1

if vuln_count == 0:
    print("CLEAN")
PYEOF

audit_results=$(cat "$result_tmp")

if [ -z "$audit_results" ]; then
    emit_skipped "CVE feed parsing failed" "CVE Audit"
return 0
fi

# --- Process results ---
vuln_count=0
while IFS= read -r line; do
    case "$line" in
        CLEAN)
            emit_pass "OpenClaw $oc_version — no known CVEs in the security feed" "CVE Audit"
            ;;
        ERROR\|*)
            err_msg="${line#ERROR|}"
            emit_skipped "$err_msg" "CVE Audit"
            ;;
        VULN\|*)
            IFS='|' read -r _ cve_id severity cvss title packages fix_ver <<< "$line"
            vuln_count=$((vuln_count + 1))
            emit_fail "$severity ($cvss): $title — affects $packages [upgrade to >= $fix_ver]" "CVE: $cve_id"
            ;;
    esac
done <<< "$audit_results"

if [ "$vuln_count" -gt 0 ]; then
    emit_warn "Found $vuln_count CVE(s) affecting OpenClaw $oc_version"
    emit_info "Run: npm install -g openclaw@latest  (or update your Docker image)"
    emit_info "Docker users: consider the Minimus hardened image (99% fewer CVEs): us-docker.pkg.dev/prod-375107/minimus-public/openclaw:latest"
fi
}

# --- Check: docker_installed ---

__meta_docker_installed() {
    case "$1" in
        name) echo "Docker Desktop" ;;
        id)   echo "docker_installed" ;;
    esac
}

__check_docker_installed() {
# ============================================================================
# Clawkeeper Check: Docker Desktop
# Detects whether Docker is installed, running, and has reasonable settings.
# Includes harden_docker_desktop sub-checks when Docker is running.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Container isolation is the most impactful security improvement for OpenClaw."

# --- Docker Desktop hardening sub-check -------------------------------------
# Called when Docker is installed and running.
harden_docker_desktop() {
    local docker_settings="$HOME/Library/Group Containers/group.com.docker/settings.json"

    if [ ! -f "$docker_settings" ]; then
        emit_info "Docker Desktop settings file not found — using defaults"
        return
    fi

    local issues=()

    # Check telemetry
    if grep -q '"analyticsEnabled".*true' "$docker_settings" 2>/dev/null; then
        issues+=("telemetry")
    fi

    # Check resource limits (warn if very high or unlimited)
    local mem_limit
    mem_limit=$(grep -o '"memoryMiB"[[:space:]]*:[[:space:]]*[0-9]*' "$docker_settings" 2>/dev/null | grep -o '[0-9]*' || echo "0")
    if [ "$mem_limit" -gt 8192 ] 2>/dev/null; then
        issues+=("memory")
    fi

    local cpu_limit
    cpu_limit=$(grep -o '"cpus"[[:space:]]*:[[:space:]]*[0-9]*' "$docker_settings" 2>/dev/null | grep -o '[0-9]*' || echo "0")
    if [ "$cpu_limit" -gt 4 ] 2>/dev/null; then
        issues+=("cpu")
    fi

    if [ ${#issues[@]} -eq 0 ]; then
        emit_pass "Docker Desktop settings look reasonable" "Docker Settings"
        return
    fi

    # Report individual issues
    for issue in "${issues[@]}"; do
        case "$issue" in
            telemetry)
                emit_warn "Docker Desktop analytics/telemetry is enabled"
                emit_info "Disable: Docker Desktop -> Settings -> General -> uncheck 'Send usage statistics'"
                ;;
            memory)
                emit_warn "Docker memory limit is high (${mem_limit}MB)"
                emit_info "Recommend 4096MB max: Docker Desktop -> Settings -> Resources -> Memory"
                ;;
            cpu)
                emit_warn "Docker CPU limit is high (${cpu_limit} CPUs)"
                emit_info "Recommend 2 CPUs max: Docker Desktop -> Settings -> Resources -> CPUs"
                ;;
        esac
    done

    emit_fail "Docker Desktop settings need hardening (adjust manually in Docker Desktop -> Settings)" "Docker Settings"
}

# --- Main Docker check -------------------------------------------------------

if command -v docker &>/dev/null; then
    if docker info &>/dev/null; then
        emit_pass "Docker is installed and running" "Docker"
        harden_docker_desktop
return 0
    else
        # Docker installed but not running
        emit_warn "Docker is installed but not running"
        emit_info "Open Docker Desktop from Applications to start it."
        emit_prompt "Attempt to start Docker Desktop?" "start_docker" \
            "Docker not running" \
            "Docker left stopped"
return 0
    fi
fi

# Docker not installed
emit_warn "Docker is not installed"

if ! command -v brew &>/dev/null; then
    emit_fail "Docker not installed (install Homebrew first)" "Docker"
return 0
fi

emit_prompt "Install Docker Desktop via Homebrew?" "install_docker" \
    "Docker not installed" \
    "Docker not installed"
}

__remediate_docker_installed() {
# ============================================================================
# Clawkeeper Remediation: Docker Desktop
# Handles starting Docker Desktop or installing it via Homebrew.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    start_docker)
        open -a "Docker" 2>/dev/null || true
        emit_info "Waiting for Docker to start (up to 60 seconds)..."

        waited=0
        while [ $waited -lt 60 ]; do
            if docker info &>/dev/null 2>&1; then
                emit_pass "Docker Desktop started" "Docker"
return 0
            fi
            sleep 5
            waited=$((waited + 5))
        done

        emit_fail "Docker did not start within 60 seconds — open it manually" "Docker"
return 1
        ;;
    install_docker)
        emit_info "Installing Docker Desktop (this may take a few minutes)..."

        brew install --cask docker 2>&1 | tail -5 || {
            emit_fail "Docker installation failed" "Docker"
return 1
        }

        emit_info "Opening Docker Desktop for first-time setup..."
        open -a "Docker" 2>/dev/null || true

        emit_info "Waiting for Docker to start (up to 90 seconds)..."
        waited=0
        while [ $waited -lt 90 ]; do
            if docker info &>/dev/null 2>&1; then
                emit_pass "Docker Desktop installed and running" "Docker"
return 0
            fi
            sleep 5
            waited=$((waited + 5))
        done

        emit_warn "Docker installed but may still be starting up"
        emit_info "Complete the Docker Desktop setup wizard, then re-run this script."
        emit_fail "Docker installed but not yet responsive" "Docker"
return 1
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Docker"
        ;;
esac
}

# --- Check: env_file ---

__meta_env_file() {
    case "$1" in
        name) echo ".env File Security" ;;
        id)   echo "env_file" ;;
    esac
}

__check_env_file() {
# ============================================================================
# Clawkeeper Check: .env File Security
# Checks .env file permissions in common OpenClaw installation locations.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

env_candidates=(
    "$HOME/openclaw-docker/.env"
    "$HOME/.openclaw/.env"
    "$HOME/openclaw/.env"
)

found_env=false

for env_file in "${env_candidates[@]}"; do
    if [ -f "$env_file" ]; then
        found_env=true
        perms=$(stat -f "%OLp" "$env_file" 2>/dev/null || stat -c "%a" "$env_file" 2>/dev/null || echo "unknown")

        if [ "$perms" = "600" ]; then
            emit_pass ".env file ($env_file) permissions are 600" ".env Permissions"
        else
            emit_prompt ".env file ($env_file) permissions are $perms — fix to 600?" \
                "fix_env_perms:${env_file}" \
                ".env permissions are $perms (should be 600)" \
                ".env permissions not changed"
        fi
    fi
done

if [ "$found_env" = false ]; then
    emit_info "No .env file found in common locations"
    emit_info "Expected at ~/openclaw-docker/.env if using Docker setup"
fi
}

__remediate_env_file() {
# ============================================================================
# Clawkeeper Remediation: .env File Security
# Fixes .env file permissions to 600.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

# The remediation_id is in the form "fix_env_perms:/path/to/.env"
case "$REMEDIATION_ID" in
    fix_env_perms:*)
        env_file="${REMEDIATION_ID#fix_env_perms:}"
        if [ -f "$env_file" ]; then
            chmod 600 "$env_file"
            emit_pass ".env file set to 600 ($env_file)" ".env Permissions"
        else
            emit_fail ".env file not found: $env_file" ".env Permissions"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" ".env Permissions"
        ;;
esac
}

# --- Check: filevault ---

__meta_filevault() {
    case "$1" in
        name) echo "FileVault (Full-Disk Encryption)" ;;
        id)   echo "filevault" ;;
    esac
}

__check_filevault() {
# ============================================================================
# Clawkeeper Check: FileVault (Full-Disk Encryption)
# Detects whether FileVault is enabled on macOS.
# Info-only — no automated remediation (must be done in System Settings).
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Protects data at rest if the machine is physically compromised."

fv_status=$(fdesetup status 2>/dev/null || echo "unknown")

if echo "$fv_status" | grep -qi "FileVault is On"; then
    emit_pass "FileVault is enabled" "FileVault"
return 0
elif echo "$fv_status" | grep -qi "FileVault is Off"; then
    emit_warn "FileVault is OFF — disk is NOT encrypted"
    emit_info "FileVault requires interactive setup (password + recovery key)."
    emit_info "Enable it: System Settings -> Privacy & Security -> FileVault -> Turn On"
    emit_info "Choose 'Create a recovery key' — do NOT use iCloud for a dedicated machine."
    emit_fail "FileVault is off (enable manually in System Settings)" "FileVault"
return 0
fi

emit_warn "Could not determine FileVault status"
emit_fail "FileVault status unknown" "FileVault"
}

# --- Check: firewall ---

__meta_firewall() {
    case "$1" in
        name) echo "macOS Firewall" ;;
        id)   echo "firewall" ;;
    esac
}

__check_firewall() {
# ============================================================================
# Clawkeeper Check: macOS Firewall
# Detects whether the macOS application firewall is enabled and whether
# "Block all incoming connections" is active.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Host-level firewall provides defense in depth beyond network isolation."

fw_on=false
fw_block_all=false

fw_status=$(/usr/libexec/ApplicationFirewall/socketfilterfw --getglobalstate 2>/dev/null || echo "unknown")

if echo "$fw_status" | grep -qi "enabled"; then
    fw_on=true
fi

if [ "$fw_on" = true ]; then
    block_status=$(/usr/libexec/ApplicationFirewall/socketfilterfw --getblockall 2>/dev/null || echo "unknown")
    if echo "$block_status" | grep -qi "enabled"; then
        fw_block_all=true
    fi
fi

if [ "$fw_on" = true ] && [ "$fw_block_all" = true ]; then
    emit_pass "Firewall is on with 'Block all incoming' enabled" "Firewall"
return 0
elif [ "$fw_on" = true ]; then
    emit_warn "Firewall is ON but 'Block all incoming' is not set"
    emit_info "This allows some incoming connections. Strictest mode blocks all."
    emit_prompt "Enable 'Block all incoming connections'?" "enable_block_all" \
        "Firewall 'Block all incoming' is not enabled" \
        "Firewall left in permissive mode"
return 0
fi

# Firewall is off
emit_warn "macOS Firewall is OFF"
emit_prompt "Enable the firewall with 'Block all incoming'?" "enable_firewall" \
    "macOS Firewall is off" \
    "Firewall left off"
}

__remediate_firewall() {
# ============================================================================
# Clawkeeper Remediation: macOS Firewall
# Enables the firewall and/or sets "Block all incoming connections".
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    enable_block_all)
        # Firewall is already on — just enable block-all
        sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setblockall on &>/dev/null || true
        emit_pass "Firewall set to block all incoming" "Firewall"
        emit_info "Note: This may block Screen Sharing. Add exceptions if needed."
        ;;
    enable_firewall)
        # Firewall is off — enable everything
        sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate on &>/dev/null || true
        sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setblockall on &>/dev/null || true
        sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setstealthmode on &>/dev/null || true
        emit_pass "Firewall enabled (block all + stealth mode)" "Firewall"
        emit_info "Note: This may block Screen Sharing. Add exceptions if needed."
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Firewall"
        ;;
esac
}

# --- Check: gateway_advanced ---

__meta_gateway_advanced() {
    case "$1" in
        name) echo "Gateway Advanced Security" ;;
        id)   echo "gateway_advanced" ;;
    esac
}

__check_gateway_advanced() {
# ============================================================================
# Clawkeeper Check: Gateway Advanced Security
# Checks elevated tools, browser control, group access, plugin allowlist,
# and trusted proxy configuration.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

config_file="$HOME/.openclaw/openclaw.json"

if [ ! -f "$config_file" ]; then
    emit_info "No openclaw.json found — skipping advanced gateway checks"
return 0
fi

emit_info "Advanced gateway security checks:"

# ---------- Elevated tool access ----------
if grep -q '"elevated"' "$config_file" 2>/dev/null; then
    if grep -q '"elevated"' "$config_file" 2>/dev/null && grep -q '"enabled".*true' "$config_file" 2>/dev/null; then
        # Check more precisely: look for elevated block with enabled: true
        # Using a simple heuristic since we don't have jq
        local_elevated=$(grep -A2 '"elevated"' "$config_file" 2>/dev/null | grep '"enabled"' | head -1)
        if echo "$local_elevated" | grep -q 'true' 2>/dev/null; then
            emit_fail "Elevated tool execution is enabled (tools.elevated.enabled: true)" "Elevated Tools"
            emit_info "Disable elevated execution: set tools.elevated.enabled = false"
        else
            emit_pass "Elevated tool execution is disabled" "Elevated Tools"
        fi
    else
        emit_pass "Elevated tool execution is disabled" "Elevated Tools"
    fi
else
    emit_pass "Elevated tool execution not configured (disabled by default)" "Elevated Tools"
fi

# ---------- Browser control ----------
# Check if browser control tools are exposed
if grep -q '"browser"' "$config_file" 2>/dev/null; then
    # Check if browser mode is set to off
    if grep -A3 '"browser"' "$config_file" 2>/dev/null | grep -q '"mode".*"off"' 2>/dev/null; then
        emit_pass "Browser control is disabled (mode: off)" "Browser Control"
    else
        emit_fail "Browser control is enabled — treat as operator-level access" "Browser Control"
        emit_info "Disable when unused: gateway.nodes.browser.mode = 'off'"
        emit_info "If needed, restrict to tailnet-only access"
    fi
else
    emit_pass "Browser control not configured (safe default)" "Browser Control"
fi

# ---------- Group access policy ----------
if grep -q '"requireMention".*true' "$config_file" 2>/dev/null; then
    emit_pass "requireMention = true (bot only responds when @mentioned)" "Group Mention Policy"
else
    if grep -q '"groupPolicy"' "$config_file" 2>/dev/null; then
        if grep -q '"groupPolicy".*"allowlist"' "$config_file" 2>/dev/null; then
            emit_pass "Group policy is set to allowlist" "Group Access Policy"
        elif grep -q '"groupPolicy".*"open"' "$config_file" 2>/dev/null; then
            emit_fail "Group policy is 'open' — any group member can command the bot" "Group Access Policy"
            emit_info "Set groupPolicy to 'allowlist' or enable requireMention"
        fi
    else
        emit_fail "requireMention not enabled for group channels" "Group Mention Policy"
        emit_info "Set requireMention: true to prevent responding to arbitrary group messages"
    fi
fi

# ---------- Plugin/extension allowlist ----------
if grep -q '"plugins"' "$config_file" 2>/dev/null; then
    if grep -q '"allow"' "$config_file" 2>/dev/null; then
        emit_pass "Plugin allowlist is configured (plugins.allow)" "Plugin Allowlist"
    else
        emit_fail "Plugins loaded without explicit allowlist" "Plugin Allowlist"
        emit_info "Define plugins.allow to explicitly trust only required plugins"
    fi
else
    emit_pass "No plugins configured" "Plugin Allowlist"
fi

# ---------- Trusted proxy configuration ----------
if grep -q '"trustedProxies"' "$config_file" 2>/dev/null; then
    emit_pass "Trusted proxies are configured (gateway.trustedProxies)" "Trusted Proxies"
else
    # Only flag if gateway is not in loopback mode (proxy config irrelevant for local-only)
    if grep -q '"bind"' "$config_file" 2>/dev/null; then
        local_bind=$(grep '"bind"' "$config_file" 2>/dev/null | head -1)
        if echo "$local_bind" | grep -q '"loopback"' 2>/dev/null; then
            emit_pass "Gateway is loopback-only (trusted proxies not needed)" "Trusted Proxies"
        else
            emit_fail "Gateway exposed without trusted proxy configuration" "Trusted Proxies"
            emit_info "Set gateway.trustedProxies to prevent auth bypass via header spoofing"
        fi
    else
        emit_pass "Gateway bind mode not set (defaults safe)" "Trusted Proxies"
    fi
fi

# ---------- Dangerous tool deny list ----------
# Check if automation, runtime, and fs groups are denied
denied_groups=0
for group in "group:automation" "group:runtime" "group:fs"; do
    if grep -q "$group" "$config_file" 2>/dev/null; then
        denied_groups=$((denied_groups + 1))
    fi
done

if [ "$denied_groups" -ge 3 ]; then
    emit_pass "Dangerous tool groups denied (automation, runtime, fs)" "Tool Deny List"
elif [ "$denied_groups" -gt 0 ]; then
    emit_warn "Some dangerous tool groups are denied but not all"
    emit_fail "Deny all dangerous tool groups: automation, runtime, fs" "Tool Deny List"
else
    emit_fail "Dangerous tool groups not explicitly denied" "Tool Deny List"
    emit_info "Add to tools.deny: group:automation, group:runtime, group:fs"
fi
}

# --- Check: homebrew ---

__meta_homebrew() {
    case "$1" in
        name) echo "Homebrew" ;;
        id)   echo "homebrew" ;;
    esac
}

__check_homebrew() {
# ============================================================================
# Clawkeeper Check: Homebrew
# Detects whether Homebrew is installed on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Package manager needed for installing Docker, Node.js, and other tools."

if command -v brew &>/dev/null; then
    brew_version=$(brew --version 2>/dev/null | head -1 || echo "unknown")
    emit_pass "Homebrew is installed ($brew_version)" "Homebrew"
return 0
fi

# Homebrew not found — prompt to install
emit_warn "Homebrew is not installed"
emit_prompt "Install Homebrew now?" "install_homebrew" \
    "Homebrew not installed" \
    "Homebrew not installed"
}

__remediate_homebrew() {
# ============================================================================
# Clawkeeper Remediation: Homebrew
# Installs Homebrew and configures PATH for the current and future sessions.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    install_homebrew)
        emit_info "Running Homebrew installer..."

        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" || {
            emit_fail "Homebrew installation failed" "Homebrew"
return 1
        }

        # Add to PATH based on architecture
        brew_prefix=""
        if [ -f /opt/homebrew/bin/brew ]; then
            brew_prefix="/opt/homebrew"
        elif [ -f /usr/local/bin/brew ]; then
            brew_prefix="/usr/local"
        fi

        if [ -n "$brew_prefix" ]; then
            eval "$("${brew_prefix}/bin/brew" shellenv)"
            # Also add to shell profile for future sessions
            shell_profile="$HOME/.zprofile"
            if ! grep -q 'homebrew' "$shell_profile" 2>/dev/null; then
                echo "eval \"\$(${brew_prefix}/bin/brew shellenv)\"" >> "$shell_profile"
                emit_info "Added Homebrew to $shell_profile"
            fi
        fi

        if command -v brew &>/dev/null; then
            emit_pass "Homebrew installed" "Homebrew"
        else
            emit_fail "Homebrew installed but not in PATH — restart your terminal" "Homebrew"
return 1
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Homebrew"
        ;;
esac
}

# --- Check: icloud ---

__meta_icloud() {
    case "$1" in
        name) echo "iCloud" ;;
        id)   echo "icloud" ;;
    esac
}

__check_icloud() {
# ============================================================================
# Clawkeeper Check: iCloud
# Detects whether an iCloud account is signed in on macOS.
# Info-only — no automated remediation (must sign out manually).
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "iCloud syncs data off-device. A compromised agent's files shouldn't trigger cloud uploads."

# Check if any iCloud account is configured
icloud_account=$(defaults read MobileMeAccounts Accounts 2>/dev/null || echo "")

if [ -z "$icloud_account" ] || echo "$icloud_account" | grep -q "(\s*)"; then
    emit_pass "No iCloud account signed in" "iCloud"
return 0
fi

emit_warn "An iCloud account appears to be signed in"
emit_info "iCloud can sync OpenClaw workspace files to Apple's servers."
emit_info "Sign out: System Settings -> [your name] -> Sign Out"
emit_info "Or disable iCloud Drive: System Settings -> Apple ID -> iCloud -> iCloud Drive -> OFF"
emit_fail "iCloud is signed in (disable manually in System Settings)" "iCloud"
}

# --- Check: linux_auto_updates ---

__meta_linux_auto_updates() {
    case "$1" in
        name) echo "Automatic Security Updates" ;;
        id)   echo "linux_auto_updates" ;;
    esac
}

__check_linux_auto_updates() {
# ============================================================================
# Clawkeeper Check: Automatic Security Updates
# Checks unattended-upgrades (Debian/Ubuntu) or dnf-automatic (RHEL/Fedora).
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Servers should auto-install security patches to prevent known exploits."

# Detect distro family
distro=""
if [ -f /etc/os-release ]; then
    . /etc/os-release
    case "$ID" in
        ubuntu|debian) distro="debian" ;;
        fedora|rhel|centos|rocky|almalinux) distro="rhel" ;;
        *) distro="$ID" ;;
    esac
fi

if [ "$distro" = "debian" ]; then
    if dpkg -l unattended-upgrades 2>/dev/null | grep -q "^ii"; then
        if systemctl is-active --quiet unattended-upgrades 2>/dev/null; then
            emit_pass "unattended-upgrades is installed and active" "Auto Updates"
        else
            emit_warn "unattended-upgrades is installed but not active"
            emit_prompt "Enable automatic security updates?" "enable_unattended_upgrades" \
                "Automatic updates not active" \
                "Automatic updates not enabled"
        fi
    else
        emit_warn "unattended-upgrades is not installed"
        emit_prompt "Install and enable automatic security updates?" "install_unattended_upgrades" \
            "No automatic updates configured" \
            "Automatic updates not configured"
    fi
elif [ "$distro" = "rhel" ]; then
    if rpm -q dnf-automatic &>/dev/null; then
        emit_pass "dnf-automatic is installed" "Auto Updates"
    else
        emit_warn "dnf-automatic is not installed"
        emit_prompt "Install and enable automatic security updates?" "install_dnf_automatic" \
            "No automatic updates configured" \
            "Automatic updates not configured"
    fi
else
    emit_info "Auto-update check not supported for distro: ${distro:-unknown}"
    emit_skipped "Auto-update check skipped (unsupported distro)" "Auto Updates"
fi
}

__remediate_linux_auto_updates() {
# ============================================================================
# Clawkeeper Remediation: Automatic Security Updates
# Installs/enables unattended-upgrades or dnf-automatic depending on distro.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    enable_unattended_upgrades)
        sudo systemctl enable --now unattended-upgrades 2>/dev/null || true
        emit_pass "Automatic updates enabled" "Auto Updates"
        ;;
    install_unattended_upgrades)
        sudo apt-get update -qq && sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq unattended-upgrades 2>&1 | tail -3
        sudo systemctl enable --now unattended-upgrades 2>/dev/null || true
        emit_pass "unattended-upgrades installed and enabled" "Auto Updates"
        ;;
    install_dnf_automatic)
        sudo dnf install -y -q dnf-automatic 2>&1 | tail -3
        sudo systemctl enable --now dnf-automatic-install.timer 2>/dev/null || true
        emit_pass "dnf-automatic installed and enabled" "Auto Updates"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Auto Updates"
        ;;
esac
}

# --- Check: linux_disk_encryption ---

__meta_linux_disk_encryption() {
    case "$1" in
        name) echo "Disk Encryption" ;;
        id)   echo "linux_disk_encryption" ;;
    esac
}

__check_linux_disk_encryption() {
# ============================================================================
# Clawkeeper Check: Linux Disk Encryption
# Detects LUKS / dm-crypt encrypted volumes.
# Info-only — no automated remediation (most VPS providers do not offer LUKS).
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Protects data at rest if the server disk is accessed outside the VM."

# Method 1: check lsblk for crypt type
if command -v lsblk &>/dev/null; then
    if lsblk -o TYPE 2>/dev/null | grep -q "crypt"; then
        emit_pass "LUKS disk encryption detected" "Disk Encryption"
return 0
    fi
fi

# Method 2: check /dev/mapper for crypt* or luks* entries
if ls /dev/mapper/crypt* &>/dev/null 2>&1 || ls /dev/mapper/luks* &>/dev/null 2>&1; then
    emit_pass "Encrypted volumes detected" "Disk Encryption"
return 0
fi

# No encryption detected
emit_warn "No disk encryption detected"
emit_info "Most VPS providers do not offer LUKS. Consider provider-level encryption"
emit_info "or application-level encryption for sensitive data."

if [ "$MODE" = "scan" ]; then
    emit_fail "No disk encryption detected" "Disk Encryption"
else
    emit_skipped "Disk encryption not available (typical for VPS)" "Disk Encryption"
fi
}

# --- Check: linux_docker ---

__meta_linux_docker() {
    case "$1" in
        name) echo "Docker Engine" ;;
        id)   echo "linux_docker" ;;
    esac
}

__check_linux_docker() {
# ============================================================================
# Clawkeeper Check: Linux Docker Engine
# Detects Docker installation, running status, and Compose plugin.
# Offers to start the service or install Docker from get.docker.com.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Docker provides container isolation for OpenClaw."

if command -v docker &>/dev/null; then
    if docker info &>/dev/null 2>&1; then
        docker_version=$(docker --version 2>/dev/null | head -1 || echo "unknown")
        emit_pass "Docker is installed and running ($docker_version)" "Docker"

        # Check Docker Compose
        if docker compose version &>/dev/null 2>&1; then
            compose_ver=$(docker compose version --short 2>/dev/null || echo "unknown")
            emit_info "Docker Compose $compose_ver available"
        else
            emit_warn "Docker Compose plugin not found"
            emit_info "Install: sudo apt-get install docker-compose-plugin"
        fi
return 0
    else
        emit_warn "Docker is installed but not running or accessible"
        emit_prompt "Start Docker service?" "start_docker" \
            "Docker not running" \
            "Docker not started"
return 0
    fi
fi

# Docker not installed at all
emit_warn "Docker is not installed"
emit_prompt "Install Docker Engine via official script?" "install_docker" \
    "Docker not installed" \
    "Docker not installed"
}

__remediate_linux_docker() {
# ============================================================================
# Clawkeeper Remediation: Linux Docker Engine
# Handles starting the Docker service or installing Docker from get.docker.com.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    start_docker)
        emit_info "Starting Docker service..."
        sudo systemctl start docker 2>/dev/null
        sudo systemctl enable docker 2>/dev/null

        if docker info &>/dev/null 2>&1; then
            emit_pass "Docker service started and enabled" "Docker"
        else
            emit_fail "Docker could not be started — check: sudo journalctl -u docker" "Docker"
return 1
        fi
        ;;
    install_docker)
        emit_info "Installing Docker Engine (this may take a minute)..."
        curl -fsSL https://get.docker.com | sudo sh 2>&1 | tail -10 || {
            emit_fail "Docker installation failed" "Docker"
return 1
        }

        # Add current user to docker group
        current_user=$(whoami)
        if [ "$current_user" != "root" ]; then
            sudo usermod -aG docker "$current_user" 2>/dev/null || true
            emit_info "Added $current_user to docker group (log out/in to take effect)"
        fi

        sudo systemctl enable --now docker 2>/dev/null || true

        if docker info &>/dev/null 2>&1 || sudo docker info &>/dev/null 2>&1; then
            emit_pass "Docker Engine installed and running" "Docker"
        else
            emit_warn "Docker installed — you may need to log out and back in"
            emit_info "Then verify with: docker info"
            emit_pass "Docker Engine installed (re-login may be required)" "Docker"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Docker"
        ;;
esac
}

# --- Check: linux_essentials ---

__meta_linux_essentials() {
    case "$1" in
        name) echo "Essential Packages" ;;
        id)   echo "linux_essentials" ;;
    esac
}

__check_linux_essentials() {
# ============================================================================
# Clawkeeper Check: Linux Essential Packages
# Checks for git, curl, openssl, and ca-certificates.
# Emits a remediation prompt if any are missing.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Checking for git, curl, openssl, and ca-certificates."

missing=()
for pkg in git curl openssl ca-certificates; do
    # ca-certificates is a package, not a command — check differently
    if [ "$pkg" = "ca-certificates" ]; then
        # Check if the ca-certificates bundle exists
        if [ -f /etc/ssl/certs/ca-certificates.crt ] || [ -d /etc/pki/tls/certs ] || dpkg -s ca-certificates &>/dev/null 2>&1 || rpm -q ca-certificates &>/dev/null 2>&1; then
            emit_info "$pkg is installed"
        else
            missing+=("$pkg")
            emit_warn "$pkg is not installed"
        fi
    elif command -v "$pkg" &>/dev/null; then
        emit_info "$pkg is installed"
    else
        missing+=("$pkg")
        emit_warn "$pkg is not installed"
    fi
done

if [ ${#missing[@]} -eq 0 ]; then
    emit_pass "All essential packages installed" "Essentials"
return 0
fi

# Check for a supported package manager before offering remediation
if ! command -v apt-get &>/dev/null && ! command -v dnf &>/dev/null; then
    emit_fail "Missing packages: ${missing[*]} (unsupported package manager)" "Essentials"
return 0
fi

emit_prompt "Install missing packages (${missing[*]})?" "install_essentials" \
    "Missing packages: ${missing[*]}" \
    "Missing packages not installed"
}

__remediate_linux_essentials() {
# ============================================================================
# Clawkeeper Remediation: Linux Essential Packages
# Installs missing packages via apt-get or dnf.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    install_essentials)
        # Re-detect which packages are missing
        missing=()
        for pkg in git curl openssl ca-certificates; do
            if [ "$pkg" = "ca-certificates" ]; then
                if [ -f /etc/ssl/certs/ca-certificates.crt ] || [ -d /etc/pki/tls/certs ] || dpkg -s ca-certificates &>/dev/null 2>&1 || rpm -q ca-certificates &>/dev/null 2>&1; then
                    continue
                fi
                missing+=("$pkg")
            elif ! command -v "$pkg" &>/dev/null; then
                missing+=("$pkg")
            fi
        done

        if [ ${#missing[@]} -eq 0 ]; then
            emit_pass "All essential packages already installed" "Essentials"
return 0
        fi

        emit_info "Installing missing packages: ${missing[*]}"

        if command -v apt-get &>/dev/null; then
            sudo apt-get update -qq && sudo apt-get install -y -qq "${missing[@]}" 2>&1 | tail -3 || {
                emit_fail "Package installation failed" "Essentials"
return 1
            }
        elif command -v dnf &>/dev/null; then
            sudo dnf install -y -q "${missing[@]}" 2>&1 | tail -3 || {
                emit_fail "Package installation failed" "Essentials"
return 1
            }
        else
            emit_fail "Unsupported package manager" "Essentials"
return 1
        fi

        emit_pass "Essential packages installed" "Essentials"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Essentials"
        ;;
esac
}

# --- Check: linux_fail2ban ---

__meta_linux_fail2ban() {
    case "$1" in
        name) echo "Fail2ban" ;;
        id)   echo "linux_fail2ban" ;;
    esac
}

__check_linux_fail2ban() {
# ============================================================================
# Clawkeeper Check: Fail2ban
# Checks whether fail2ban is installed and running.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Blocks IPs after repeated failed login attempts."

if command -v fail2ban-client &>/dev/null; then
    if systemctl is-active --quiet fail2ban 2>/dev/null; then
        emit_pass "Fail2ban is installed and running" "Fail2ban"
    else
        emit_warn "Fail2ban is installed but not running"
        emit_prompt "Start and enable fail2ban?" "start_fail2ban" \
            "Fail2ban is not running" \
            "Fail2ban not started"
    fi
else
    emit_warn "Fail2ban is not installed"
    emit_prompt "Install and configure fail2ban?" "install_fail2ban" \
        "Fail2ban is not installed" \
        "Fail2ban not installed"
fi
}

__remediate_linux_fail2ban() {
# ============================================================================
# Clawkeeper Remediation: Fail2ban
# Installs and/or starts fail2ban with a sensible default configuration.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    start_fail2ban)
        sudo systemctl enable --now fail2ban 2>/dev/null
        emit_pass "Fail2ban started and enabled" "Fail2ban"
        ;;
    install_fail2ban)
        if command -v apt-get &>/dev/null; then
            sudo apt-get update -qq && sudo apt-get install -y -qq fail2ban 2>&1 | tail -3
        elif command -v dnf &>/dev/null; then
            sudo dnf install -y -q fail2ban 2>&1 | tail -3
        else
            emit_fail "Cannot install fail2ban -- unsupported package manager" "Fail2ban"
return 1
        fi

        sudo tee /etc/fail2ban/jail.local > /dev/null << 'F2B_EOF'
# CLAW Keeper — fail2ban configuration
[DEFAULT]
bantime = 1h
findtime = 10m
maxretry = 3

[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
F2B_EOF

        sudo systemctl enable --now fail2ban 2>/dev/null || true
        emit_pass "Fail2ban installed and configured" "Fail2ban"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Fail2ban"
        ;;
esac
}

# --- Check: linux_firewall ---

__meta_linux_firewall() {
    case "$1" in
        name) echo "Firewall (UFW)" ;;
        id)   echo "linux_firewall" ;;
    esac
}

__check_linux_firewall() {
# ============================================================================
# Clawkeeper Check: Firewall (UFW)
# Checks UFW status: active, installed-but-inactive, or not installed.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "A firewall limits inbound access to only the ports you need."

if command -v ufw &>/dev/null; then
    ufw_status=$(sudo ufw status 2>/dev/null || ufw status 2>/dev/null || echo "unknown")

    if echo "$ufw_status" | grep -qi "Status: active"; then
        emit_pass "UFW firewall is active" "Firewall"

        # Check if OpenClaw port is exposed externally
        if echo "$ufw_status" | grep -q "18789.*ALLOW.*Anywhere"; then
            emit_warn "Port 18789 is open in UFW -- prefer SSH tunnel over direct exposure"
        fi
return 0
    fi

    # UFW is installed but not active
    emit_warn "UFW is installed but not active"
    emit_prompt "Enable UFW with SSH-only inbound rules?" "enable_ufw" \
        "UFW firewall is not active" \
        "Firewall not enabled"
else
    # UFW is not installed
    emit_warn "UFW is not installed"
    emit_prompt "Install and configure UFW?" "install_ufw" \
        "No firewall installed" \
        "Firewall not installed"
fi
}

__remediate_linux_firewall() {
# ============================================================================
# Clawkeeper Remediation: Firewall (UFW)
# Installs and/or enables UFW with SSH-only inbound rules.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    enable_ufw)
        sudo ufw default deny incoming 2>/dev/null
        sudo ufw default allow outgoing 2>/dev/null
        sudo ufw allow ssh 2>/dev/null
        sudo ufw --force enable 2>/dev/null
        emit_pass "UFW enabled (SSH allowed, OpenClaw via SSH tunnel only)" "Firewall"
        emit_info "Access OpenClaw via: ssh -N -L 18789:127.0.0.1:18789 user@this-server"
        ;;
    install_ufw)
        if command -v apt-get &>/dev/null; then
            sudo apt-get update -qq && sudo apt-get install -y -qq ufw 2>&1 | tail -3
        elif command -v dnf &>/dev/null; then
            sudo dnf install -y -q ufw 2>&1 | tail -3
        else
            emit_fail "Cannot install UFW -- unsupported package manager" "Firewall"
return 1
        fi
        sudo ufw default deny incoming 2>/dev/null
        sudo ufw default allow outgoing 2>/dev/null
        sudo ufw allow ssh 2>/dev/null
        sudo ufw --force enable 2>/dev/null
        emit_pass "UFW installed and enabled (SSH-only inbound)" "Firewall"
        emit_info "Access OpenClaw via SSH tunnel -- do NOT open port 18789"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Firewall"
        ;;
esac
}

# --- Check: linux_network ---

__meta_linux_network() {
    case "$1" in
        name) echo "Network Configuration" ;;
        id)   echo "linux_network" ;;
    esac
}

__check_linux_network() {
# ============================================================================
# Clawkeeper Check: Linux Network Configuration
# Displays public IP, local IP, and virtualization type.
# Info-only — always passes.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Reviewing network interfaces and connectivity."

# Gather public IP
public_ip=$(curl -sf --max-time 5 https://ifconfig.me 2>/dev/null \
    || curl -sf --max-time 5 https://api.ipify.org 2>/dev/null \
    || echo "unknown")

# Gather local IP
local_ip=$(hostname -I 2>/dev/null | awk '{print $1}' || echo "unknown")

emit_info "Public IP: $public_ip"
emit_info "Local IP: $local_ip"

# Detect virtualization type
virt_type=$(systemd-detect-virt 2>/dev/null || echo "unknown")
emit_info "Virtualization: $virt_type"

emit_info "For VPS deployments, bind OpenClaw to loopback and access via SSH tunnel:"
emit_info "  ssh -N -L 18789:127.0.0.1:18789 user@$public_ip"

emit_pass "Network info displayed" "Network"
}

# --- Check: linux_node ---

__meta_linux_node() {
    case "$1" in
        name) echo "Node.js" ;;
        id)   echo "linux_node" ;;
    esac
}

__check_linux_node() {
# ============================================================================
# Clawkeeper Check: Linux Node.js
# Detects whether Node.js >= 22 is installed.
# Offers installation via NodeSource if missing or outdated.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "OpenClaw requires Node.js 22 or higher."

if command -v node &>/dev/null; then
    node_version=$(node --version 2>/dev/null || echo "unknown")
    major_version=$(echo "$node_version" | sed 's/v//' | cut -d. -f1)

    if [ "$major_version" -ge 22 ] 2>/dev/null; then
        emit_pass "Node.js $node_version installed (meets v22+ requirement)" "Node.js"
return 0
    else
        emit_warn "Node.js $node_version is installed but OpenClaw needs v22+"
    fi
else
    emit_warn "Node.js is not installed"
fi

# Check for a supported package manager before offering remediation
if ! command -v apt-get &>/dev/null && ! command -v dnf &>/dev/null; then
    emit_fail "Node.js 22+ not available (unsupported package manager for NodeSource)" "Node.js"
return 0
fi

emit_prompt "Install Node.js 22 via NodeSource?" "install_node" \
    "Node.js 22+ not installed" \
    "Node.js not installed"
}

__remediate_linux_node() {
# ============================================================================
# Clawkeeper Remediation: Linux Node.js
# Installs Node.js 22 via NodeSource repository.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    install_node)
        emit_info "Setting up NodeSource repository..."

        if command -v apt-get &>/dev/null; then
            curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash - 2>&1 | tail -5 || {
                emit_fail "NodeSource setup failed" "Node.js"
return 1
            }
            sudo apt-get install -y -qq nodejs 2>&1 | tail -3 || {
                emit_fail "Node.js installation failed" "Node.js"
return 1
            }
        elif command -v dnf &>/dev/null; then
            curl -fsSL https://rpm.nodesource.com/setup_22.x | sudo -E bash - 2>&1 | tail -5 || {
                emit_fail "NodeSource setup failed" "Node.js"
return 1
            }
            sudo dnf install -y -q nodejs 2>&1 | tail -3 || {
                emit_fail "Node.js installation failed" "Node.js"
return 1
            }
        else
            emit_fail "Unsupported package manager for NodeSource" "Node.js"
return 1
        fi

        if command -v node &>/dev/null; then
            new_version=$(node --version 2>/dev/null)
            emit_pass "Node.js $new_version installed" "Node.js"
        else
            emit_fail "Node.js installation failed" "Node.js"
return 1
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Node.js"
        ;;
esac
}

# --- Check: linux_open_ports ---

__meta_linux_open_ports() {
    case "$1" in
        name) echo "Open Ports Audit" ;;
        id)   echo "linux_open_ports" ;;
    esac
}

__check_linux_open_ports() {
# ============================================================================
# Clawkeeper Check: Linux Open Ports Audit
# Uses ss or netstat to identify listening ports. Flags OpenClaw gateway
# (port 18789) on 0.0.0.0 as critical.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Only essential ports should be listening on external interfaces."

listening_ports=""
if command -v ss &>/dev/null; then
    listening_ports=$(ss -tlnp 2>/dev/null || echo "")
elif command -v netstat &>/dev/null; then
    listening_ports=$(netstat -tlnp 2>/dev/null || echo "")
else
    emit_info "Neither ss nor netstat available — skipping port audit"
    emit_skipped "No port inspection tool available" "Open Ports"
return 0
fi

if [ -z "$listening_ports" ]; then
    emit_info "Could not retrieve listening ports"
    emit_skipped "Could not retrieve listening ports" "Open Ports"
return 0
fi

# Report listening services
if command -v ss &>/dev/null; then
    while IFS= read -r line; do
        addr=$(echo "$line" | awk '{print $4}')
        proc=$(echo "$line" | awk '{print $6}')
        if echo "$addr" | grep -q "0.0.0.0\|::"; then
            emit_warn "External listener: $addr -- $proc"
        else
            emit_info "Local listener: $addr -- $proc"
        fi
    done < <(ss -tlnp 2>/dev/null | grep "LISTEN")
fi

# Critical: check if OpenClaw port is externally exposed
if echo "$listening_ports" | grep -q "0.0.0.0:18789\|:::18789"; then
    emit_fail "OpenClaw gateway (18789) is listening on ALL interfaces — CRITICAL" "Open Ports"
    emit_info "Bind to loopback only and use SSH tunnel for access"
else
    emit_pass "No critical port exposure detected" "Open Ports"
fi
}

# --- Check: linux_ssh_hardening ---

__meta_linux_ssh_hardening() {
    case "$1" in
        name) echo "SSH Hardening" ;;
        id)   echo "linux_ssh_hardening" ;;
    esac
}

__check_linux_ssh_hardening() {
# ============================================================================
# Clawkeeper Check: SSH Hardening
# Checks sshd_config for PermitRootLogin, PasswordAuthentication,
# X11Forwarding, and MaxAuthTries.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "SSH is the primary attack surface on a VPS. Hardening is critical."

sshd_config="/etc/ssh/sshd_config"

if [ ! -f "$sshd_config" ]; then
    emit_warn "sshd_config not found at $sshd_config"
    emit_fail "Cannot audit SSH configuration" "SSH Hardening"
return 0
fi

issues=0

# Check PermitRootLogin
root_login=$(grep -i "^PermitRootLogin" "$sshd_config" 2>/dev/null | awk '{print $2}' || echo "")
if [ -z "$root_login" ]; then
    root_login=$(grep -rhi "^PermitRootLogin" /etc/ssh/sshd_config.d/ 2>/dev/null | tail -1 | awk '{print $2}' || echo "")
fi
if [ "$root_login" = "no" ] || [ "$root_login" = "prohibit-password" ]; then
    emit_pass "PermitRootLogin = $root_login" "PermitRootLogin"
else
    issues=$((issues + 1))
    emit_fail "PermitRootLogin is '${root_login:-yes (default)}' -- should be 'no' or 'prohibit-password'" "PermitRootLogin"
fi

# Check PasswordAuthentication
pass_auth=$(grep -i "^PasswordAuthentication" "$sshd_config" 2>/dev/null | awk '{print $2}' || echo "")
if [ -z "$pass_auth" ]; then
    pass_auth=$(grep -rhi "^PasswordAuthentication" /etc/ssh/sshd_config.d/ 2>/dev/null | tail -1 | awk '{print $2}' || echo "")
fi
if [ "$pass_auth" = "no" ]; then
    emit_pass "PasswordAuthentication = no" "PasswordAuthentication"
else
    issues=$((issues + 1))
    emit_fail "PasswordAuthentication is '${pass_auth:-yes (default)}' -- should be 'no'" "PasswordAuthentication"
fi

# Check X11Forwarding
x11=$(grep -i "^X11Forwarding" "$sshd_config" 2>/dev/null | awk '{print $2}' || echo "")
if [ "$x11" = "no" ]; then
    emit_pass "X11Forwarding = no" "X11Forwarding"
elif [ "$x11" = "yes" ]; then
    issues=$((issues + 1))
    emit_fail "X11Forwarding is enabled -- should be 'no' on a headless server" "X11Forwarding"
fi

# Check MaxAuthTries
max_auth=$(grep -i "^MaxAuthTries" "$sshd_config" 2>/dev/null | awk '{print $2}' || echo "")
if [ -n "$max_auth" ] && [ "$max_auth" -le 3 ] 2>/dev/null; then
    emit_pass "MaxAuthTries = $max_auth" "MaxAuthTries"
elif [ -n "$max_auth" ] && [ "$max_auth" -gt 6 ] 2>/dev/null; then
    issues=$((issues + 1))
    emit_fail "MaxAuthTries is $max_auth -- recommend 3 or less" "MaxAuthTries"
fi

if [ "$issues" -eq 0 ]; then
    emit_pass "SSH configuration is hardened" "SSH Hardening"
else
    emit_prompt "Harden SSH configuration?" "harden_ssh" \
        "SSH is not fully hardened" \
        "SSH hardening deferred"
fi
}

__remediate_linux_ssh_hardening() {
# ============================================================================
# Clawkeeper Remediation: SSH Hardening
# Creates a drop-in config at /etc/ssh/sshd_config.d/99-clawkeeper-hardening.conf,
# validates configuration, and reloads sshd.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    harden_ssh)
        dropin_dir="/etc/ssh/sshd_config.d"
        sudo mkdir -p "$dropin_dir" 2>/dev/null || true

        sudo tee "$dropin_dir/99-clawkeeper-hardening.conf" > /dev/null << 'SSH_EOF'
# CLAW Keeper SSH hardening
PermitRootLogin prohibit-password
PasswordAuthentication no
X11Forwarding no
MaxAuthTries 3
AllowAgentForwarding no
SSH_EOF

        # Validate config before reloading
        if sudo sshd -t 2>/dev/null; then
            sudo systemctl reload sshd 2>/dev/null || sudo systemctl reload ssh 2>/dev/null || true
            emit_pass "SSH hardened (drop-in: $dropin_dir/99-clawkeeper-hardening.conf)" "SSH Hardening"
            emit_warn "IMPORTANT: Verify you can still SSH in from another terminal before closing this session!"
        else
            sudo rm -f "$dropin_dir/99-clawkeeper-hardening.conf"
            emit_fail "SSH config validation failed -- changes reverted" "SSH Hardening"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "SSH Hardening"
        ;;
esac
}

# --- Check: linux_unnecessary_services ---

__meta_linux_unnecessary_services() {
    case "$1" in
        name) echo "Unnecessary Services" ;;
        id)   echo "linux_unnecessary_services" ;;
    esac
}

__check_linux_unnecessary_services() {
# ============================================================================
# Clawkeeper Check: Unnecessary Services
# Checks for running services that are typically unnecessary on a server:
# cups, avahi-daemon, bluetooth, ModemManager, whoopsie, apport.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Reducing running services minimizes the attack surface."

declare -A checked_services=(
    ["cups"]="Printing (CUPS)"
    ["avahi-daemon"]="mDNS/Bonjour (Avahi)"
    ["bluetooth"]="Bluetooth"
    ["ModemManager"]="Modem Manager"
    ["whoopsie"]="Ubuntu error reporting"
    ["apport"]="Crash reporting"
)

# Preserve ordering with a separate array
service_order=("cups" "avahi-daemon" "bluetooth" "ModemManager" "whoopsie" "apport")

found_services=()

for svc_name in "${service_order[@]}"; do
    svc_desc="${checked_services[$svc_name]}"
    if systemctl is-active --quiet "$svc_name" 2>/dev/null; then
        found_services+=("$svc_name")
        emit_warn "$svc_desc ($svc_name) is running"
    fi
done

if [ ${#found_services[@]} -eq 0 ]; then
    emit_pass "No unnecessary services detected" "Unnecessary Services"
return 0
fi

emit_prompt "Disable ${#found_services[@]} unnecessary service(s)?" "disable_services" \
    "Unnecessary services running" \
    "Unnecessary services left running"
}

__remediate_linux_unnecessary_services() {
# ============================================================================
# Clawkeeper Remediation: Unnecessary Services
# Disables all detected unnecessary services.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_services)
        # Re-check which services are running and disable them
        declare -A checked_services=(
            ["cups"]="Printing (CUPS)"
            ["avahi-daemon"]="mDNS/Bonjour (Avahi)"
            ["bluetooth"]="Bluetooth"
            ["ModemManager"]="Modem Manager"
            ["whoopsie"]="Ubuntu error reporting"
            ["apport"]="Crash reporting"
        )

        service_order=("cups" "avahi-daemon" "bluetooth" "ModemManager" "whoopsie" "apport")
        disabled_count=0

        for svc_name in "${service_order[@]}"; do
            svc_desc="${checked_services[$svc_name]}"
            if systemctl is-active --quiet "$svc_name" 2>/dev/null; then
                sudo systemctl disable --now "$svc_name" 2>/dev/null || true
                emit_info "Disabled $svc_desc ($svc_name)"
                disabled_count=$((disabled_count + 1))
            fi
        done

        if [ "$disabled_count" -gt 0 ]; then
            emit_pass "Disabled $disabled_count unnecessary service(s)" "Unnecessary Services"
        else
            emit_pass "No unnecessary services found to disable" "Unnecessary Services"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Unnecessary Services"
        ;;
esac
}

# --- Check: linux_user_account ---

__meta_linux_user_account() {
    case "$1" in
        name) echo "User Account" ;;
        id)   echo "linux_user_account" ;;
    esac
}

__check_linux_user_account() {
# ============================================================================
# Clawkeeper Check: Linux User Account
# Detects whether running as root and checks docker group membership.
# User creation is interactive (password input) so we emit FAIL with
# instructions rather than a prompt.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "OpenClaw should run under a non-root user to limit blast radius."

current_user=$(whoami)

if [ "$current_user" = "root" ]; then
    emit_warn "You are running as root"
    emit_info "A compromised agent running as root has full system access."

    if id "openclaw" &>/dev/null; then
        emit_info "A dedicated 'openclaw' user already exists."
        emit_info "Switch to it: su - openclaw"
        emit_fail "Running as root (switch to 'openclaw' user)" "User Account"
    else
        emit_info "To create a dedicated 'openclaw' user, run the following manually:"
        if getent group docker &>/dev/null; then
            emit_info "  useradd -m -s /bin/bash -G docker openclaw"
        else
            emit_info "  useradd -m -s /bin/bash openclaw"
        fi
        emit_info "  passwd openclaw"
        emit_info "Then grant sudo access:"
        emit_info "  echo 'openclaw ALL=(ALL) NOPASSWD:ALL' > /etc/sudoers.d/openclaw"
        emit_info "  chmod 440 /etc/sudoers.d/openclaw"
        emit_info "Create OpenClaw directories:"
        emit_info "  mkdir -p /home/openclaw/.openclaw/workspace"
        emit_info "  chown -R openclaw:openclaw /home/openclaw/.openclaw"
        emit_info "Then switch to the new user: su - openclaw"
        emit_fail "Running as root (create a dedicated 'openclaw' user)" "User Account"
    fi
else
    emit_pass "Running as non-root user: $current_user" "User Account"

    # Check docker group membership if Docker is available
    if command -v docker &>/dev/null; then
        if groups "$current_user" 2>/dev/null | grep -qw "docker"; then
            emit_pass "User is in 'docker' group" "Docker Group"
        else
            emit_warn "User is not in 'docker' group (needed for Docker deployment)"
            emit_info "To add yourself: sudo usermod -aG docker $current_user"
            emit_info "Log out and back in for group membership to take effect."
        fi
    fi
fi
}

# --- Check: location_services ---

__meta_location_services() {
    case "$1" in
        name) echo "Location Services" ;;
        id)   echo "location_services" ;;
    esac
}

__check_location_services() {
# ============================================================================
# Clawkeeper Check: Location Services
# Detects whether Location Services are enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Location data embeds in file metadata that OpenClaw might process or transmit."

ls_enabled=false

if command -v defaults &>/dev/null; then
    # Try reading without elevated access first
    ls_status=$(defaults read /var/db/locationd/Library/Preferences/ByHost/com.apple.locationd LocationServicesEnabled 2>/dev/null || echo "unknown")

    if [ "$ls_status" = "1" ]; then
        ls_enabled=true
    elif [ "$ls_status" = "0" ]; then
        ls_enabled=false
    else
        # Can't read the plist without elevated access — use launchctl as fallback
        if launchctl list 2>/dev/null | grep -q "locationd"; then
            # Service is running, likely enabled
            ls_enabled=true
        fi
    fi
fi

if [ "$ls_enabled" = false ]; then
    emit_pass "Location Services appear disabled" "Location Services"
return 0
fi

emit_warn "Location Services appear to be ENABLED"
emit_prompt "Attempt to disable Location Services?" "disable_location_services" \
    "Location Services are enabled" \
    "Location Services left enabled"
}

__remediate_location_services() {
# ============================================================================
# Clawkeeper Remediation: Location Services
# Disables Location Services on macOS (requires sudo).
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_location_services)
        sudo defaults write /var/db/locationd/Library/Preferences/ByHost/com.apple.locationd LocationServicesEnabled -bool false 2>/dev/null || true
        emit_pass "Location Services disabled" "Location Services"
        emit_info "Note: A restart may be required for this to fully take effect"
        emit_info "Verify in System Settings → Privacy & Security → Location Services"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Location Services"
        ;;
esac
}

# --- Check: mdns_bonjour ---

__meta_mdns_bonjour() {
    case "$1" in
        name) echo "mDNS / Bonjour (OpenClaw Discovery)" ;;
        id)   echo "mdns_bonjour" ;;
    esac
}

__check_mdns_bonjour() {
# ============================================================================
# Clawkeeper Check: mDNS / Bonjour (OpenClaw Discovery)
# Scans for OpenClaw mDNS broadcasts on the local network using dns-sd.
# Uses a 5-second timeout to detect any _openclaw-gw._tcp broadcasts.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "OpenClaw can broadcast its presence via mDNS. This should be disabled."
emit_info "Scanning for OpenClaw mDNS broadcasts (5 seconds)..."

# Use perl alarm to enforce a 5-second timeout on dns-sd browse
mdns_result=$(perl -e 'alarm 5; exec @ARGV' dns-sd -B _openclaw-gw._tcp 2>/dev/null || true)

if echo "$mdns_result" | grep -qi "openclaw"; then
    emit_fail "OpenClaw is broadcasting via mDNS — discoverable on the network" "mDNS"
    emit_info "Set OPENCLAW_DISABLE_BONJOUR=1 in your environment"
    emit_info "Set gateway.discover.mode = 'off' in openclaw.json"
else
    emit_pass "No OpenClaw mDNS broadcasts detected" "mDNS"
fi
}

# --- Check: native_openclaw ---

__meta_native_openclaw() {
    case "$1" in
        name) echo "OpenClaw (npm)" ;;
        id)   echo "native_openclaw" ;;
    esac
}

__check_native_openclaw() {
# ============================================================================
# Clawkeeper Check: OpenClaw (npm)
# Detects whether OpenClaw is available via global install or npx.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Checking if OpenClaw is installed globally..."

# Check direct command (global install — required for LaunchAgent)
if command -v openclaw >/dev/null 2>&1; then
    oc_version=$(openclaw --version 2>/dev/null || echo "unknown")
    emit_pass "OpenClaw is installed ($oc_version)" "OpenClaw npm"
return 0
fi

# npx can run it, but it's not a real install — LaunchAgent needs a global binary
if command -v npx >/dev/null 2>&1; then
    npx_version=$(npx openclaw --version 2>/dev/null || echo "")
    if [ -n "$npx_version" ]; then
        emit_info "OpenClaw $npx_version is available via npx but not installed globally"
        emit_info "A global install is required for the LaunchAgent to auto-start OpenClaw"
    fi
fi

# Not found globally — needs install
emit_warn "OpenClaw is not installed globally"

if ! command -v npm >/dev/null 2>&1; then
    emit_fail "npm not available — install Node.js first" "OpenClaw npm"
return 0
fi

emit_prompt "Install OpenClaw globally via npm?" "install_openclaw" \
    "OpenClaw not installed globally" \
    "OpenClaw not installed globally"
}

__remediate_native_openclaw() {
# ============================================================================
# Clawkeeper Remediation: OpenClaw (npm)
# Installs OpenClaw globally via npm.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    install_openclaw)
        emit_info "Installing openclaw..."

        local npm_output npm_rc
        npm_output=$(npm install -g openclaw@latest 2>&1)
        npm_rc=$?
        echo "$npm_output" | tail -5

        if [ $npm_rc -ne 0 ]; then
            emit_fail "OpenClaw installation failed" "OpenClaw npm"
return 1
        fi

        if command -v openclaw &>/dev/null; then
            new_version=$(openclaw --version 2>/dev/null || echo "installed")
            emit_pass "OpenClaw $new_version installed" "OpenClaw npm"
        else
            emit_fail "OpenClaw installed but not in PATH — restart your terminal" "OpenClaw npm"
return 1
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "OpenClaw npm"
        ;;
esac
}

# --- Check: network_isolation ---

__meta_network_isolation() {
    case "$1" in
        name) echo "Network Isolation" ;;
        id)   echo "network_isolation" ;;
    esac
}

__check_network_isolation() {
# ============================================================================
# Clawkeeper Check: Network Isolation
# Displays current network info (Wi-Fi SSID, gateway, local IP) so the user
# can manually verify this machine is on a dedicated isolated network.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Checking if this machine appears to be on an isolated network."

# Get current Wi-Fi SSID
ssid=$(networksetup -getairportnetwork en0 2>/dev/null | sed 's/Current Wi-Fi Network: //' || echo "unknown")
if [ "$ssid" = "unknown" ] || echo "$ssid" | grep -qi "not associated\|error\|not found"; then
    # Fallback to legacy airport binary (may not exist on newer macOS)
    ssid=$(/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I 2>/dev/null | awk '/ SSID/ {print substr($0, index($0, $2))}' || echo "unknown")
fi

if [ "$ssid" != "unknown" ]; then
    emit_info "Connected to Wi-Fi: $ssid"
    emit_info "Verify this is your dedicated isolated network, not your primary Wi-Fi."
else
    emit_info "Could not determine Wi-Fi SSID"
fi

# Report gateway
gateway_ip=$(route -n get default 2>/dev/null | grep "gateway" | awk '{print $2}' || echo "unknown")
emit_info "Default gateway: $gateway_ip"

# Report local IP
local_ip=$(ipconfig getifaddr en0 2>/dev/null || ipconfig getifaddr en1 2>/dev/null || echo "unknown")
emit_info "Local IP: $local_ip"

emit_info "Manual verification required:"
emit_info "  1. Confirm this is NOT your primary network"
emit_info "  2. Test: ping a device on your primary network (should FAIL)"
emit_info "  3. Test: ping 8.8.8.8 (should SUCCEED)"

emit_pass "Network info displayed for manual verification" "Network Isolation"
}

# --- Check: node ---

__meta_node() {
    case "$1" in
        name) echo "Node.js" ;;
        id)   echo "node" ;;
    esac
}

__check_node() {
# ============================================================================
# Clawkeeper Check: Node.js
# Detects whether Node.js >= 22 is installed.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "OpenClaw requires Node.js 22 or higher."

if command -v node &>/dev/null; then
    node_version=$(node --version 2>/dev/null || echo "unknown")
    major_version=$(echo "$node_version" | sed 's/v//' | cut -d. -f1)

    if [ "$major_version" -ge 22 ] 2>/dev/null; then
        emit_pass "Node.js $node_version installed (meets v22+ requirement)" "Node.js"
return 0
    else
        emit_warn "Node.js $node_version is installed but OpenClaw needs v22+"
    fi
else
    emit_warn "Node.js is not installed"
fi

# Check if brew is available for the remediation
if ! command -v brew &>/dev/null; then
    emit_fail "Node.js 22+ not available (install Homebrew first)" "Node.js"
return 0
fi

emit_prompt "Install Node.js 22 via Homebrew?" "install_node" \
    "Node.js 22+ not installed" \
    "Node.js not installed"
}

__remediate_node() {
# ============================================================================
# Clawkeeper Remediation: Node.js
# Installs Node.js 22 via Homebrew.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    install_node)
        emit_info "Installing node@22..."

        brew install node@22 2>&1 | tail -3 || {
            emit_fail "Node.js installation failed" "Node.js"
return 1
        }

        # Link if needed
        brew link --overwrite node@22 2>/dev/null || true

        if command -v node &>/dev/null; then
            new_version=$(node --version 2>/dev/null)
            emit_pass "Node.js $new_version installed" "Node.js"
        else
            emit_fail "Node.js installed but not in PATH — restart your terminal" "Node.js"
return 1
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Node.js"
        ;;
esac
}

# --- Check: openclaw_config ---

__meta_openclaw_config() {
    case "$1" in
        name) echo "OpenClaw Configuration Audit" ;;
        id)   echo "openclaw_config" ;;
    esac
}

__check_openclaw_config() {
# ============================================================================
# Clawkeeper Check: OpenClaw Configuration Audit
# Audits ~/.openclaw directory permissions, openclaw.json file permissions,
# and key config values: gateway.bind, auth.mode, controlUI, discover.mode,
# exec.ask, redactSensitive, and credential exposure.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

config_file="$HOME/.openclaw/openclaw.json"
config_dir="$HOME/.openclaw"

# ---------- Check config directory exists ----------
if [ ! -d "$config_dir" ]; then
    emit_info "No OpenClaw config directory found (~/.openclaw)"
    emit_info "This is expected if OpenClaw isn't installed yet. Skipping config checks."
return 0
fi

# ---------- Check directory permissions ----------
dir_perms=$(stat -f "%OLp" "$config_dir" 2>/dev/null || stat -c "%a" "$config_dir" 2>/dev/null || echo "unknown")
if [ "$dir_perms" = "700" ]; then
    emit_pass "Config directory permissions are 700 (owner-only)" "Config Permissions"
else
    emit_prompt "Config directory permissions are $dir_perms — fix to 700?" \
        "fix_config_dir_perms" \
        "Config directory permissions are $dir_perms (should be 700)" \
        "Config directory permissions not changed"
fi

# ---------- Check config file exists ----------
if [ ! -f "$config_file" ]; then
    emit_info "No openclaw.json found. Skipping config content checks."
return 0
fi

# ---------- Check config file permissions ----------
file_perms=$(stat -f "%OLp" "$config_file" 2>/dev/null || stat -c "%a" "$config_file" 2>/dev/null || echo "unknown")
if [ "$file_perms" = "600" ]; then
    emit_pass "Config file permissions are 600" "Config File Permissions"
else
    emit_prompt "Config file permissions are $file_perms — fix to 600?" \
        "fix_config_file_perms" \
        "Config file permissions are $file_perms (should be 600)" \
        "Config file permissions not changed"
fi

# ---------- Parse key config values ----------
emit_info "Configuration audit:"

# gateway.bind
if grep -q '"bind".*"loopback"' "$config_file" 2>/dev/null; then
    emit_pass "gateway.bind = loopback" "gateway.bind"
elif grep -q '"bind"' "$config_file" 2>/dev/null; then
    emit_fail "gateway.bind is set but NOT to loopback" "gateway.bind"
else
    emit_warn "gateway.bind not explicitly set"
    emit_fail "gateway.bind not configured (should be 'loopback')" "gateway.bind"
fi

# gateway.auth.mode
if grep -q '"mode".*"token"' "$config_file" 2>/dev/null; then
    emit_pass "gateway.auth.mode = token" "gateway.auth"
else
    emit_fail "Token authentication not configured" "gateway.auth"
fi

# gateway.controlUI
if grep -q '"controlUI".*false' "$config_file" 2>/dev/null; then
    emit_pass "gateway.controlUI = false (web UI disabled)" "gateway.controlUI"
else
    emit_warn "gateway.controlUI may be enabled"
    emit_fail "Web control UI should be disabled (controlUI: false)" "gateway.controlUI"
fi

# gateway.discover.mode
if grep -q '"discover"' "$config_file" 2>/dev/null && grep -q '"mode".*"off"' "$config_file" 2>/dev/null; then
    emit_pass "gateway.discover.mode = off (mDNS disabled)" "gateway.discover"
else
    emit_fail "mDNS discovery should be disabled (discover.mode: off)" "gateway.discover"
fi

# exec.ask
if grep -q '"ask".*"on"' "$config_file" 2>/dev/null; then
    emit_pass "exec.ask = on (explicit consent mode)" "exec.ask"
else
    emit_fail "Explicit consent not enabled (exec.ask should be 'on')" "exec.ask"
fi

# logging.redactSensitive
if grep -q '"redactSensitive"' "$config_file" 2>/dev/null; then
    emit_pass "logging.redactSensitive is configured" "logging.redactSensitive"
else
    emit_fail "Sensitive log redaction not configured" "logging.redactSensitive"
fi

# Check for plain-text API keys in config
if grep -qiE "(api.key|api_key|apikey|sk-ant-|sk-)" "$config_file" 2>/dev/null; then
    emit_fail "CRITICAL: Possible plain-text API keys found in config file" "Credential Exposure"
    emit_info "Move API keys to environment variables or a .env file"
else
    emit_pass "No plain-text API keys detected in config" "Credential Exposure"
fi
}

__remediate_openclaw_config() {
# ============================================================================
# Clawkeeper Remediation: OpenClaw Configuration
# Fixes config directory and file permissions.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    fix_config_dir_perms)
        config_dir="$HOME/.openclaw"
        if [ -d "$config_dir" ]; then
            chmod 700 "$config_dir"
            emit_pass "Config directory set to 700" "Config Permissions"
        else
            emit_fail "Config directory not found: $config_dir" "Config Permissions"
        fi
        ;;
    fix_config_file_perms)
        config_file="$HOME/.openclaw/openclaw.json"
        if [ -f "$config_file" ]; then
            chmod 600 "$config_file"
            emit_pass "Config file set to 600" "Config File Permissions"
        else
            emit_fail "Config file not found: $config_file" "Config File Permissions"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "OpenClaw Config"
        ;;
esac
}

# --- Check: openclaw_hardening ---

__meta_openclaw_hardening() {
    case "$1" in
        name) echo "OpenClaw Hardening Audit" ;;
        id)   echo "openclaw_hardening" ;;
    esac
}

__check_openclaw_hardening() {
# ============================================================================
# Clawkeeper Check: OpenClaw Hardening Audit
# Advanced configuration checks: sandbox mode, exec host policy, DM scope,
# DM policy, filesystem restriction, and log redaction level.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

config_file="$HOME/.openclaw/openclaw.json"

if [ ! -f "$config_file" ]; then
    emit_info "No openclaw.json found — skipping hardening checks"
return 0
fi

emit_info "Advanced hardening checks:"

# ---------- Sandbox mode ----------
if grep -q '"sandbox"' "$config_file" 2>/dev/null && grep -q '"mode".*"all"' "$config_file" 2>/dev/null; then
    emit_pass "agents.defaults.sandbox.mode = all" "Sandbox Mode"
else
    emit_fail "Sandbox mode should be 'all' (agents.defaults.sandbox.mode)" "Sandbox Mode"
    emit_info "This ensures all agent actions run within the sandbox"
fi

# ---------- Exec host policy ----------
if grep -q '"exec"' "$config_file" 2>/dev/null && grep -q '"host".*"sandbox"' "$config_file" 2>/dev/null; then
    emit_pass "tools.exec.host = sandbox" "Exec Policy"
else
    emit_fail "Exec host should be 'sandbox' (not gateway/elevated)" "Exec Policy"
    emit_info "Prevents agents from executing on the gateway host directly"
fi

# ---------- DM scope ----------
if grep -q '"dmScope".*"per-channel-peer"' "$config_file" 2>/dev/null; then
    emit_pass "session.dmScope = per-channel-peer" "DM Scope"
else
    emit_fail "DM scope should be 'per-channel-peer' for isolation" "DM Scope"
fi

# ---------- DM policy ----------
if grep -q '"dmPolicy".*"pairing"' "$config_file" 2>/dev/null || grep -q '"dm".*"pairing"' "$config_file" 2>/dev/null; then
    emit_pass "DM policy = pairing (requires mutual opt-in)" "DM Policy"
else
    emit_fail "DM policy should be 'pairing' (not 'open')" "DM Policy"
    emit_info "Open DM policy allows any user to message the bot directly"
fi

# ---------- Filesystem restriction ----------
if grep -q '"workspaceOnly".*true' "$config_file" 2>/dev/null; then
    emit_pass "tools.fs.workspaceOnly = true" "Filesystem Restriction"
else
    emit_fail "Filesystem access should be restricted to workspace only" "Filesystem Restriction"
    emit_info "Set tools.fs.workspaceOnly = true in openclaw.json"
fi

# ---------- Log redaction level ----------
if grep -q '"redactSensitive".*"tools"' "$config_file" 2>/dev/null; then
    emit_pass "logging.redactSensitive = tools (full redaction)" "Log Redaction Level"
elif grep -q '"redactSensitive".*true' "$config_file" 2>/dev/null; then
    emit_warn "logging.redactSensitive is enabled but not set to 'tools'"
    emit_fail "Log redaction should be 'tools' for complete coverage" "Log Redaction Level"
else
    emit_fail "logging.redactSensitive not configured" "Log Redaction Level"
fi
}

# --- Check: openclaw_running ---

__meta_openclaw_running() {
    case "$1" in
        name) echo "OpenClaw Instance Detection" ;;
        id)   echo "openclaw_running" ;;
    esac
}

__check_openclaw_running() {
# ============================================================================
# Clawkeeper Check: OpenClaw Instance Detection
# Detects running OpenClaw instances via Docker containers, bare-metal
# processes, and port 18789 binding. If the gateway is bound to 0.0.0.0,
# it's a critical finding; 127.0.0.1 is safe.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Checking for running OpenClaw instances..."

found=false

# ---------- Check for OpenClaw Docker container ----------
if command -v docker &>/dev/null && docker info &>/dev/null 2>&1; then
    oc_containers=$(docker ps --format '{{.Names}} {{.Image}}' 2>/dev/null | grep -i "openclaw" || true)
    if [ -n "$oc_containers" ]; then
        found=true
        while IFS= read -r line; do
            emit_info "Found Docker container: $line"
        done <<< "$oc_containers"
    fi
fi

# ---------- Check for bare-metal process ----------
oc_process=$(pgrep -f "openclaw|moltbot|clawdbot" 2>/dev/null || true)
if [ -n "$oc_process" ]; then
    found=true
    while IFS= read -r line; do
        emit_info "Found bare-metal process: $line"
    done <<< "$oc_process"
fi

# ---------- Check for gateway port 18789 ----------
port_check=""
if command -v lsof &>/dev/null; then
    port_check=$(lsof -i :18789 2>/dev/null || true)
elif command -v ss &>/dev/null; then
    port_check=$(ss -tlnp 2>/dev/null | grep ":18789" || true)
fi

if [ -n "$port_check" ]; then
    found=true
    emit_info "Port 18789 is in use"

    # Check binding address
    if echo "$port_check" | grep -q "0.0.0.0"; then
        emit_fail "Gateway bound to 0.0.0.0 (ALL interfaces) — CRITICAL" "OpenClaw Gateway"
        emit_info "This exposes the gateway to the entire network."
        emit_info "Fix: Set gateway.bind to 'loopback' in openclaw.json"
    elif echo "$port_check" | grep -q "127.0.0.1\|localhost"; then
        emit_pass "Gateway bound to localhost only" "OpenClaw Gateway"
    else
        emit_warn "Gateway binding could not be determined"
    fi
fi

if [ "$found" = false ]; then
    emit_info "No running OpenClaw instance detected"
    emit_info "This is expected if you haven't installed OpenClaw yet."
fi
}

# --- Check: openclaw_version ---

__meta_openclaw_version() {
    case "$1" in
        name) echo "OpenClaw Version & CVE Check" ;;
        id)   echo "openclaw_version" ;;
    esac
}

__check_openclaw_version() {
# ============================================================================
# Clawkeeper Check: OpenClaw Version & CVE Check
# Detects installed OpenClaw version and checks against known vulnerabilities.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

# --- Known vulnerable versions ---
# Format: "max_affected_version|CVE|severity|description"
# All versions BEFORE 2026.1.29 are affected by these CVEs
KNOWN_CVES=(
    "2026.1.28|CVE-2026-24763|HIGH|Gateway authentication bypass via crafted request"
    "2026.1.28|CVE-2026-25253|HIGH|1-click RCE: WebSocket gatewayUrl token leak from query string"
)

# Minimum safe version
MIN_SAFE_VERSION="2026.1.29"

# --- Detect OpenClaw version ---
oc_version=""
if command -v openclaw &>/dev/null; then
    oc_version=$(openclaw --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
elif command -v npx &>/dev/null; then
    oc_version=$(npx openclaw --version 2>/dev/null | grep -oE '[0-9]+\.[0-9]+\.[0-9]+' | head -1)
fi

if [ -z "$oc_version" ]; then
    emit_skipped "OpenClaw not detected — version check skipped" "OpenClaw Version"
return 0
fi

emit_info "Detected OpenClaw version: $oc_version"

# --- Version comparison helper ---
# Returns 0 if $1 <= $2 (version A is less than or equal to version B)
version_lte() {
    local IFS='.'
    local -a a=($1) b=($2)
    local i
    for ((i=0; i<3; i++)); do
        local va=${a[$i]:-0}
        local vb=${b[$i]:-0}
        if (( va < vb )); then return 0; fi
        if (( va > vb )); then return 1; fi
    done
    return 0  # equal
}

version_lt() {
    local IFS='.'
    local -a a=($1) b=($2)
    local i
    for ((i=0; i<3; i++)); do
        local va=${a[$i]:-0}
        local vb=${b[$i]:-0}
        if (( va < vb )); then return 0; fi
        if (( va > vb )); then return 1; fi
    done
    return 1  # equal means not less-than
}

# --- Check against known CVEs ---
vuln_count=0
for entry in "${KNOWN_CVES[@]}"; do
    IFS='|' read -r max_affected cve severity description <<< "$entry"
    if version_lte "$oc_version" "$max_affected"; then
        emit_fail "CRITICAL: $cve ($severity) — $description [fixed in $MIN_SAFE_VERSION]" "CVE: $cve"
        vuln_count=$((vuln_count + 1))
    fi
done

if [ "$vuln_count" -eq 0 ]; then
    emit_pass "OpenClaw $oc_version has no known CVEs" "OpenClaw Version"
else
    emit_warn "Found $vuln_count known CVE(s) — upgrade to OpenClaw >= $MIN_SAFE_VERSION"
    emit_info "Run: npm install -g openclaw@latest"
fi

# --- Check if version is recent ---
# Warn if version is more than 3 major releases behind latest known
latest_known="2026.1.29"
if version_lt "$oc_version" "$latest_known"; then
    emit_warn "OpenClaw $oc_version may be outdated (latest known: $latest_known)"
fi
}

# --- Check: remote_login ---

__meta_remote_login() {
    case "$1" in
        name) echo "Remote Login" ;;
        id)   echo "remote_login" ;;
    esac
}

__check_remote_login() {
# ============================================================================
# Clawkeeper Check: Remote Login (SSH)
# Detects whether Remote Login (SSH) is enabled on macOS via systemsetup.
# May require sudo to read the setting on some macOS versions.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "SSH is useful for managing this machine remotely. Verify it's intentional."

ssh_status=$(systemsetup -getremotelogin 2>&1 || echo "unknown")

# If the call requires admin privileges, skip — don't prompt for password
if echo "$ssh_status" | grep -qi "requires admin\|not authorized\|error"; then
    ssh_status="unknown"
fi

if echo "$ssh_status" | grep -qi "off"; then
    emit_pass "Remote Login (SSH) is off" "Remote Login"
    emit_info "Enable it if you need to manage this machine from your primary Mac."
return 0
elif echo "$ssh_status" | grep -qi "on"; then
    emit_warn "Remote Login (SSH) is ON"
    emit_info "This is expected if you manage this machine remotely."
    emit_info "Ensure only authorized keys are in ~/.ssh/authorized_keys"
    emit_pass "Remote Login (SSH) is on (verify this is intentional)" "Remote Login"
return 0
fi

# Could not determine status
emit_warn "Could not determine Remote Login status"
emit_skipped "Remote Login status unknown" "Remote Login"
}

# --- Check: screen_sharing ---

__meta_screen_sharing() {
    case "$1" in
        name) echo "Screen Sharing" ;;
        id)   echo "screen_sharing" ;;
    esac
}

__check_screen_sharing() {
# ============================================================================
# Clawkeeper Check: Screen Sharing
# Detects whether macOS Screen Sharing is enabled via launchctl.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Screen Sharing should only be enabled if you're accessing this Mac remotely."

screen_sharing=false

# Check if Screen Sharing is enabled via launchctl
if launchctl list 2>/dev/null | grep -q "com.apple.screensharing"; then
    screen_sharing=true
fi

if [ "$screen_sharing" = true ]; then
    emit_warn "Screen Sharing is ON"
    emit_info "This is expected if you access this Mac via Screen Sharing from your main Mac."
    emit_info "Ensure only authorized users have access."
    emit_pass "Screen Sharing is on (verify this is intentional)" "Screen Sharing"
else
    emit_pass "Screen Sharing is off" "Screen Sharing"
fi
}

# --- Check: session_commands ---

__meta_session_commands() {
    case "$1" in
        name) echo "Session Rogue Commands" ;;
        id)   echo "session_commands" ;;
    esac
}

__check_session_commands() {
# ============================================================================
# Clawkeeper Check: Session Rogue Commands
# Scans session JSONL files for suspicious bash commands executed by agents.
# Detects potential data exfiltration, reverse shells, and privilege escalation.
# Outputs JSON lines to stdout.
# ============================================================================


sessions_dir="$HOME/.openclaw/agents"
if [ ! -d "$sessions_dir" ]; then
    emit_info "No agents directory found — skipping session command scan"
return 0
fi

session_files=$(find "$sessions_dir" -name "*.jsonl" -type f 2>/dev/null | sort -r | head -10)
if [ -z "$session_files" ]; then
    emit_info "No session log files found"
return 0
fi

rogue_found=false

while IFS= read -r sfile; do
    [ -z "$sfile" ] && continue

    # Extract lines referencing bash tool_use / command content
    cmd_content=$(grep -E '"(tool_use|bash|command)"' "$sfile" 2>/dev/null | head -500 || true)
    [ -z "$cmd_content" ] && continue

    # Data exfiltration — curl/wget POSTing data
    if echo "$cmd_content" | grep -qiE 'curl.*(--data|-d |-X POST|--upload)|wget.*--post'; then
        rogue_found=true
        snippet=$(echo "$cmd_content" | grep -oiE 'curl.*(--data|-d |-X POST|--upload)|wget.*--post' | head -1 | cut -c1-60)
        emit_fail "Suspicious data exfil command: ${snippet}" "Session Rogue Commands"
        emit_info "File: $sfile"
    fi

    # Reverse shells
    if echo "$cmd_content" | grep -qiE '(nc|ncat|netcat).* -e.*(bash|sh|/bin)|bash -i.*>&.*/dev/tcp'; then
        rogue_found=true
        emit_fail "Reverse shell pattern detected in session commands" "Session Rogue Commands"
        emit_info "File: $sfile"
    fi

    # Base64 decode piped to shell
    if echo "$cmd_content" | grep -qiE 'base64.*(decode|--decode|-d).*\|.*(bash|sh)'; then
        rogue_found=true
        emit_fail "Base64-to-shell execution detected" "Session Rogue Commands"
        emit_info "File: $sfile"
    fi

    # Privilege escalation
    if echo "$cmd_content" | grep -qiE 'chmod 777|chmod [+]s|chown root'; then
        rogue_found=true
        emit_fail "Privilege escalation command detected (chmod 777/setuid)" "Session Rogue Commands"
        emit_info "File: $sfile"
    fi

    # Sensitive file access
    if echo "$cmd_content" | grep -qiE '(cat|less|head|tail|cp|scp).*/etc/(shadow|passwd)|authorized_keys'; then
        rogue_found=true
        emit_fail "Sensitive file access detected (/etc/shadow, /etc/passwd, authorized_keys)" "Session Rogue Commands"
        emit_info "File: $sfile"
    fi

    # Download-and-execute
    if echo "$cmd_content" | grep -qiE '(curl|wget).*\|.*(bash|sh)'; then
        rogue_found=true
        emit_fail "Download-and-execute pattern detected (curl|bash)" "Session Rogue Commands"
        emit_info "File: $sfile"
    fi

    # Env dumping to external
    if echo "$cmd_content" | grep -qiE '(printenv|env|set).*\|.*(curl|wget|nc|ncat)'; then
        rogue_found=true
        emit_fail "Environment variable exfiltration detected" "Session Rogue Commands"
        emit_info "File: $sfile"
    fi

    # History clearing
    if echo "$cmd_content" | grep -qiE 'history -c|rm.*(bash_history|zsh_history|history)'; then
        rogue_found=true
        emit_fail "History clearing detected" "Session Rogue Commands"
        emit_info "File: $sfile"
    fi

done <<< "$session_files"

if [ "$rogue_found" = false ]; then
    emit_pass "No rogue command patterns detected in recent sessions" "Session Rogue Commands"
fi
}

# --- Check: siri ---

__meta_siri() {
    case "$1" in
        name) echo "Siri" ;;
        id)   echo "siri" ;;
    esac
}

__check_siri() {
# ============================================================================
# Clawkeeper Check: Siri
# Detects whether Siri and its assistant features are enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Siri indexes files, contacts, messages, and app activity locally."
emit_info "A compromised agent could query this index to enumerate sensitive data."

siri_enabled=false

# Check Siri assistant
if defaults read com.apple.assistant.support "Assistant Enabled" 2>/dev/null | grep -q "1"; then
    siri_enabled=true
fi

# Check Listen for Siri
if defaults read com.apple.Siri StatusMenuVisible 2>/dev/null | grep -q "1"; then
    siri_enabled=true
fi

if [ "$siri_enabled" = false ]; then
    emit_pass "Siri is disabled" "Siri"
return 0
fi

emit_warn "Siri is currently ENABLED"
emit_prompt "Disable Siri?" "disable_siri" "Siri is enabled" "Siri left enabled"
}

__remediate_siri() {
# ============================================================================
# Clawkeeper Remediation: Siri
# Disables Siri and related features on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_siri)
        defaults write com.apple.assistant.support "Assistant Enabled" -bool false 2>/dev/null || true
        defaults write com.apple.Siri StatusMenuVisible -bool false 2>/dev/null || true
        defaults write com.apple.Siri UserHasDeclinedEnable -bool true 2>/dev/null || true
        # Disable Siri suggestions
        defaults write com.apple.suggestions SuggestionsAllowFrom -int 0 2>/dev/null || true
        emit_pass "Siri disabled" "Siri" # FIXED status set by orchestrator
        emit_info "Note: You may need to also disable Siri in System Settings → Apple Intelligence & Siri"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Siri"
        ;;
esac
}

# --- Check: skills_security ---

__meta_skills_security() {
    case "$1" in
        name) echo "Skills Security Audit" ;;
        id)   echo "skills_security" ;;
    esac
}

__check_skills_security() {
# ============================================================================
# Clawkeeper Check: Skills Security Audit
# Scans skills directories for dangerous install commands, secret injection
# via apiKey/token/env blocks, and data exfiltration patterns.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

skills_dirs=(
    "$HOME/.openclaw/skills"
    "./skills"
)

found_skills=false

for skills_dir in "${skills_dirs[@]}"; do
    if [ ! -d "$skills_dir" ]; then
        continue
    fi
    found_skills=true

    # ---------- Check directory permissions ----------
    dir_perms=$(stat -f "%OLp" "$skills_dir" 2>/dev/null || stat -c "%a" "$skills_dir" 2>/dev/null || echo "unknown")
    if [ "$dir_perms" = "700" ]; then
        emit_pass "Skills directory ($skills_dir) permissions are 700" "Skills Directory Permissions"
    else
        emit_prompt "Skills directory ($skills_dir) permissions are $dir_perms — fix to 700?" \
            "fix_skills_dir_perms:${skills_dir}" \
            "Skills directory permissions are $dir_perms (should be 700)" \
            "Skills directory permissions not changed"
    fi

    # ---------- Scan each SKILL.md file ----------
    skill_files=$(find "$skills_dir" -name "SKILL.md" -o -name "skill.md" 2>/dev/null || true)
    if [ -z "$skill_files" ]; then
        emit_info "No SKILL.md files found in $skills_dir"
        continue
    fi

    emit_info "Scanning skills in $skills_dir:"

    install_flagged=false
    secret_flagged=false
    exfil_flagged=false

    while IFS= read -r skill_file; do
        [ -z "$skill_file" ] && continue
        skill_name=$(basename "$(dirname "$skill_file")")

        # 1. Install commands — check for dangerous patterns
        install_block=$(grep -iA5 "^install:" "$skill_file" 2>/dev/null || true)
        if [ -n "$install_block" ]; then
            if echo "$install_block" | grep -qiE 'curl\s|wget\s|eval\s|exec\s|bash\s+-c|base64|sh\s+-c|\|\s*sh|\|\s*bash'; then
                install_flagged=true
                emit_fail "CRITICAL: Skill '$skill_name' has dangerous install commands" "Skills Install Commands"
                emit_info "Found shell execution patterns in install block"
                emit_prompt "Quarantine skill '$skill_name'? (rename SKILL.md with .quarantined)" \
                    "quarantine_skill:${skill_file}" \
                    "Dangerous skill '$skill_name' not quarantined" \
                    "Skill '$skill_name' left as-is"
            fi
        fi

        # 2. Secret injection — skills using apiKey: or env: to inject secrets
        if grep -qiE '^\s*(apiKey|api_key|secret|token)\s*:' "$skill_file" 2>/dev/null; then
            secret_flagged=true
            emit_fail "Skill '$skill_name' injects secrets (apiKey/token)" "Skills Secret Injection"
            emit_info "Secrets injected via skills run in the host process context"
        fi
        if grep -qiE '^\s*env\s*:' "$skill_file" 2>/dev/null; then
            # Check if the env block references sensitive-looking vars
            env_block=$(grep -iA3 '^\s*env\s*:' "$skill_file" 2>/dev/null || true)
            if echo "$env_block" | grep -qiE 'KEY|SECRET|TOKEN|PASSWORD|CREDENTIAL'; then
                secret_flagged=true
                emit_fail "Skill '$skill_name' injects sensitive env vars" "Skills Secret Injection"
            fi
        fi

        # 3. Data exfiltration — curl/wget/nc with external URLs in body
        body_content=$(sed -n '/^---$/,/^---$/d; p' "$skill_file" 2>/dev/null || true)
        if echo "$body_content" | grep -qiE '(curl|wget|nc|ncat)\s+(https?://|[0-9]+\.[0-9]+\.[0-9]+)'; then
            exfil_flagged=true
            emit_fail "Skill '$skill_name' may exfiltrate data (external network call)" "Skills Data Exfiltration"
            emit_info "Review: $skill_file"
        fi

    done <<< "$skill_files"

    if [ "$install_flagged" = false ]; then
        emit_pass "No dangerous install commands found" "Skills Install Commands"
    fi
    if [ "$secret_flagged" = false ]; then
        emit_pass "No secret injection detected" "Skills Secret Injection"
    fi
    if [ "$exfil_flagged" = false ]; then
        emit_pass "No data exfiltration patterns found" "Skills Data Exfiltration"
    fi
done

if [ "$found_skills" = false ]; then
    emit_info "No skills directories found — skipping skills audit"
    emit_info "Checked: ~/.openclaw/skills/ and ./skills/"
fi
}

__remediate_skills_security() {
# ============================================================================
# Clawkeeper Remediation: Skills Security
# Quarantines dangerous skills by renaming SKILL.md and fixes directory perms.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    quarantine_skill:*)
        skill_file="${REMEDIATION_ID#quarantine_skill:}"
        if [ -f "$skill_file" ]; then
            skill_name=$(basename "$(dirname "$skill_file")")
            mv "$skill_file" "${skill_file}.quarantined"
            emit_pass "Skill '$skill_name' quarantined" "Skills Install Commands"
        else
            emit_fail "Skill file not found: $skill_file" "Skills Install Commands"
        fi
        ;;
    fix_skills_dir_perms:*)
        skills_dir="${REMEDIATION_ID#fix_skills_dir_perms:}"
        if [ -d "$skills_dir" ]; then
            chmod 700 "$skills_dir"
            emit_pass "Skills directory set to 700 ($skills_dir)" "Skills Directory Permissions"
        else
            emit_fail "Skills directory not found: $skills_dir" "Skills Directory Permissions"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Skills Security"
        ;;
esac
}

# --- Check: soul_security ---

__meta_soul_security() {
    case "$1" in
        name) echo "SOUL.md Security Audit" ;;
        id)   echo "soul_security" ;;
    esac
}

__check_soul_security() {
# ============================================================================
# Clawkeeper Check: SOUL.md Security Audit
# Checks SOUL.md permissions, sensitive data (credentials/PII), prompt
# injection patterns, base64-encoded blocks, invisible Unicode characters,
# and file size anomalies.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

soul_files=(
    "$HOME/.openclaw/SOUL.md"
    "./SOUL.md"
)

found_soul=false

for soul_file in "${soul_files[@]}"; do
    if [ ! -f "$soul_file" ]; then
        continue
    fi
    found_soul=true
    emit_info "Checking: $soul_file"

    # ---------- 1. Permissions — should be 600 ----------
    perms=$(stat -f "%OLp" "$soul_file" 2>/dev/null || stat -c "%a" "$soul_file" 2>/dev/null || echo "unknown")
    if [ "$perms" = "600" ]; then
        emit_pass "SOUL.md permissions are 600 ($soul_file)" "SOUL.md Permissions"
    else
        emit_prompt "SOUL.md permissions are $perms — fix to 600? ($soul_file)" \
            "fix_soul_perms:${soul_file}" \
            "SOUL.md permissions are $perms (should be 600)" \
            "SOUL.md permissions not changed"
    fi

    # ---------- 2. Sensitive data — credential/PII patterns ----------
    cred_patterns='(sk-ant-api|sk-[A-Za-z0-9]{20,}|ghp_|xoxb-|AKIA[0-9A-Z]|AIza[A-Za-z0-9]|password\s*[:=]\s*\S+)'
    soul_cred=$(grep -oiE "$cred_patterns" "$soul_file" 2>/dev/null | head -1 || true)
    if [ -n "$soul_cred" ]; then
        truncated=$(echo "$soul_cred" | cut -c1-4)
        emit_fail "Sensitive data found in SOUL.md (${truncated}****)" "SOUL.md Sensitive Data"
        emit_info "SOUL.md is loaded into every conversation — remove secrets immediately"
    else
        emit_pass "No sensitive data detected in SOUL.md" "SOUL.md Sensitive Data"
    fi

    # ---------- 3. Prompt injection / integrity ----------
    injection_hit=false

    # Check for common prompt injection patterns
    if grep -qiE '(you are now|ignore previous|disregard all|forget your instructions|new instructions|system prompt override|jailbreak)' "$soul_file" 2>/dev/null; then
        injection_hit=true
        emit_fail "Potential prompt injection detected in SOUL.md" "SOUL.md Integrity"
        emit_info "Found override/jailbreak language — review file for tampering"
    fi

    # Check for base64-encoded blocks (suspicious in a personality file)
    if grep -qE '[A-Za-z0-9+/]{40,}={0,2}$' "$soul_file" 2>/dev/null; then
        injection_hit=true
        emit_fail "Suspicious base64-encoded content in SOUL.md" "SOUL.md Integrity"
        emit_info "Base64 blocks in SOUL.md may hide malicious instructions"
    fi

    # Check for unusual Unicode (zero-width chars, RTL override, homoglyphs)
    if grep -qP '[\x{200B}-\x{200F}\x{202A}-\x{202E}\x{2060}\x{FEFF}]' "$soul_file" 2>/dev/null; then
        injection_hit=true
        emit_fail "Invisible Unicode characters found in SOUL.md" "SOUL.md Integrity"
        emit_info "Zero-width or directional override chars can hide injected text"
    fi

    if [ "$injection_hit" = false ]; then
        emit_pass "No prompt injection patterns detected" "SOUL.md Integrity"
    fi

    # ---------- 4. File size — over 10KB is suspicious ----------
    file_size=$(wc -c < "$soul_file" 2>/dev/null | tr -d ' ')
    if [ "$file_size" -gt 10240 ] 2>/dev/null; then
        emit_fail "SOUL.md is unusually large ($(( file_size / 1024 ))KB — over 10KB)" "SOUL.md Size"
        emit_info "Large SOUL.md files may contain hidden instructions or data"
    else
        emit_pass "SOUL.md size is reasonable ($(( file_size / 1024 ))KB)" "SOUL.md Size"
    fi
done

if [ "$found_soul" = false ]; then
    emit_info "No SOUL.md files found — skipping SOUL.md audit"
    emit_info "Checked: ~/.openclaw/SOUL.md and ./SOUL.md"
fi
}

__remediate_soul_security() {
# ============================================================================
# Clawkeeper Remediation: SOUL.md Security
# Fixes SOUL.md file permissions to 600.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    fix_soul_perms:*)
        soul_file="${REMEDIATION_ID#fix_soul_perms:}"
        if [ -f "$soul_file" ]; then
            chmod 600 "$soul_file"
            emit_pass "SOUL.md set to 600 ($soul_file)" "SOUL.md Permissions"
        else
            emit_fail "SOUL.md file not found: $soul_file" "SOUL.md Permissions"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "SOUL.md Permissions"
        ;;
esac
}

# --- Check: spotlight ---

__meta_spotlight() {
    case "$1" in
        name) echo "Spotlight Indexing" ;;
        id)   echo "spotlight" ;;
    esac
}

__check_spotlight() {
# ============================================================================
# Clawkeeper Check: Spotlight Indexing
# Detects whether Spotlight indexing is enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Spotlight indexes file contents and metadata. Reduces what's queryable by a compromised agent."

spotlight_on=false

spotlight_status=$(mdutil -s / 2>/dev/null || echo "unknown")

if echo "$spotlight_status" | grep -qi "indexing enabled"; then
    spotlight_on=true
elif echo "$spotlight_status" | grep -qi "indexing disabled"; then
    spotlight_on=false
else
    # Assume it's on by default
    spotlight_on=true
fi

if [ "$spotlight_on" = false ]; then
    emit_pass "Spotlight indexing is disabled" "Spotlight Indexing"
return 0
fi

emit_warn "Spotlight indexing is ENABLED"
emit_prompt "Disable Spotlight indexing entirely?" "disable_spotlight" \
    "Spotlight indexing is enabled" \
    "Spotlight left enabled"
}

__remediate_spotlight() {
# ============================================================================
# Clawkeeper Remediation: Spotlight Indexing
# Disables Spotlight indexing on macOS (requires sudo).
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_spotlight)
        sudo mdutil -a -i off &>/dev/null || true
        emit_pass "Spotlight indexing disabled" "Spotlight Indexing"
        emit_info "Consider excluding OpenClaw directories later: System Settings → Siri & Spotlight → Spotlight Privacy"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Spotlight Indexing"
        ;;
esac
}

# === Orchestrator (entrypoint) ===========================================

# ============================================================================
# Clawkeeper Orchestrator — CLI entrypoint
# Concatenated LAST by bundle.sh — do NOT add a shebang here.
#
# Dependencies (concatenated before this file):
#   lib/ui.sh        — colors, formatting, output helpers
#   lib/scanner.sh   — check runner, detection, reporting
#   lib/agent.sh     — SaaS agent management
#   lib/deploy.sh    — OpenClaw deployment (native + Docker)
#   lib/uninstall.sh — secure removal
#
# By RAD Security — https://rad.security
# ============================================================================

# --- Platform Detection Function --------------------------------------------

detect_platform() {
    local kernel
    kernel=$(uname -s 2>/dev/null || echo "unknown")

    case "$kernel" in
        Darwin)
            PLATFORM="macos"
            ;;
        Linux)
            PLATFORM="linux"
            # Detect distro
            if [ -f /etc/os-release ]; then
                # shellcheck disable=SC1091
                . /etc/os-release
                LINUX_DISTRO="${ID:-unknown}"
                LINUX_DISTRO_VERSION="${VERSION_ID:-unknown}"
                LINUX_DISTRO_NAME="${PRETTY_NAME:-$ID}"
            elif [ -f /etc/debian_version ]; then
                LINUX_DISTRO="debian"
                LINUX_DISTRO_VERSION=$(cat /etc/debian_version)
                LINUX_DISTRO_NAME="Debian $LINUX_DISTRO_VERSION"
            elif [ -f /etc/redhat-release ]; then
                LINUX_DISTRO="rhel"
                LINUX_DISTRO_VERSION=$(grep -oP '\d+' /etc/redhat-release | head -1)
                LINUX_DISTRO_NAME=$(cat /etc/redhat-release)
            else
                LINUX_DISTRO="unknown"
                LINUX_DISTRO_VERSION="unknown"
                LINUX_DISTRO_NAME="Linux (unknown distro)"
            fi
            # Detect if running on a VPS/VM
            if command -v systemd-detect-virt &>/dev/null; then
                local virt_type
                virt_type=$(systemd-detect-virt 2>/dev/null || echo "none")
                if [ "$virt_type" != "none" ] && [ -n "$virt_type" ]; then
                    IS_VPS=true
                fi
            fi
            ;;
        MINGW*|MSYS*|CYGWIN*)
            echo ""
            echo -e "${CYAN}${BOLD}  Clawkeeper${RESET}"
            echo ""
            echo -e "  ${YELLOW}Clawkeeper supports macOS and Linux.${RESET}"
            echo -e "  ${DIM}Windows: install WSL2, then run Clawkeeper from within WSL.${RESET}"
            echo ""
            exit 0
            ;;
        *)
            echo ""
            echo -e "${CYAN}${BOLD}  Clawkeeper${RESET}"
            echo ""
            echo -e "  ${YELLOW}Clawkeeper supports macOS and Linux.${RESET}"
            echo -e "  ${DIM}Detected platform: $kernel${RESET}"
            echo ""
            exit 0
            ;;
    esac

    # Detect architecture
    local machine
    machine=$(uname -m 2>/dev/null || echo "unknown")
    case "$machine" in
        arm64|aarch64) ARCH="arm64" ;;
        x86_64)        ARCH="x86_64" ;;
        *)             ARCH="$machine" ;;
    esac

    # Detect OS version
    if [ "$PLATFORM" = "macos" ]; then
        MACOS_VERSION=$(sw_vers -productVersion 2>/dev/null || echo "unknown")
    fi
}

# --- Usage ------------------------------------------------------------------

usage() {
    local prog
    prog=$(basename "$0")

    if [ "$HAS_GUM" = true ]; then
        gum format -t markdown -- "# $prog" \
            "" \
            "**Usage:** \`$prog [command] [options]\`" \
            "" \
            "## Commands" \
            "| Command | Description |" \
            "|---------|-------------|" \
            "| \`setup\` | Guided wizard: harden host + install OpenClaw (default) |" \
            "| \`deploy\` | Force full deployment even if already installed |" \
            "| \`scan\` | Read-only security audit (no changes, just a report) |" \
            "| \`uninstall\` | Securely remove OpenClaw and wipe sensitive data |" \
            "| \`agent\` | Manage the Clawkeeper SaaS agent |" \
            "| \`shield\` | Manage the Runtime Shield skill |" \
            "| \`help\` | Show this help |" \
            "" \
            "## Options" \
            "- \`--non-interactive\` — Don't prompt for fixes (same as scan)" \
            "- \`--report FILE\` — Save report to FILE" \
            "" \
            "## Examples" \
            "\`\`\`" \
            "$prog setup              # Interactive hardening wizard" \
            "$prog scan               # Read-only security audit" \
            "$prog scan --report r.txt # Audit with saved report" \
            "$prog uninstall          # Securely remove OpenClaw" \
            "$prog agent --install    # Install SaaS monitoring agent" \
            "\`\`\`"
    else
        echo "Usage: $prog [command] [options]"
        echo ""
        echo "Commands:"
        echo "  setup       Guided wizard: harden host + install OpenClaw (default)"
        echo "  deploy      Force full deployment even if already installed"
        echo "  scan        Read-only security audit (no changes, just a report)"
        echo "  uninstall   Securely remove OpenClaw and wipe sensitive data"
        echo "  agent       Manage the Clawkeeper SaaS agent"
        echo "  shield      Manage the Runtime Shield skill"
        echo "  help        Show this help"
        echo ""
        echo "Deployment modes (chosen interactively):"
        echo "  native      Run OpenClaw directly via npm — simpler"
        echo "  docker      Run OpenClaw in Docker — better isolation (recommended)"
        echo ""
        echo "Options:"
        echo "  --non-interactive    Don't prompt for fixes (same as scan)"
        echo "  --report FILE        Save report to FILE"
        echo ""
        echo "Examples:"
        echo "  $prog setup              # Interactive hardening wizard"
        echo "  $prog deploy             # Full install + deployment"
        echo "  $prog scan               # Read-only security audit"
        echo "  $prog scan --report r.txt # Audit with saved report"
        echo "  $prog uninstall          # Securely remove OpenClaw"
        echo "  $prog agent --install    # Install SaaS monitoring agent"
        echo "  $prog agent --status     # Check agent status"
        echo ""
    fi
}

# --- Main -------------------------------------------------------------------

main() {
    local command="${1:-start}"

    # Save all args after command for agent passthrough
    local agent_args=()
    shift 2>/dev/null || true
    agent_args=("$@")

    # Agent command handles its own args — skip main's parse loop
    if [ "$command" != "agent" ]; then
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --non-interactive)
                    INTERACTIVE=false
                    ;;
                --report)
                    shift
                    REPORT_FILE="${1:-}"
                    ;;
                --help|-h)
                    usage
                    exit 0
                    ;;
                *)
                    ;;
            esac
            shift 2>/dev/null || true
        done
    fi

    # Detect platform before anything else
    detect_platform
    ensure_gum
    init_gum_icons

    case "$command" in
        start)
            # Interactive menu — default when no command given
            print_banner
            echo ""
            if [ "$HAS_GUM" = true ]; then
                local choice
                choice=$(gum choose --header "  What would you like to do?" \
                    "Scan existing OpenClaw  — audit your current installation (read-only)" \
                    "Deploy OpenClaw securely — full setup wizard with hardened defaults" \
                    "Uninstall OpenClaw      — securely remove and wipe all data" </dev/tty)
                case "$choice" in
                    Deploy*)
                        command="setup"
                        SCAN_ONLY=false
                        INTERACTIVE=true
                        COMPACT_OUTPUT=true
                        print_expectations
                        select_deployment_mode
                        ;;
                    Uninstall*)
                        uninstall_openclaw
                        exit 0
                        ;;
                    *)
                        command="scan"
                        SCAN_ONLY=true
                        INTERACTIVE=false
                        COMPACT_OUTPUT=true
                        echo ""
                        dim_msg "  Read-only audit. No changes will be made."
                        select_deployment_mode
                        ;;
                esac
            else
                echo -e "  What would you like to do?"
                echo ""
                echo -e "  ${BOLD}1)${RESET} ${CYAN}Scan existing OpenClaw${RESET}  — audit your current installation (read-only)"
                echo -e "  ${BOLD}2)${RESET} ${CYAN}Deploy OpenClaw securely${RESET} — full setup wizard with hardened defaults"
                echo -e "  ${BOLD}3)${RESET} ${RED}Uninstall OpenClaw${RESET}      — securely remove and wipe all data"
                echo ""
                printf "  Choose [1/2/3]: "
                read -r choice </dev/tty
                case "$choice" in
                    2)
                        command="setup"
                        SCAN_ONLY=false
                        INTERACTIVE=true
                        COMPACT_OUTPUT=true
                        print_expectations
                        select_deployment_mode
                        ;;
                    3)
                        uninstall_openclaw
                        exit 0
                        ;;
                    *)
                        command="scan"
                        SCAN_ONLY=true
                        INTERACTIVE=false
                        COMPACT_OUTPUT=true
                        echo ""
                        echo -e "  ${DIM}Read-only audit. No changes will be made.${RESET}"
                        select_deployment_mode
                        ;;
                esac
            fi
            ;;
        setup|deploy)
            SCAN_ONLY=false
            INTERACTIVE=true
            COMPACT_OUTPUT=true
            print_banner
            print_expectations
            select_deployment_mode
            ;;
        scan)
            SCAN_ONLY=true
            INTERACTIVE=false
            COMPACT_OUTPUT=true
            print_scan_banner
            select_deployment_mode
            dim_msg "  Read-only audit. No changes will be made."
            ;;
        uninstall|remove)
            uninstall_openclaw
            exit 0
            ;;
        agent)
            agent_main "${agent_args[@]+"${agent_args[@]}"}"
            exit 0
            ;;
        shield|--shield)
            shield_main "${agent_args[@]+"${agent_args[@]}"}"
            exit 0
            ;;
        help|--help|-h)
            usage
            exit 0
            ;;
        *)
            echo "Unknown command: $command"
            usage
            exit 1
            ;;
    esac

    # Pre-cache sudo credentials so remediations don't surprise the user
    if [ "$SCAN_ONLY" != true ]; then
        ensure_sudo
    fi

    # ── Phase 1 of 5: Host Hardening ──
    reset_phase_counters
    if [ "$PLATFORM" = "macos" ]; then
        phase_header "═══ Phase 1 of 5: macOS Host Hardening ═══"
        run_check "siri"
        run_check "location_services"
        run_check "bluetooth"
        run_check "airdrop"
        run_check "analytics"
        run_check "spotlight"
        run_check "firewall"
        run_check "filevault"
        run_check "admin_user"
        run_check "icloud"
        run_check "automatic_login"
    elif [ "$PLATFORM" = "linux" ]; then
        phase_header "═══ Phase 1 of 5: Linux Host Hardening ═══"
        run_check "linux_user_account"
        run_check "linux_ssh_hardening"
        run_check "linux_firewall"
        run_check "linux_auto_updates"
        run_check "linux_fail2ban"
        run_check "linux_unnecessary_services"
        run_check "linux_disk_encryption"
    fi
    _compact_flush
    print_phase_summary
    if [ "$COMPACT_OUTPUT" != true ]; then
        if [ "$HAS_GUM" = true ]; then
            echo "  $(gum style --foreground "$GUM_DIM" "These settings can drift. Re-run scans regularly or monitor at") $(gum style --foreground "$GUM_CYAN" "clawkeeper.dev")"
        else
            echo -e "  ${DIM}These settings can drift. Re-run scans regularly or monitor at ${CYAN}clawkeeper.dev${RESET}"
        fi
    fi

    # ── Phase 2 of 5: Network ──
    reset_phase_counters
    phase_header "═══ Phase 2 of 5: Network ═══"

    if [ "$PLATFORM" = "macos" ]; then
        run_check "network_isolation"
        run_check "screen_sharing"
        run_check "remote_login"
        run_check "mdns_bonjour"
    elif [ "$PLATFORM" = "linux" ]; then
        run_check "linux_network"
        run_check "linux_open_ports"
    fi
    _compact_flush
    print_phase_summary

    # ── Phase 3 of 5: Prerequisites ──
    reset_phase_counters
    detect_install_capability
    if [ "$PLATFORM" = "macos" ]; then
        print_install_capability_warning
        if [ "$DEPLOY_MODE" = "native" ]; then
            phase_header "═══ Phase 3 of 5: Prerequisites (Homebrew + Node.js) ═══"
            run_check "homebrew"
            if ! command -v brew &>/dev/null; then
                # Node.js install depends on Homebrew — skip with clear guidance
                step_header "Node.js"
                info "Skipped — Homebrew is required to install Node.js."
                fail "Node.js 22+ not available (Homebrew required)" "Node.js"
            else
                run_check "node"
            fi
        else
            phase_header "═══ Phase 3 of 5: Prerequisites (Docker) ═══"
            if command -v docker &>/dev/null; then
                run_check "docker_installed"
                harden_docker_desktop
            else
                # Need Homebrew to install Docker Desktop
                run_check "homebrew"
                if ! command -v brew &>/dev/null; then
                    step_header "Docker Desktop"
                    info "Skipped — Homebrew is required to install Docker Desktop."
                    info "Alternatively, download Docker Desktop directly from https://docker.com/products/docker-desktop"
                    fail "Docker not available (install Homebrew or download Docker Desktop directly)" "Docker"
                else
                    run_check "docker_installed"
                fi
            fi
        fi
    elif [ "$PLATFORM" = "linux" ]; then
        print_install_capability_warning
        if [ "$DEPLOY_MODE" = "native" ]; then
            phase_header "═══ Phase 3 of 5: Prerequisites (Node.js) ═══"
            run_check "linux_essentials"
            run_check "linux_node"
        else
            phase_header "═══ Phase 3 of 5: Prerequisites (Docker) ═══"
            # Docker mode on Linux: check Docker first, Node.js not needed
            if command -v docker &>/dev/null; then
                run_check "linux_docker"
            else
                run_check "linux_essentials"
                run_check "linux_docker"
            fi
        fi
    fi
    _compact_flush
    print_phase_summary

    # If prerequisites failed because user can't install software, show clear next steps
    if [ "$CAN_INSTALL_SOFTWARE" = false ] && [ "$FAIL" -gt "$PHASE_FAIL" ]; then
        echo ""
        highlight_msg "  What to do next:"
        if [ "$PLATFORM" = "macos" ]; then
            dim_msg "  1. Log into an admin account on this Mac"
            if [ "$DEPLOY_MODE" = "native" ]; then
                dim_msg "  2. Install Homebrew and Node.js (see commands above)"
            else
                dim_msg "  2. Install Docker Desktop (see options above)"
            fi
            dim_msg "  3. Log back in as '$(whoami)' and re-run this script"
        else
            dim_msg "  1. Ask an admin to install the required packages"
            dim_msg "  2. Re-run this script"
        fi
    fi

    # ── Phase 4 of 5: OpenClaw Installation & Deployment ──
    reset_phase_counters
    detect_openclaw_installed

    if [ "$command" = "scan" ]; then
        # Scan mode: report installation status only
        phase_header "═══ Phase 4 of 5: OpenClaw Installation Status ═══"
        step_header "OpenClaw Detection"
        if [ "$OPENCLAW_INSTALLED" = true ]; then
            local install_label="native (npm)"
            [ "$OPENCLAW_INSTALL_TYPE" = "docker" ] && install_label="Docker"
            pass "OpenClaw is installed ($install_label — detected via $OPENCLAW_DETECT_METHOD)" "OpenClaw Detection"
        else
            fail "OpenClaw is not installed" "OpenClaw Detection"
            info "Run '$(basename "$0") setup' to install OpenClaw with hardened defaults."
        fi

    elif [ "$command" = "setup" ]; then
        # Setup mode: detect and offer to install if missing
        phase_header "═══ Phase 4 of 5: OpenClaw Installation ═══"

        if [ "$OPENCLAW_INSTALLED" = true ]; then
            step_header "OpenClaw Detection"
            local install_label="native (npm)"
            [ "$OPENCLAW_INSTALL_TYPE" = "docker" ] && install_label="Docker"
            pass "OpenClaw is already installed ($install_label — detected via $OPENCLAW_DETECT_METHOD)" "OpenClaw Detection"
        else
            step_header "OpenClaw Detection"
            warn "OpenClaw is not installed on this system"
            info "The setup wizard can install OpenClaw with secure, hardened defaults."
            if [ "$DEPLOY_MODE" = "native" ]; then
                info "Selected mode: Native (npm) — runs directly on this Mac"
            else
                info "Selected mode: Docker — runs in an isolated container (recommended)"
            fi
            echo ""

            if ask_yn "Install OpenClaw now?"; then
                if [ "$DEPLOY_MODE" = "native" ]; then
                    echo ""
                    accent_bold_msg "  Installing OpenClaw (Native/npm)..."
                    if command -v node &>/dev/null; then
                        setup_native_openclaw_directories
                        install_openclaw_global
                        setup_native_env_file
                        setup_openclaw_config
                        setup_native_launchd
                    else
                        echo ""
                        warn "Node.js is not available — cannot install OpenClaw"
                        info "Re-run this wizard after installing Node.js (Phase 3)."
                        fail "Skipped installation (Node.js not available)" "Deploy"
                    fi
                else
                    echo ""
                    accent_bold_msg "  Installing OpenClaw (Docker)..."
                    if command -v docker &>/dev/null && docker info &>/dev/null; then
                        setup_openclaw_directories
                        setup_env_file
                        setup_docker_compose
                        setup_openclaw_config
                        deploy_openclaw_docker
                    else
                        echo ""
                        warn "Docker is not available — cannot install OpenClaw"
                        info "Re-run this wizard after installing Docker Desktop (Phase 3)."
                        fail "Skipped installation (Docker not available)" "Deploy"
                    fi
                fi
            else
                skipped "OpenClaw installation deferred" "OpenClaw Installation"
                info "Run '$(basename "$0") deploy' when you're ready to install."
            fi
        fi

    elif [ "$command" = "deploy" ]; then
        # Deploy mode: always run full deployment
        if [ "$DEPLOY_MODE" = "native" ]; then
            phase_header "═══ Phase 4 of 5: OpenClaw Native Deployment ═══"

            if command -v node &>/dev/null; then
                setup_native_openclaw_directories
                install_openclaw_global
                setup_native_env_file
                setup_openclaw_config
                setup_native_launchd
            else
                echo ""
                warn "Node.js is not available — cannot deploy OpenClaw"
                info "Install Node.js first, then re-run: $(basename "$0") deploy"
                fail "Skipped deployment (Node.js not available)" "Deploy"
            fi
        else
            phase_header "═══ Phase 4 of 5: OpenClaw Docker Deployment ═══"

            if command -v docker &>/dev/null && docker info &>/dev/null; then
                setup_openclaw_directories
                setup_env_file
                setup_docker_compose
                setup_openclaw_config
                deploy_openclaw_docker
            else
                echo ""
                warn "Docker is not available — cannot deploy OpenClaw"
                info "Install and start Docker Desktop first, then re-run: $(basename "$0") deploy"
                fail "Skipped deployment (Docker not available)" "Deploy"
            fi
        fi
    fi

    _compact_flush
    print_phase_summary

    # Re-detect after setup/deploy in case OpenClaw was just installed
    if [ "$OPENCLAW_INSTALLED" = false ] && [ "$command" != "scan" ]; then
        detect_openclaw_installed
    fi

    # ── Phase 5 of 5: Security Audit (all modes) ──
    reset_phase_counters
    phase_header "═══ Phase 5 of 5: Security Audit ═══"

    if [ "$OPENCLAW_INSTALLED" = true ]; then
        run_check "openclaw_running"
        run_check "cve_audit"

        if [ "$DEPLOY_MODE" = "native" ]; then
            run_check "openclaw_config"
            run_check "openclaw_hardening"
            run_check "env_file"
            run_check "credential_exposure"
            run_check "session_commands"
            run_check "skills_security"
            run_check "soul_security"
        else
            run_check "container_security"
            run_check "openclaw_config"
            run_check "openclaw_hardening"
            run_check "env_file"
            run_check "credential_exposure"
            run_check "session_commands"
            run_check "skills_security"
            run_check "soul_security"
        fi
    else
        info "OpenClaw is not installed — skipping security audit."
        info "Run '$(basename "$0") setup' to install OpenClaw, then re-run scan."
    fi
    _compact_flush
    print_phase_summary

    # Final report
    print_report
    save_report

    # Post-setup: prompt to connect to dashboard
    if [ "$command" = "setup" ] || [ "$command" = "deploy" ]; then
        local has_api_key=false
        if [ -f "$AGENT_CONFIG_FILE" ]; then
            local stored_key
            stored_key=$(grep '^CLAWKEEPER_API_KEY=' "$AGENT_CONFIG_FILE" 2>/dev/null | head -1 | sed 's/^CLAWKEEPER_API_KEY="//' | sed 's/"$//')
            if [ -n "$stored_key" ] && echo "$stored_key" | grep -qE '^ck_live_.{12,}'; then
                has_api_key=true
            fi
        fi

        if [ "$has_api_key" != true ] && [ "$OPENCLAW_INSTALLED" = true ]; then
            echo ""
            echo -e "  ${CYAN}${BOLD}━━━ Connect to Your Dashboard ━━━${RESET}"
            echo ""
            echo -e "  Your OpenClaw deployment is secured. Track your security"
            echo -e "  grade over time with a free Clawkeeper dashboard."
            echo ""
            echo -e "  ${BOLD}1.${RESET} Sign up at ${CYAN}clawkeeper.dev/signup${RESET}"
            echo -e "  ${BOLD}2.${RESET} Add your host and copy the API key"
            echo -e "  ${BOLD}3.${RESET} Run: ${CYAN}clawkeeper.sh agent --install${RESET}"
            echo ""
        fi
    fi
}

# Run
main "$@"
