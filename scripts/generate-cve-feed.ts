/**
 * Prebuild script: fetches CVE data from NVD 2.0 API for OpenClaw's tech stack.
 * Outputs web/src/data/cve-feed.json as seed data for the security feed page.
 *
 * Run: npx tsx ../scripts/generate-cve-feed.ts (from web/)
 */

import { writeFileSync, mkdirSync } from "fs";
import { join, dirname } from "path";

const ROOT = join(dirname(new URL(import.meta.url).pathname), "..");
const OUTPUT = join(ROOT, "web", "src", "data", "cve-feed.json");

const NVD_API = "https://services.nvd.nist.gov/rest/json/cves/2.0";
const KEYWORDS = ["node.js", "docker engine", "websocket"];
const MAX_ITEMS = 50;
const REQUEST_DELAY_MS = 7000; // NVD allows 5 req/30s without API key

interface NVDResponse {
  totalResults: number;
  vulnerabilities: Array<{
    cve: {
      id: string;
      published: string;
      descriptions: Array<{ lang: string; value: string }>;
      metrics?: {
        cvssMetricV31?: Array<{
          cvssData: { baseScore: number; baseSeverity: string };
        }>;
        cvssMetricV30?: Array<{
          cvssData: { baseScore: number; baseSeverity: string };
        }>;
      };
      weaknesses?: Array<{
        description: Array<{ lang: string; value: string }>;
      }>;
    };
  }>;
}

interface CVEFeedItem {
  id: string;
  description: string;
  cvssScore: number;
  severity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";
  cweIds: string[];
  publishedDate: string;
  nvdUrl: string;
}

interface CVEFeed {
  generatedAt: string;
  totalResults: number;
  items: CVEFeedItem[];
}

function getSeverityFromScore(
  score: number
): "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" {
  if (score >= 9.0) return "CRITICAL";
  if (score >= 7.0) return "HIGH";
  if (score >= 4.0) return "MEDIUM";
  return "LOW";
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function fetchKeyword(keyword: string): Promise<CVEFeedItem[]> {
  const now = new Date();
  const ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);

  const params = new URLSearchParams({
    keywordSearch: keyword,
    pubStartDate: ninetyDaysAgo.toISOString(),
    pubEndDate: now.toISOString(),
    cvssV3Severity: "MEDIUM",
  });

  // Also include HIGH and CRITICAL — NVD filters by minimum severity
  // Actually NVD cvssV3Severity only takes one value. We'll filter client-side instead.
  params.delete("cvssV3Severity");

  const url = `${NVD_API}?${params}`;
  console.log(`  Fetching: ${keyword}...`);

  const res = await fetch(url, {
    headers: { "User-Agent": "Clawkeeper-CVE-Feed/1.0" },
  });

  if (!res.ok) {
    console.warn(`  Warning: NVD returned ${res.status} for "${keyword}"`);
    return [];
  }

  const data: NVDResponse = await res.json();
  console.log(`  Found ${data.totalResults} results for "${keyword}"`);

  return data.vulnerabilities
    .map((v) => {
      const cve = v.cve;
      const desc =
        cve.descriptions.find((d) => d.lang === "en")?.value ?? "";

      const metrics =
        cve.metrics?.cvssMetricV31?.[0] ?? cve.metrics?.cvssMetricV30?.[0];
      const cvssScore = metrics?.cvssData.baseScore ?? 0;

      const cweIds: string[] = [];
      for (const w of cve.weaknesses ?? []) {
        for (const d of w.description) {
          if (d.value.startsWith("CWE-")) {
            cweIds.push(d.value);
          }
        }
      }

      return {
        id: cve.id,
        description: desc,
        cvssScore,
        severity: getSeverityFromScore(cvssScore),
        cweIds: [...new Set(cweIds)],
        publishedDate: cve.published,
        nvdUrl: `https://nvd.nist.gov/vuln/detail/${cve.id}`,
      };
    })
    .filter((item) => item.cvssScore >= 4.0);
}

async function main() {
  console.log("Generating CVE feed...");

  const allItems: CVEFeedItem[] = [];

  for (let i = 0; i < KEYWORDS.length; i++) {
    if (i > 0) {
      console.log(`  Waiting ${REQUEST_DELAY_MS / 1000}s (NVD rate limit)...`);
      await sleep(REQUEST_DELAY_MS);
    }
    const items = await fetchKeyword(KEYWORDS[i]);
    allItems.push(...items);
  }

  // Deduplicate by CVE ID
  const seen = new Set<string>();
  const deduped = allItems.filter((item) => {
    if (seen.has(item.id)) return false;
    seen.add(item.id);
    return true;
  });

  // Sort by published date descending, cap at MAX_ITEMS
  deduped.sort(
    (a, b) =>
      new Date(b.publishedDate).getTime() -
      new Date(a.publishedDate).getTime()
  );
  const items = deduped.slice(0, MAX_ITEMS);

  const feed: CVEFeed = {
    generatedAt: new Date().toISOString(),
    totalResults: items.length,
    items,
  };

  mkdirSync(dirname(OUTPUT), { recursive: true });
  writeFileSync(OUTPUT, JSON.stringify(feed, null, 2) + "\n");
  console.log(`CVE feed generated: ${OUTPUT} (${items.length} items)`);
}

main().catch((err) => {
  console.error("CVE feed generation failed:", err);
  // Non-fatal — write empty feed so build doesn't break
  const emptyFeed: CVEFeed = {
    generatedAt: new Date().toISOString(),
    totalResults: 0,
    items: [],
  };
  mkdirSync(dirname(OUTPUT), { recursive: true });
  writeFileSync(OUTPUT, JSON.stringify(emptyFeed, null, 2) + "\n");
  console.log("Wrote empty CVE feed as fallback.");
});
