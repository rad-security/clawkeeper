#!/bin/bash
# ============================================================================
# CLAW Keeper Setup Wizard
# Harden your host. Deploy OpenClaw securely.
#
# By RAD Security — https://rad.security
#
# This file is auto-generated by scripts/bundle.sh — do not edit directly.
# ============================================================================

set -uo pipefail

# === Shared Helpers ======================================================

# ============================================================================
# Clawkeeper — Shared Helpers
# JSON output functions for check scripts + parsing for the orchestrator
# ============================================================================

# --- JSON Output Helpers (used by check.sh / remediate.sh scripts) ----------
# These emit structured JSON lines to stdout. Both the CLI orchestrator and
# the Tauri backend parse this output.

# Escape a string for safe JSON embedding
_json_escape() {
    local s="$1"
    s="${s//\\/\\\\}"
    s="${s//\"/\\\"}"
    s="${s//$'\t'/\\t}"
    s="${s//$'\n'/\\n}"
    printf '%s' "$s"
}

emit_pass() {
    local detail="$1"
    local check_name="${2:-}"
    printf '{"status":"PASS","check_name":"%s","detail":"%s"}\n' \
        "$(_json_escape "$check_name")" "$(_json_escape "$detail")"
}

emit_fail() {
    local detail="$1"
    local check_name="${2:-}"
    printf '{"status":"FAIL","check_name":"%s","detail":"%s"}\n' \
        "$(_json_escape "$check_name")" "$(_json_escape "$detail")"
}

emit_info() {
    local message="$1"
    printf '{"type":"info","message":"%s"}\n' "$(_json_escape "$message")"
}

emit_warn() {
    local message="$1"
    printf '{"type":"warn","message":"%s"}\n' "$(_json_escape "$message")"
}

emit_skipped() {
    local detail="$1"
    local check_name="${2:-}"
    printf '{"status":"SKIPPED","check_name":"%s","detail":"%s"}\n' \
        "$(_json_escape "$check_name")" "$(_json_escape "$detail")"
}

# Emit a remediation prompt. The orchestrator will ask the user and call
# remediate.sh if accepted. fail_detail is used when the user declines in
# scan mode; skip_detail when they decline in setup mode.
emit_prompt() {
    local message="$1"
    local remediation_id="$2"
    local fail_detail="${3:-}"
    local skip_detail="${4:-}"
    printf '{"action":"prompt","message":"%s","remediation_id":"%s","fail_detail":"%s","skip_detail":"%s"}\n' \
        "$(_json_escape "$message")" \
        "$(_json_escape "$remediation_id")" \
        "$(_json_escape "$fail_detail")" \
        "$(_json_escape "$skip_detail")"
}

# --- JSON Parsing Helper (used by the orchestrator) -------------------------
# Extract a value from a simple flat JSON object. No jq dependency.
# Usage: _jval '{"key":"value"}' "key"  → prints "value"
_jval() {
    local json="$1" key="$2"
    local pattern="\"${key}\":\""
    local rest="${json#*$pattern}"
    if [ "$rest" = "$json" ]; then
        echo ""
        return
    fi
    # Handle escaped quotes in value
    local value=""
    local i=0
    local len=${#rest}
    local prev=""
    while [ $i -lt "$len" ]; do
        local ch="${rest:$i:1}"
        if [ "$ch" = '"' ] && [ "$prev" != '\' ]; then
            break
        fi
        value="${value}${ch}"
        prev="$ch"
        i=$((i + 1))
    done
    # Unescape
    value="${value//\\n/$'\n'}"
    value="${value//\\t/$'\t'}"
    value="${value//\\\"/\"}"
    value="${value//\\\\/\\}"
    printf '%s' "$value"
}

# === Extracted Checks ====================================================

# --- Check: admin_user ---

__meta_admin_user() {
    case "$1" in
        name) echo "User Account" ;;
        id)   echo "admin_user" ;;
    esac
}

__check_admin_user() {
# ============================================================================
# Clawkeeper Check: User Account
# Detects whether the current user is an admin, and whether a dedicated
# 'openclaw' standard user exists.
# Info-only — creating a user requires interactive password input which
# cannot be handled via the JSON protocol.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "OpenClaw should run under a standard (non-admin) user to limit blast radius."

current_user=$(whoami)

# Check if current user is admin
if groups "$current_user" 2>/dev/null | grep -qw "admin"; then
    emit_warn "You are running as admin user: $current_user"
    emit_info "A compromised agent under an admin account has much broader access."

    # Check if an 'openclaw' user already exists
    if id "openclaw" &>/dev/null; then
        emit_info "A dedicated 'openclaw' user already exists."
        emit_info "Log into that account for OpenClaw usage."
        emit_fail "Currently running as admin (switch to 'openclaw' user)" "User Account"
    else
        emit_info "To create a dedicated 'openclaw' standard user, run the following manually:"
        emit_info "  sudo dscl . -create /Users/openclaw"
        emit_info "  sudo dscl . -create /Users/openclaw UserShell /bin/zsh"
        emit_info "  sudo dscl . -create /Users/openclaw RealName \"OpenClaw\""
        emit_info "  sudo dscl . -create /Users/openclaw UniqueID <NEXT_UID>"
        emit_info "  sudo dscl . -create /Users/openclaw PrimaryGroupID 20"
        emit_info "  sudo dscl . -create /Users/openclaw NFSHomeDirectory /Users/openclaw"
        emit_info "  sudo dscl . -passwd /Users/openclaw <PASSWORD>"
        emit_info "  sudo createhomedir -c -u openclaw"
        emit_info "Do NOT add the user to the admin group — it should be a standard account."
        emit_info "Then log into that account for all OpenClaw operations."
        emit_fail "Running as admin user (create a dedicated 'openclaw' standard user)" "User Account"
    fi
else
    emit_pass "Running as standard (non-admin) user: $current_user" "User Account"
fi
}

# --- Check: airdrop ---

__meta_airdrop() {
    case "$1" in
        name) echo "AirDrop & Handoff" ;;
        id)   echo "airdrop" ;;
    esac
}

__check_airdrop() {
# ============================================================================
# Clawkeeper Check: AirDrop & Handoff
# Detects whether AirDrop and Handoff are enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Both create network-discoverable services. AirDrop makes this machine visible nearby."

airdrop_issue=false
handoff_issue=false

# AirDrop
airdrop_status=$(defaults read com.apple.NetworkBrowser DisableAirDrop 2>/dev/null || echo "0")
if [ "$airdrop_status" != "1" ]; then
    airdrop_issue=true
fi

# Handoff
handoff_status=$(defaults read ~/Library/Preferences/ByHost/com.apple.coreservices.useractivityd ActivityAdvertisingAllowed 2>/dev/null || echo "1")
if [ "$handoff_status" != "0" ]; then
    handoff_issue=true
fi

if [ "$airdrop_issue" = false ] && [ "$handoff_issue" = false ]; then
    emit_pass "AirDrop and Handoff are disabled" "AirDrop & Handoff"
return 0
fi

[ "$airdrop_issue" = true ] && emit_warn "AirDrop is not disabled"
[ "$handoff_issue" = true ] && emit_warn "Handoff is not disabled"

emit_prompt "Disable AirDrop and Handoff?" "disable_airdrop_handoff" \
    "AirDrop/Handoff not fully disabled" \
    "AirDrop/Handoff left as-is"
}

__remediate_airdrop() {
# ============================================================================
# Clawkeeper Remediation: AirDrop & Handoff
# Disables AirDrop and Handoff on macOS (no sudo required).
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_airdrop_handoff)
        defaults write com.apple.NetworkBrowser DisableAirDrop -bool true 2>/dev/null || true
        defaults write ~/Library/Preferences/ByHost/com.apple.coreservices.useractivityd ActivityAdvertisingAllowed -bool false 2>/dev/null || true
        defaults write ~/Library/Preferences/ByHost/com.apple.coreservices.useractivityd ActivityReceivingAllowed -bool false 2>/dev/null || true
        emit_pass "AirDrop and Handoff disabled" "AirDrop & Handoff"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "AirDrop & Handoff"
        ;;
esac
}

# --- Check: analytics ---

__meta_analytics() {
    case "$1" in
        name) echo "Analytics & Telemetry" ;;
        id)   echo "analytics" ;;
    esac
}

__check_analytics() {
# ============================================================================
# Clawkeeper Check: Analytics & Telemetry
# Detects whether analytics and telemetry settings are enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Diagnostic data from this machine shouldn't go to Apple or third parties."

analytics_issue=false

# Check crash reporter auto-submit
auto_submit=$(defaults read "/Library/Application Support/CrashReporter/DiagnosticMessagesHistory.plist" AutoSubmit 2>/dev/null || echo "unknown")
if [ "$auto_submit" = "1" ] || [ "$auto_submit" = "unknown" ]; then
    analytics_issue=true
fi

# Check Siri analytics
siri_analytics=$(defaults read com.apple.assistant.support "Siri Data Sharing Opt-In Status" 2>/dev/null || echo "unknown")
if [ "$siri_analytics" = "2" ]; then
    analytics_issue=true
fi

if [ "$analytics_issue" = false ]; then
    emit_pass "Analytics and telemetry appear disabled" "Analytics & Telemetry"
return 0
fi

emit_warn "Some analytics/telemetry settings may be enabled"
emit_prompt "Disable all analytics and telemetry?" "disable_analytics" \
    "Analytics/telemetry may be enabled" \
    "Analytics left as-is"
}

__remediate_analytics() {
# ============================================================================
# Clawkeeper Remediation: Analytics & Telemetry
# Disables analytics and telemetry on macOS (partially requires sudo).
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_analytics)
        # Disable crash reporter auto-submit (requires sudo)
        sudo defaults write "/Library/Application Support/CrashReporter/DiagnosticMessagesHistory.plist" AutoSubmit -bool false 2>/dev/null || true
        # Disable Siri data sharing
        defaults write com.apple.assistant.support "Siri Data Sharing Opt-In Status" -int 0 2>/dev/null || true
        # Disable app analytics
        defaults write com.apple.appanalyticsd policy -int 0 2>/dev/null || true
        emit_pass "Analytics and telemetry disabled" "Analytics & Telemetry"
        emit_info "Verify in System Settings → Privacy & Security → Analytics & Improvements"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Analytics & Telemetry"
        ;;
esac
}

# --- Check: automatic_login ---

__meta_automatic_login() {
    case "$1" in
        name) echo "Automatic Login" ;;
        id)   echo "automatic_login" ;;
    esac
}

__check_automatic_login() {
# ============================================================================
# Clawkeeper Check: Automatic Login
# Detects whether automatic login is enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Automatic login bypasses the login screen — anyone with physical access gets in."

auto_login=$(defaults read /Library/Preferences/com.apple.loginwindow autoLoginUser 2>/dev/null || echo "")

if [ -z "$auto_login" ]; then
    emit_pass "Automatic login is disabled" "Automatic Login"
return 0
fi

emit_warn "Automatic login is enabled for user: $auto_login"
emit_prompt "Disable automatic login?" "disable_automatic_login" \
    "Automatic login is enabled" \
    "Automatic login left enabled"
}

__remediate_automatic_login() {
# ============================================================================
# Clawkeeper Remediation: Automatic Login
# Disables automatic login by removing the autoLoginUser preference.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_automatic_login)
        sudo defaults delete /Library/Preferences/com.apple.loginwindow autoLoginUser 2>/dev/null || true
        emit_pass "Automatic login disabled" "Automatic Login"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Automatic Login"
        ;;
esac
}

# --- Check: bluetooth ---

__meta_bluetooth() {
    case "$1" in
        name) echo "Bluetooth" ;;
        id)   echo "bluetooth" ;;
    esac
}

__check_bluetooth() {
# ============================================================================
# Clawkeeper Check: Bluetooth
# Detects whether Bluetooth is enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Unnecessary radio interface. Exposes the machine to proximity-based attacks."

bt_on=false

# Check via defaults
bt_status=$(defaults read /Library/Preferences/com.apple.Bluetooth ControllerPowerState 2>/dev/null || echo "unknown")

if [ "$bt_status" = "1" ]; then
    bt_on=true
elif [ "$bt_status" = "0" ]; then
    bt_on=false
else
    # Try system_profiler as fallback
    if system_profiler SPBluetoothDataType 2>/dev/null | grep -q "State: On"; then
        bt_on=true
    fi
fi

if [ "$bt_on" = false ]; then
    emit_pass "Bluetooth is off" "Bluetooth"
return 0
fi

emit_warn "Bluetooth is ON"
emit_info "If you're using a wireless keyboard/mouse, you may need Bluetooth."
emit_prompt "Disable Bluetooth? (skip if you need wireless peripherals)" "disable_bluetooth" \
    "Bluetooth is on" \
    "Bluetooth left on (wireless peripherals)"
}

__remediate_bluetooth() {
# ============================================================================
# Clawkeeper Remediation: Bluetooth
# Disables Bluetooth on macOS (requires sudo).
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_bluetooth)
        sudo defaults write /Library/Preferences/com.apple.Bluetooth ControllerPowerState -int 0 2>/dev/null || true
        emit_pass "Bluetooth disabled" "Bluetooth"
        emit_info "Note: If using wireless peripherals, re-enable in System Settings → Bluetooth"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Bluetooth"
        ;;
esac
}

# --- Check: container_security ---

__meta_container_security() {
    case "$1" in
        name) echo "Container Security Audit" ;;
        id)   echo "container_security" ;;
    esac
}

__check_container_security() {
# ============================================================================
# Clawkeeper Check: Container Security Audit
# Audits a running OpenClaw Docker container for: user (non-root),
# capabilities (cap_drop ALL), privileged mode, no-new-privileges,
# read-only root filesystem, port binding, resource limits (memory/CPU),
# network mode, Bonjour env var, and volume mounts.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

# ---------- Check if OpenClaw container is running ----------
if ! command -v docker &>/dev/null; then
    emit_info "Docker not installed — skipping container audit"
return 0
fi

if ! docker ps --format '{{.Names}}' 2>/dev/null | grep -q "^openclaw$"; then
    emit_info "OpenClaw container is not running — skipping container audit"
return 0
fi

emit_info "Auditing running container:"

# ---------- Check 1: Running as non-root ----------
container_user=$(docker exec openclaw id -u 2>/dev/null || echo "unknown")
if [ "$container_user" = "0" ]; then
    emit_fail "Container is running as ROOT (uid 0)" "Container User"
elif [ "$container_user" = "unknown" ]; then
    emit_warn "Could not determine container user"
else
    emit_pass "Container running as non-root (uid: $container_user)" "Container User"
fi

# ---------- Check 2: Capabilities ----------
cap_info=$(docker inspect --format='{{.HostConfig.CapDrop}}' openclaw 2>/dev/null || echo "")
if echo "$cap_info" | grep -qi "all"; then
    emit_pass "All capabilities dropped (cap_drop: ALL)" "Capabilities"
else
    emit_fail "Capabilities not fully dropped — add cap_drop: ALL" "Capabilities"
fi

cap_add=$(docker inspect --format='{{.HostConfig.CapAdd}}' openclaw 2>/dev/null || echo "")
if echo "$cap_add" | grep -qi "NET_BIND_SERVICE" && [ "$(echo "$cap_add" | tr -cd ',' | wc -c)" -le 0 ]; then
    emit_pass "Only NET_BIND_SERVICE capability added back" "Cap Add"
elif [ -z "$cap_add" ] || echo "$cap_add" | grep -q "\[\]"; then
    emit_pass "No extra capabilities added" "Cap Add"
else
    emit_warn "Additional capabilities added: $cap_add"
    emit_fail "Minimize added capabilities — only NET_BIND_SERVICE should be needed" "Cap Add"
fi

# ---------- Check 3: Privileged mode ----------
privileged=$(docker inspect --format='{{.HostConfig.Privileged}}' openclaw 2>/dev/null || echo "unknown")
if [ "$privileged" = "false" ]; then
    emit_pass "Container is NOT privileged" "Privileged Mode"
elif [ "$privileged" = "true" ]; then
    emit_fail "CRITICAL: Container is running in PRIVILEGED mode" "Privileged Mode"
    emit_info "Remove --privileged immediately — this gives full host access"
fi

# ---------- Check 4: no-new-privileges ----------
no_new_priv=$(docker inspect --format='{{index .HostConfig.SecurityOpt}}' openclaw 2>/dev/null || echo "")
if echo "$no_new_priv" | grep -qi "no-new-privileges"; then
    emit_pass "no-new-privileges is set" "No New Privileges"
else
    emit_fail "no-new-privileges not set — add security_opt: no-new-privileges:true" "No New Privileges"
fi

# ---------- Check 5: Read-only root filesystem ----------
readonly_fs=$(docker inspect --format='{{.HostConfig.ReadonlyRootfs}}' openclaw 2>/dev/null || echo "unknown")
if [ "$readonly_fs" = "true" ]; then
    emit_pass "Root filesystem is read-only" "Read-Only FS"
else
    emit_fail "Root filesystem is writable — add read_only: true to compose" "Read-Only FS"
fi

# ---------- Check 6: Port binding ----------
port_bindings=$(docker inspect --format='{{range $p, $conf := .NetworkSettings.Ports}}{{$p}}={{(index $conf 0).HostIp}}:{{(index $conf 0).HostPort}} {{end}}' openclaw 2>/dev/null || echo "")

port_ok=true
if echo "$port_bindings" | grep -q "0.0.0.0"; then
    emit_fail "CRITICAL: Ports bound to 0.0.0.0 (all interfaces)" "Port Binding"
    emit_info "Change to 127.0.0.1:<port>:<port> in docker-compose.yml"
    port_ok=false
fi
if [ "$port_ok" = true ] && [ -n "$port_bindings" ]; then
    emit_pass "All ports bound to localhost only" "Port Binding"
fi

# ---------- Check 7: Resource limits ----------
mem_limit=$(docker inspect --format='{{.HostConfig.Memory}}' openclaw 2>/dev/null || echo "0")
if [ "$mem_limit" -gt 0 ] 2>/dev/null; then
    mem_mb=$((mem_limit / 1024 / 1024))
    emit_pass "Memory limit set (${mem_mb}MB)" "Memory Limit"
else
    emit_fail "No memory limit set — container can consume all host memory" "Memory Limit"
fi

cpu_limit=$(docker inspect --format='{{.HostConfig.NanoCpus}}' openclaw 2>/dev/null || echo "0")
if [ "$cpu_limit" -gt 0 ] 2>/dev/null; then
    cpu_cores=$((cpu_limit / 1000000000))
    emit_pass "CPU limit set (~${cpu_cores} cores)" "CPU Limit"
else
    emit_fail "No CPU limit set — runaway agent can consume all CPUs" "CPU Limit"
fi

# ---------- Check 8: Network mode ----------
net_mode=$(docker inspect --format='{{.HostConfig.NetworkMode}}' openclaw 2>/dev/null || echo "unknown")
if [ "$net_mode" = "host" ]; then
    emit_fail "CRITICAL: Container using host network mode — no network isolation" "Network Mode"
else
    emit_pass "Container using isolated network ($net_mode)" "Network Mode"
fi

# ---------- Check 9: Bonjour environment variable ----------
bonjour_disabled=$(docker exec openclaw printenv OPENCLAW_DISABLE_BONJOUR 2>/dev/null || echo "")
if [ "$bonjour_disabled" = "1" ]; then
    emit_pass "OPENCLAW_DISABLE_BONJOUR=1 is set" "Container Bonjour"
else
    emit_fail "OPENCLAW_DISABLE_BONJOUR not set in container environment" "Container Bonjour"
fi

# ---------- Check 10: Volume mounts — warn on sensitive paths ----------
mounts=$(docker inspect --format='{{range .Mounts}}{{.Source}}:{{.Destination}}:{{.Mode}} {{end}}' openclaw 2>/dev/null || echo "")

mount_issue=false
for sensitive_path in "/etc" "/var" "/root" "/Users" "/home"; do
    if echo "$mounts" | grep -q "^${sensitive_path}:"; then
        emit_warn "Sensitive host path mounted: $sensitive_path"
        mount_issue=true
    fi
done

if [ "$mount_issue" = false ]; then
    emit_pass "No sensitive host paths mounted" "Volume Mounts"
else
    emit_fail "Sensitive host paths are mounted into the container" "Volume Mounts"
fi
}

# --- Check: credential_exposure ---

__meta_credential_exposure() {
    case "$1" in
        name) echo "Credential Exposure Scan" ;;
        id)   echo "credential_exposure" ;;
    esac
}

__check_credential_exposure() {
# ============================================================================
# Clawkeeper Check: Credential Exposure Scan
# Scans openclaw.json, shell history, MEMORY.md, and session logs for
# common credential patterns. Never echoes actual credentials — truncates
# to first 4 characters.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

# Patterns that match common credential formats
# NEVER echo actual credentials — truncate to first 4 chars
cred_patterns='(sk-ant-api[A-Za-z0-9]{10,}|sk-[A-Za-z0-9]{20,}|ghp_[A-Za-z0-9]{36}|xoxb-[0-9]{10,}|AKIA[0-9A-Z]{16}|AIza[A-Za-z0-9_-]{35})'

config_file="$HOME/.openclaw/openclaw.json"

# ---- 1. Config file: detect resolved ${VAR} env vars (config.patch bug) ----
if [ -f "$config_file" ]; then
    config_matches=$(grep -oE "$cred_patterns" "$config_file" 2>/dev/null || true)
    if [ -n "$config_matches" ]; then
        truncated=$(echo "$config_matches" | head -1 | cut -c1-4)
        emit_fail "CRITICAL: Credential found in openclaw.json (${truncated}****)" "Credential Exposure Config"
        emit_info "Likely caused by env-var resolution bug — remove and use .env instead"
    else
        emit_pass "No credentials detected in openclaw.json" "Credential Exposure Config"
    fi
else
    emit_info "No openclaw.json found — skipping config credential scan"
fi

# ---- 2. Shell history ----
history_files=(
    "$HOME/.bash_history"
    "$HOME/.zsh_history"
)
history_hit=false
for hfile in "${history_files[@]}"; do
    if [ -f "$hfile" ]; then
        hist_match=$(grep -oE "$cred_patterns" "$hfile" 2>/dev/null | head -1 || true)
        if [ -n "$hist_match" ]; then
            history_hit=true
            truncated=$(echo "$hist_match" | cut -c1-4)
            emit_fail "Credential found in shell history: $(basename "$hfile") (${truncated}****)" "Credential Exposure History"
            emit_info "Run: history -c or remove matching lines from $hfile"
        fi
    fi
done
if [ "$history_hit" = false ]; then
    emit_pass "No credentials found in shell history" "Credential Exposure History"
fi

# ---- 3. MEMORY.md ----
memory_file="$HOME/.openclaw/MEMORY.md"
if [ -f "$memory_file" ]; then
    # Check permissions
    mem_perms=$(stat -f "%OLp" "$memory_file" 2>/dev/null || stat -c "%a" "$memory_file" 2>/dev/null || echo "unknown")
    if [ "$mem_perms" != "600" ] && [ "$mem_perms" != "700" ]; then
        emit_fail "MEMORY.md permissions are $mem_perms (should be 600)" "Credential Exposure Memory"
    fi
    # Content scan
    mem_match=$(grep -oE "$cred_patterns" "$memory_file" 2>/dev/null | head -1 || true)
    if [ -n "$mem_match" ]; then
        truncated=$(echo "$mem_match" | cut -c1-4)
        emit_fail "Credential found in MEMORY.md (${truncated}****)" "Credential Exposure Memory"
        emit_info "OpenClaw may have memorized a secret — edit ~/.openclaw/MEMORY.md"
    else
        emit_pass "No credentials detected in MEMORY.md" "Credential Exposure Memory"
    fi
else
    emit_info "No MEMORY.md found — skipping memory credential scan"
fi

# ---- 4. Session logs (sample scan — check permissions + first few files) ----
sessions_dir="$HOME/.openclaw/agents"
if [ -d "$sessions_dir" ]; then
    session_files=$(find "$sessions_dir" -name "*.jsonl" -type f 2>/dev/null | head -5)
    if [ -n "$session_files" ]; then
        # Check directory permissions
        sess_perms=$(stat -f "%OLp" "$sessions_dir" 2>/dev/null || stat -c "%a" "$sessions_dir" 2>/dev/null || echo "unknown")
        if [ "$sess_perms" != "700" ]; then
            emit_fail "Session logs directory permissions are $sess_perms (should be 700)" "Credential Exposure Sessions"
        fi
        # Sample content scan
        sess_hit=false
        while IFS= read -r sfile; do
            [ -z "$sfile" ] && continue
            s_match=$(grep -oE "$cred_patterns" "$sfile" 2>/dev/null | head -1 || true)
            if [ -n "$s_match" ]; then
                sess_hit=true
                truncated=$(echo "$s_match" | cut -c1-4)
                emit_fail "Credential found in session log (${truncated}****)" "Credential Exposure Sessions"
                emit_info "File: $sfile"
                break
            fi
        done <<< "$session_files"
        if [ "$sess_hit" = false ]; then
            emit_pass "No credentials detected in sampled session logs" "Credential Exposure Sessions"
        fi
    else
        emit_info "No session log files found"
    fi
else
    emit_info "No agents directory found — skipping session log scan"
fi
}

# --- Check: docker_installed ---

__meta_docker_installed() {
    case "$1" in
        name) echo "Docker Desktop" ;;
        id)   echo "docker_installed" ;;
    esac
}

__check_docker_installed() {
# ============================================================================
# Clawkeeper Check: Docker Desktop
# Detects whether Docker is installed, running, and has reasonable settings.
# Includes harden_docker_desktop sub-checks when Docker is running.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Container isolation is the most impactful security improvement for OpenClaw."

# --- Docker Desktop hardening sub-check -------------------------------------
# Called when Docker is installed and running.
harden_docker_desktop() {
    local docker_settings="$HOME/Library/Group Containers/group.com.docker/settings.json"

    if [ ! -f "$docker_settings" ]; then
        emit_info "Docker Desktop settings file not found — using defaults"
        return
    fi

    local issues=()

    # Check telemetry
    if grep -q '"analyticsEnabled".*true' "$docker_settings" 2>/dev/null; then
        issues+=("telemetry")
    fi

    # Check resource limits (warn if very high or unlimited)
    local mem_limit
    mem_limit=$(grep -o '"memoryMiB"[[:space:]]*:[[:space:]]*[0-9]*' "$docker_settings" 2>/dev/null | grep -o '[0-9]*' || echo "0")
    if [ "$mem_limit" -gt 8192 ] 2>/dev/null; then
        issues+=("memory")
    fi

    local cpu_limit
    cpu_limit=$(grep -o '"cpus"[[:space:]]*:[[:space:]]*[0-9]*' "$docker_settings" 2>/dev/null | grep -o '[0-9]*' || echo "0")
    if [ "$cpu_limit" -gt 4 ] 2>/dev/null; then
        issues+=("cpu")
    fi

    if [ ${#issues[@]} -eq 0 ]; then
        emit_pass "Docker Desktop settings look reasonable" "Docker Settings"
        return
    fi

    # Report individual issues
    for issue in "${issues[@]}"; do
        case "$issue" in
            telemetry)
                emit_warn "Docker Desktop analytics/telemetry is enabled"
                emit_info "Disable: Docker Desktop -> Settings -> General -> uncheck 'Send usage statistics'"
                ;;
            memory)
                emit_warn "Docker memory limit is high (${mem_limit}MB)"
                emit_info "Recommend 4096MB max: Docker Desktop -> Settings -> Resources -> Memory"
                ;;
            cpu)
                emit_warn "Docker CPU limit is high (${cpu_limit} CPUs)"
                emit_info "Recommend 2 CPUs max: Docker Desktop -> Settings -> Resources -> CPUs"
                ;;
        esac
    done

    emit_fail "Docker Desktop settings need hardening (adjust manually in Docker Desktop -> Settings)" "Docker Settings"
}

# --- Main Docker check -------------------------------------------------------

if command -v docker &>/dev/null; then
    if docker info &>/dev/null; then
        emit_pass "Docker is installed and running" "Docker"
        harden_docker_desktop
return 0
    else
        # Docker installed but not running
        emit_warn "Docker is installed but not running"
        emit_info "Open Docker Desktop from Applications to start it."
        emit_prompt "Attempt to start Docker Desktop?" "start_docker" \
            "Docker not running" \
            "Docker left stopped"
return 0
    fi
fi

# Docker not installed
emit_warn "Docker is not installed"

if ! command -v brew &>/dev/null; then
    emit_fail "Docker not installed (install Homebrew first)" "Docker"
return 0
fi

emit_prompt "Install Docker Desktop via Homebrew?" "install_docker" \
    "Docker not installed" \
    "Docker not installed"
}

__remediate_docker_installed() {
# ============================================================================
# Clawkeeper Remediation: Docker Desktop
# Handles starting Docker Desktop or installing it via Homebrew.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    start_docker)
        open -a "Docker" 2>/dev/null || true
        emit_info "Waiting for Docker to start (up to 60 seconds)..."

        waited=0
        while [ $waited -lt 60 ]; do
            if docker info &>/dev/null 2>&1; then
                emit_pass "Docker Desktop started" "Docker"
return 0
            fi
            sleep 5
            waited=$((waited + 5))
        done

        emit_fail "Docker did not start within 60 seconds — open it manually" "Docker"
return 1
        ;;
    install_docker)
        emit_info "Installing Docker Desktop (this may take a few minutes)..."

        brew install --cask docker 2>&1 | tail -5 || {
            emit_fail "Docker installation failed" "Docker"
return 1
        }

        emit_info "Opening Docker Desktop for first-time setup..."
        open -a "Docker" 2>/dev/null || true

        emit_info "Waiting for Docker to start (up to 90 seconds)..."
        waited=0
        while [ $waited -lt 90 ]; do
            if docker info &>/dev/null 2>&1; then
                emit_pass "Docker Desktop installed and running" "Docker"
return 0
            fi
            sleep 5
            waited=$((waited + 5))
        done

        emit_warn "Docker installed but may still be starting up"
        emit_info "Complete the Docker Desktop setup wizard, then re-run this script."
        emit_fail "Docker installed but not yet responsive" "Docker"
return 1
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Docker"
        ;;
esac
}

# --- Check: env_file ---

__meta_env_file() {
    case "$1" in
        name) echo ".env File Security" ;;
        id)   echo "env_file" ;;
    esac
}

__check_env_file() {
# ============================================================================
# Clawkeeper Check: .env File Security
# Checks .env file permissions in common OpenClaw installation locations.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

env_candidates=(
    "$HOME/openclaw-docker/.env"
    "$HOME/.openclaw/.env"
    "$HOME/openclaw/.env"
)

found_env=false

for env_file in "${env_candidates[@]}"; do
    if [ -f "$env_file" ]; then
        found_env=true
        perms=$(stat -f "%OLp" "$env_file" 2>/dev/null || stat -c "%a" "$env_file" 2>/dev/null || echo "unknown")

        if [ "$perms" = "600" ]; then
            emit_pass ".env file ($env_file) permissions are 600" ".env Permissions"
        else
            emit_prompt ".env file ($env_file) permissions are $perms — fix to 600?" \
                "fix_env_perms:${env_file}" \
                ".env permissions are $perms (should be 600)" \
                ".env permissions not changed"
        fi
    fi
done

if [ "$found_env" = false ]; then
    emit_info "No .env file found in common locations"
    emit_info "Expected at ~/openclaw-docker/.env if using Docker setup"
fi
}

__remediate_env_file() {
# ============================================================================
# Clawkeeper Remediation: .env File Security
# Fixes .env file permissions to 600.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

# The remediation_id is in the form "fix_env_perms:/path/to/.env"
case "$REMEDIATION_ID" in
    fix_env_perms:*)
        env_file="${REMEDIATION_ID#fix_env_perms:}"
        if [ -f "$env_file" ]; then
            chmod 600 "$env_file"
            emit_pass ".env file set to 600 ($env_file)" ".env Permissions"
        else
            emit_fail ".env file not found: $env_file" ".env Permissions"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" ".env Permissions"
        ;;
esac
}

# --- Check: filevault ---

__meta_filevault() {
    case "$1" in
        name) echo "FileVault (Full-Disk Encryption)" ;;
        id)   echo "filevault" ;;
    esac
}

__check_filevault() {
# ============================================================================
# Clawkeeper Check: FileVault (Full-Disk Encryption)
# Detects whether FileVault is enabled on macOS.
# Info-only — no automated remediation (must be done in System Settings).
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Protects data at rest if the machine is physically compromised."

fv_status=$(fdesetup status 2>/dev/null || echo "unknown")

if echo "$fv_status" | grep -qi "FileVault is On"; then
    emit_pass "FileVault is enabled" "FileVault"
return 0
elif echo "$fv_status" | grep -qi "FileVault is Off"; then
    emit_warn "FileVault is OFF — disk is NOT encrypted"
    emit_info "FileVault requires interactive setup (password + recovery key)."
    emit_info "Enable it: System Settings -> Privacy & Security -> FileVault -> Turn On"
    emit_info "Choose 'Create a recovery key' — do NOT use iCloud for a dedicated machine."
    emit_fail "FileVault is off (enable manually in System Settings)" "FileVault"
return 0
fi

emit_warn "Could not determine FileVault status"
emit_fail "FileVault status unknown" "FileVault"
}

# --- Check: firewall ---

__meta_firewall() {
    case "$1" in
        name) echo "macOS Firewall" ;;
        id)   echo "firewall" ;;
    esac
}

__check_firewall() {
# ============================================================================
# Clawkeeper Check: macOS Firewall
# Detects whether the macOS application firewall is enabled and whether
# "Block all incoming connections" is active.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Host-level firewall provides defense in depth beyond network isolation."

fw_on=false
fw_block_all=false

fw_status=$(/usr/libexec/ApplicationFirewall/socketfilterfw --getglobalstate 2>/dev/null || echo "unknown")

if echo "$fw_status" | grep -qi "enabled"; then
    fw_on=true
fi

if [ "$fw_on" = true ]; then
    block_status=$(/usr/libexec/ApplicationFirewall/socketfilterfw --getblockall 2>/dev/null || echo "unknown")
    if echo "$block_status" | grep -qi "enabled"; then
        fw_block_all=true
    fi
fi

if [ "$fw_on" = true ] && [ "$fw_block_all" = true ]; then
    emit_pass "Firewall is on with 'Block all incoming' enabled" "Firewall"
return 0
elif [ "$fw_on" = true ]; then
    emit_warn "Firewall is ON but 'Block all incoming' is not set"
    emit_info "This allows some incoming connections. Strictest mode blocks all."
    emit_prompt "Enable 'Block all incoming connections'?" "enable_block_all" \
        "Firewall 'Block all incoming' is not enabled" \
        "Firewall left in permissive mode"
return 0
fi

# Firewall is off
emit_warn "macOS Firewall is OFF"
emit_prompt "Enable the firewall with 'Block all incoming'?" "enable_firewall" \
    "macOS Firewall is off" \
    "Firewall left off"
}

__remediate_firewall() {
# ============================================================================
# Clawkeeper Remediation: macOS Firewall
# Enables the firewall and/or sets "Block all incoming connections".
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    enable_block_all)
        # Firewall is already on — just enable block-all
        sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setblockall on &>/dev/null || true
        emit_pass "Firewall set to block all incoming" "Firewall"
        emit_info "Note: This may block Screen Sharing. Add exceptions if needed."
        ;;
    enable_firewall)
        # Firewall is off — enable everything
        sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setglobalstate on &>/dev/null || true
        sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setblockall on &>/dev/null || true
        sudo /usr/libexec/ApplicationFirewall/socketfilterfw --setstealthmode on &>/dev/null || true
        emit_pass "Firewall enabled (block all + stealth mode)" "Firewall"
        emit_info "Note: This may block Screen Sharing. Add exceptions if needed."
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Firewall"
        ;;
esac
}

# --- Check: homebrew ---

__meta_homebrew() {
    case "$1" in
        name) echo "Homebrew" ;;
        id)   echo "homebrew" ;;
    esac
}

__check_homebrew() {
# ============================================================================
# Clawkeeper Check: Homebrew
# Detects whether Homebrew is installed on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Package manager needed for installing Docker, Node.js, and other tools."

if command -v brew &>/dev/null; then
    brew_version=$(brew --version 2>/dev/null | head -1 || echo "unknown")
    emit_pass "Homebrew is installed ($brew_version)" "Homebrew"
return 0
fi

# Homebrew not found — prompt to install
emit_warn "Homebrew is not installed"
emit_prompt "Install Homebrew now?" "install_homebrew" \
    "Homebrew not installed" \
    "Homebrew not installed"
}

__remediate_homebrew() {
# ============================================================================
# Clawkeeper Remediation: Homebrew
# Installs Homebrew and configures PATH for the current and future sessions.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    install_homebrew)
        emit_info "Running Homebrew installer..."

        /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)" || {
            emit_fail "Homebrew installation failed" "Homebrew"
return 1
        }

        # Add to PATH based on architecture
        brew_prefix=""
        if [ -f /opt/homebrew/bin/brew ]; then
            brew_prefix="/opt/homebrew"
        elif [ -f /usr/local/bin/brew ]; then
            brew_prefix="/usr/local"
        fi

        if [ -n "$brew_prefix" ]; then
            eval "$("${brew_prefix}/bin/brew" shellenv)"
            # Also add to shell profile for future sessions
            shell_profile="$HOME/.zprofile"
            if ! grep -q 'homebrew' "$shell_profile" 2>/dev/null; then
                echo "eval \"\$(${brew_prefix}/bin/brew shellenv)\"" >> "$shell_profile"
                emit_info "Added Homebrew to $shell_profile"
            fi
        fi

        if command -v brew &>/dev/null; then
            emit_pass "Homebrew installed" "Homebrew"
        else
            emit_fail "Homebrew installed but not in PATH — restart your terminal" "Homebrew"
return 1
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Homebrew"
        ;;
esac
}

# --- Check: icloud ---

__meta_icloud() {
    case "$1" in
        name) echo "iCloud" ;;
        id)   echo "icloud" ;;
    esac
}

__check_icloud() {
# ============================================================================
# Clawkeeper Check: iCloud
# Detects whether an iCloud account is signed in on macOS.
# Info-only — no automated remediation (must sign out manually).
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "iCloud syncs data off-device. A compromised agent's files shouldn't trigger cloud uploads."

# Check if any iCloud account is configured
icloud_account=$(defaults read MobileMeAccounts Accounts 2>/dev/null || echo "")

if [ -z "$icloud_account" ] || echo "$icloud_account" | grep -q "(\s*)"; then
    emit_pass "No iCloud account signed in" "iCloud"
return 0
fi

emit_warn "An iCloud account appears to be signed in"
emit_info "iCloud can sync OpenClaw workspace files to Apple's servers."
emit_info "Sign out: System Settings -> [your name] -> Sign Out"
emit_info "Or disable iCloud Drive: System Settings -> Apple ID -> iCloud -> iCloud Drive -> OFF"
emit_fail "iCloud is signed in (disable manually in System Settings)" "iCloud"
}

# --- Check: linux_auto_updates ---

__meta_linux_auto_updates() {
    case "$1" in
        name) echo "Automatic Security Updates" ;;
        id)   echo "linux_auto_updates" ;;
    esac
}

__check_linux_auto_updates() {
# ============================================================================
# Clawkeeper Check: Automatic Security Updates
# Checks unattended-upgrades (Debian/Ubuntu) or dnf-automatic (RHEL/Fedora).
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Servers should auto-install security patches to prevent known exploits."

# Detect distro family
distro=""
if [ -f /etc/os-release ]; then
    . /etc/os-release
    case "$ID" in
        ubuntu|debian) distro="debian" ;;
        fedora|rhel|centos|rocky|almalinux) distro="rhel" ;;
        *) distro="$ID" ;;
    esac
fi

if [ "$distro" = "debian" ]; then
    if dpkg -l unattended-upgrades 2>/dev/null | grep -q "^ii"; then
        if systemctl is-active --quiet unattended-upgrades 2>/dev/null; then
            emit_pass "unattended-upgrades is installed and active" "Auto Updates"
        else
            emit_warn "unattended-upgrades is installed but not active"
            emit_prompt "Enable automatic security updates?" "enable_unattended_upgrades" \
                "Automatic updates not active" \
                "Automatic updates not enabled"
        fi
    else
        emit_warn "unattended-upgrades is not installed"
        emit_prompt "Install and enable automatic security updates?" "install_unattended_upgrades" \
            "No automatic updates configured" \
            "Automatic updates not configured"
    fi
elif [ "$distro" = "rhel" ]; then
    if rpm -q dnf-automatic &>/dev/null; then
        emit_pass "dnf-automatic is installed" "Auto Updates"
    else
        emit_warn "dnf-automatic is not installed"
        emit_prompt "Install and enable automatic security updates?" "install_dnf_automatic" \
            "No automatic updates configured" \
            "Automatic updates not configured"
    fi
else
    emit_info "Auto-update check not supported for distro: ${distro:-unknown}"
    emit_skipped "Auto-update check skipped (unsupported distro)" "Auto Updates"
fi
}

__remediate_linux_auto_updates() {
# ============================================================================
# Clawkeeper Remediation: Automatic Security Updates
# Installs/enables unattended-upgrades or dnf-automatic depending on distro.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    enable_unattended_upgrades)
        sudo systemctl enable --now unattended-upgrades 2>/dev/null || true
        emit_pass "Automatic updates enabled" "Auto Updates"
        ;;
    install_unattended_upgrades)
        sudo apt-get update -qq && sudo DEBIAN_FRONTEND=noninteractive apt-get install -y -qq unattended-upgrades 2>&1 | tail -3
        sudo systemctl enable --now unattended-upgrades 2>/dev/null || true
        emit_pass "unattended-upgrades installed and enabled" "Auto Updates"
        ;;
    install_dnf_automatic)
        sudo dnf install -y -q dnf-automatic 2>&1 | tail -3
        sudo systemctl enable --now dnf-automatic-install.timer 2>/dev/null || true
        emit_pass "dnf-automatic installed and enabled" "Auto Updates"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Auto Updates"
        ;;
esac
}

# --- Check: linux_disk_encryption ---

__meta_linux_disk_encryption() {
    case "$1" in
        name) echo "Disk Encryption" ;;
        id)   echo "linux_disk_encryption" ;;
    esac
}

__check_linux_disk_encryption() {
# ============================================================================
# Clawkeeper Check: Linux Disk Encryption
# Detects LUKS / dm-crypt encrypted volumes.
# Info-only — no automated remediation (most VPS providers do not offer LUKS).
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Protects data at rest if the server disk is accessed outside the VM."

# Method 1: check lsblk for crypt type
if command -v lsblk &>/dev/null; then
    if lsblk -o TYPE 2>/dev/null | grep -q "crypt"; then
        emit_pass "LUKS disk encryption detected" "Disk Encryption"
return 0
    fi
fi

# Method 2: check /dev/mapper for crypt* or luks* entries
if ls /dev/mapper/crypt* &>/dev/null 2>&1 || ls /dev/mapper/luks* &>/dev/null 2>&1; then
    emit_pass "Encrypted volumes detected" "Disk Encryption"
return 0
fi

# No encryption detected
emit_warn "No disk encryption detected"
emit_info "Most VPS providers do not offer LUKS. Consider provider-level encryption"
emit_info "or application-level encryption for sensitive data."

if [ "$MODE" = "scan" ]; then
    emit_fail "No disk encryption detected" "Disk Encryption"
else
    emit_skipped "Disk encryption not available (typical for VPS)" "Disk Encryption"
fi
}

# --- Check: linux_docker ---

__meta_linux_docker() {
    case "$1" in
        name) echo "Docker Engine" ;;
        id)   echo "linux_docker" ;;
    esac
}

__check_linux_docker() {
# ============================================================================
# Clawkeeper Check: Linux Docker Engine
# Detects Docker installation, running status, and Compose plugin.
# Offers to start the service or install Docker from get.docker.com.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Docker provides container isolation for OpenClaw."

if command -v docker &>/dev/null; then
    if docker info &>/dev/null 2>&1; then
        docker_version=$(docker --version 2>/dev/null | head -1 || echo "unknown")
        emit_pass "Docker is installed and running ($docker_version)" "Docker"

        # Check Docker Compose
        if docker compose version &>/dev/null 2>&1; then
            compose_ver=$(docker compose version --short 2>/dev/null || echo "unknown")
            emit_info "Docker Compose $compose_ver available"
        else
            emit_warn "Docker Compose plugin not found"
            emit_info "Install: sudo apt-get install docker-compose-plugin"
        fi
return 0
    else
        emit_warn "Docker is installed but not running or accessible"
        emit_prompt "Start Docker service?" "start_docker" \
            "Docker not running" \
            "Docker not started"
return 0
    fi
fi

# Docker not installed at all
emit_warn "Docker is not installed"
emit_prompt "Install Docker Engine via official script?" "install_docker" \
    "Docker not installed" \
    "Docker not installed"
}

__remediate_linux_docker() {
# ============================================================================
# Clawkeeper Remediation: Linux Docker Engine
# Handles starting the Docker service or installing Docker from get.docker.com.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    start_docker)
        emit_info "Starting Docker service..."
        sudo systemctl start docker 2>/dev/null
        sudo systemctl enable docker 2>/dev/null

        if docker info &>/dev/null 2>&1; then
            emit_pass "Docker service started and enabled" "Docker"
        else
            emit_fail "Docker could not be started — check: sudo journalctl -u docker" "Docker"
return 1
        fi
        ;;
    install_docker)
        emit_info "Installing Docker Engine (this may take a minute)..."
        curl -fsSL https://get.docker.com | sudo sh 2>&1 | tail -10 || {
            emit_fail "Docker installation failed" "Docker"
return 1
        }

        # Add current user to docker group
        current_user=$(whoami)
        if [ "$current_user" != "root" ]; then
            sudo usermod -aG docker "$current_user" 2>/dev/null || true
            emit_info "Added $current_user to docker group (log out/in to take effect)"
        fi

        sudo systemctl enable --now docker 2>/dev/null || true

        if docker info &>/dev/null 2>&1 || sudo docker info &>/dev/null 2>&1; then
            emit_pass "Docker Engine installed and running" "Docker"
        else
            emit_warn "Docker installed — you may need to log out and back in"
            emit_info "Then verify with: docker info"
            emit_pass "Docker Engine installed (re-login may be required)" "Docker"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Docker"
        ;;
esac
}

# --- Check: linux_essentials ---

__meta_linux_essentials() {
    case "$1" in
        name) echo "Essential Packages" ;;
        id)   echo "linux_essentials" ;;
    esac
}

__check_linux_essentials() {
# ============================================================================
# Clawkeeper Check: Linux Essential Packages
# Checks for git, curl, openssl, and ca-certificates.
# Emits a remediation prompt if any are missing.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Checking for git, curl, openssl, and ca-certificates."

missing=()
for pkg in git curl openssl ca-certificates; do
    # ca-certificates is a package, not a command — check differently
    if [ "$pkg" = "ca-certificates" ]; then
        # Check if the ca-certificates bundle exists
        if [ -f /etc/ssl/certs/ca-certificates.crt ] || [ -d /etc/pki/tls/certs ] || dpkg -s ca-certificates &>/dev/null 2>&1 || rpm -q ca-certificates &>/dev/null 2>&1; then
            emit_info "$pkg is installed"
        else
            missing+=("$pkg")
            emit_warn "$pkg is not installed"
        fi
    elif command -v "$pkg" &>/dev/null; then
        emit_info "$pkg is installed"
    else
        missing+=("$pkg")
        emit_warn "$pkg is not installed"
    fi
done

if [ ${#missing[@]} -eq 0 ]; then
    emit_pass "All essential packages installed" "Essentials"
return 0
fi

# Check for a supported package manager before offering remediation
if ! command -v apt-get &>/dev/null && ! command -v dnf &>/dev/null; then
    emit_fail "Missing packages: ${missing[*]} (unsupported package manager)" "Essentials"
return 0
fi

emit_prompt "Install missing packages (${missing[*]})?" "install_essentials" \
    "Missing packages: ${missing[*]}" \
    "Missing packages not installed"
}

__remediate_linux_essentials() {
# ============================================================================
# Clawkeeper Remediation: Linux Essential Packages
# Installs missing packages via apt-get or dnf.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    install_essentials)
        # Re-detect which packages are missing
        missing=()
        for pkg in git curl openssl ca-certificates; do
            if [ "$pkg" = "ca-certificates" ]; then
                if [ -f /etc/ssl/certs/ca-certificates.crt ] || [ -d /etc/pki/tls/certs ] || dpkg -s ca-certificates &>/dev/null 2>&1 || rpm -q ca-certificates &>/dev/null 2>&1; then
                    continue
                fi
                missing+=("$pkg")
            elif ! command -v "$pkg" &>/dev/null; then
                missing+=("$pkg")
            fi
        done

        if [ ${#missing[@]} -eq 0 ]; then
            emit_pass "All essential packages already installed" "Essentials"
return 0
        fi

        emit_info "Installing missing packages: ${missing[*]}"

        if command -v apt-get &>/dev/null; then
            sudo apt-get update -qq && sudo apt-get install -y -qq "${missing[@]}" 2>&1 | tail -3 || {
                emit_fail "Package installation failed" "Essentials"
return 1
            }
        elif command -v dnf &>/dev/null; then
            sudo dnf install -y -q "${missing[@]}" 2>&1 | tail -3 || {
                emit_fail "Package installation failed" "Essentials"
return 1
            }
        else
            emit_fail "Unsupported package manager" "Essentials"
return 1
        fi

        emit_pass "Essential packages installed" "Essentials"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Essentials"
        ;;
esac
}

# --- Check: linux_fail2ban ---

__meta_linux_fail2ban() {
    case "$1" in
        name) echo "Fail2ban" ;;
        id)   echo "linux_fail2ban" ;;
    esac
}

__check_linux_fail2ban() {
# ============================================================================
# Clawkeeper Check: Fail2ban
# Checks whether fail2ban is installed and running.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Blocks IPs after repeated failed login attempts."

if command -v fail2ban-client &>/dev/null; then
    if systemctl is-active --quiet fail2ban 2>/dev/null; then
        emit_pass "Fail2ban is installed and running" "Fail2ban"
    else
        emit_warn "Fail2ban is installed but not running"
        emit_prompt "Start and enable fail2ban?" "start_fail2ban" \
            "Fail2ban is not running" \
            "Fail2ban not started"
    fi
else
    emit_warn "Fail2ban is not installed"
    emit_prompt "Install and configure fail2ban?" "install_fail2ban" \
        "Fail2ban is not installed" \
        "Fail2ban not installed"
fi
}

__remediate_linux_fail2ban() {
# ============================================================================
# Clawkeeper Remediation: Fail2ban
# Installs and/or starts fail2ban with a sensible default configuration.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    start_fail2ban)
        sudo systemctl enable --now fail2ban 2>/dev/null
        emit_pass "Fail2ban started and enabled" "Fail2ban"
        ;;
    install_fail2ban)
        if command -v apt-get &>/dev/null; then
            sudo apt-get update -qq && sudo apt-get install -y -qq fail2ban 2>&1 | tail -3
        elif command -v dnf &>/dev/null; then
            sudo dnf install -y -q fail2ban 2>&1 | tail -3
        else
            emit_fail "Cannot install fail2ban -- unsupported package manager" "Fail2ban"
return 1
        fi

        sudo tee /etc/fail2ban/jail.local > /dev/null << 'F2B_EOF'
# CLAW Keeper — fail2ban configuration
[DEFAULT]
bantime = 1h
findtime = 10m
maxretry = 3

[sshd]
enabled = true
port = ssh
filter = sshd
logpath = /var/log/auth.log
maxretry = 3
F2B_EOF

        sudo systemctl enable --now fail2ban 2>/dev/null || true
        emit_pass "Fail2ban installed and configured" "Fail2ban"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Fail2ban"
        ;;
esac
}

# --- Check: linux_firewall ---

__meta_linux_firewall() {
    case "$1" in
        name) echo "Firewall (UFW)" ;;
        id)   echo "linux_firewall" ;;
    esac
}

__check_linux_firewall() {
# ============================================================================
# Clawkeeper Check: Firewall (UFW)
# Checks UFW status: active, installed-but-inactive, or not installed.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "A firewall limits inbound access to only the ports you need."

if command -v ufw &>/dev/null; then
    ufw_status=$(sudo ufw status 2>/dev/null || ufw status 2>/dev/null || echo "unknown")

    if echo "$ufw_status" | grep -qi "Status: active"; then
        emit_pass "UFW firewall is active" "Firewall"

        # Check if OpenClaw port is exposed externally
        if echo "$ufw_status" | grep -q "18789.*ALLOW.*Anywhere"; then
            emit_warn "Port 18789 is open in UFW -- prefer SSH tunnel over direct exposure"
        fi
return 0
    fi

    # UFW is installed but not active
    emit_warn "UFW is installed but not active"
    emit_prompt "Enable UFW with SSH-only inbound rules?" "enable_ufw" \
        "UFW firewall is not active" \
        "Firewall not enabled"
else
    # UFW is not installed
    emit_warn "UFW is not installed"
    emit_prompt "Install and configure UFW?" "install_ufw" \
        "No firewall installed" \
        "Firewall not installed"
fi
}

__remediate_linux_firewall() {
# ============================================================================
# Clawkeeper Remediation: Firewall (UFW)
# Installs and/or enables UFW with SSH-only inbound rules.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    enable_ufw)
        sudo ufw default deny incoming 2>/dev/null
        sudo ufw default allow outgoing 2>/dev/null
        sudo ufw allow ssh 2>/dev/null
        sudo ufw --force enable 2>/dev/null
        emit_pass "UFW enabled (SSH allowed, OpenClaw via SSH tunnel only)" "Firewall"
        emit_info "Access OpenClaw via: ssh -N -L 18789:127.0.0.1:18789 user@this-server"
        ;;
    install_ufw)
        if command -v apt-get &>/dev/null; then
            sudo apt-get update -qq && sudo apt-get install -y -qq ufw 2>&1 | tail -3
        elif command -v dnf &>/dev/null; then
            sudo dnf install -y -q ufw 2>&1 | tail -3
        else
            emit_fail "Cannot install UFW -- unsupported package manager" "Firewall"
return 1
        fi
        sudo ufw default deny incoming 2>/dev/null
        sudo ufw default allow outgoing 2>/dev/null
        sudo ufw allow ssh 2>/dev/null
        sudo ufw --force enable 2>/dev/null
        emit_pass "UFW installed and enabled (SSH-only inbound)" "Firewall"
        emit_info "Access OpenClaw via SSH tunnel -- do NOT open port 18789"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Firewall"
        ;;
esac
}

# --- Check: linux_network ---

__meta_linux_network() {
    case "$1" in
        name) echo "Network Configuration" ;;
        id)   echo "linux_network" ;;
    esac
}

__check_linux_network() {
# ============================================================================
# Clawkeeper Check: Linux Network Configuration
# Displays public IP, local IP, and virtualization type.
# Info-only — always passes.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Reviewing network interfaces and connectivity."

# Gather public IP
public_ip=$(curl -sf --max-time 5 https://ifconfig.me 2>/dev/null \
    || curl -sf --max-time 5 https://api.ipify.org 2>/dev/null \
    || echo "unknown")

# Gather local IP
local_ip=$(hostname -I 2>/dev/null | awk '{print $1}' || echo "unknown")

emit_info "Public IP: $public_ip"
emit_info "Local IP: $local_ip"

# Detect virtualization type
virt_type=$(systemd-detect-virt 2>/dev/null || echo "unknown")
emit_info "Virtualization: $virt_type"

emit_info "For VPS deployments, bind OpenClaw to loopback and access via SSH tunnel:"
emit_info "  ssh -N -L 18789:127.0.0.1:18789 user@$public_ip"

emit_pass "Network info displayed" "Network"
}

# --- Check: linux_node ---

__meta_linux_node() {
    case "$1" in
        name) echo "Node.js" ;;
        id)   echo "linux_node" ;;
    esac
}

__check_linux_node() {
# ============================================================================
# Clawkeeper Check: Linux Node.js
# Detects whether Node.js >= 22 is installed.
# Offers installation via NodeSource if missing or outdated.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "OpenClaw requires Node.js 22 or higher."

if command -v node &>/dev/null; then
    node_version=$(node --version 2>/dev/null || echo "unknown")
    major_version=$(echo "$node_version" | sed 's/v//' | cut -d. -f1)

    if [ "$major_version" -ge 22 ] 2>/dev/null; then
        emit_pass "Node.js $node_version installed (meets v22+ requirement)" "Node.js"
return 0
    else
        emit_warn "Node.js $node_version is installed but OpenClaw needs v22+"
    fi
else
    emit_warn "Node.js is not installed"
fi

# Check for a supported package manager before offering remediation
if ! command -v apt-get &>/dev/null && ! command -v dnf &>/dev/null; then
    emit_fail "Node.js 22+ not available (unsupported package manager for NodeSource)" "Node.js"
return 0
fi

emit_prompt "Install Node.js 22 via NodeSource?" "install_node" \
    "Node.js 22+ not installed" \
    "Node.js not installed"
}

__remediate_linux_node() {
# ============================================================================
# Clawkeeper Remediation: Linux Node.js
# Installs Node.js 22 via NodeSource repository.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    install_node)
        emit_info "Setting up NodeSource repository..."

        if command -v apt-get &>/dev/null; then
            curl -fsSL https://deb.nodesource.com/setup_22.x | sudo -E bash - 2>&1 | tail -5 || {
                emit_fail "NodeSource setup failed" "Node.js"
return 1
            }
            sudo apt-get install -y -qq nodejs 2>&1 | tail -3 || {
                emit_fail "Node.js installation failed" "Node.js"
return 1
            }
        elif command -v dnf &>/dev/null; then
            curl -fsSL https://rpm.nodesource.com/setup_22.x | sudo -E bash - 2>&1 | tail -5 || {
                emit_fail "NodeSource setup failed" "Node.js"
return 1
            }
            sudo dnf install -y -q nodejs 2>&1 | tail -3 || {
                emit_fail "Node.js installation failed" "Node.js"
return 1
            }
        else
            emit_fail "Unsupported package manager for NodeSource" "Node.js"
return 1
        fi

        if command -v node &>/dev/null; then
            new_version=$(node --version 2>/dev/null)
            emit_pass "Node.js $new_version installed" "Node.js"
        else
            emit_fail "Node.js installation failed" "Node.js"
return 1
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Node.js"
        ;;
esac
}

# --- Check: linux_open_ports ---

__meta_linux_open_ports() {
    case "$1" in
        name) echo "Open Ports Audit" ;;
        id)   echo "linux_open_ports" ;;
    esac
}

__check_linux_open_ports() {
# ============================================================================
# Clawkeeper Check: Linux Open Ports Audit
# Uses ss or netstat to identify listening ports. Flags OpenClaw gateway
# (port 18789) on 0.0.0.0 as critical.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Only essential ports should be listening on external interfaces."

listening_ports=""
if command -v ss &>/dev/null; then
    listening_ports=$(ss -tlnp 2>/dev/null || echo "")
elif command -v netstat &>/dev/null; then
    listening_ports=$(netstat -tlnp 2>/dev/null || echo "")
else
    emit_info "Neither ss nor netstat available — skipping port audit"
    emit_skipped "No port inspection tool available" "Open Ports"
return 0
fi

if [ -z "$listening_ports" ]; then
    emit_info "Could not retrieve listening ports"
    emit_skipped "Could not retrieve listening ports" "Open Ports"
return 0
fi

# Report listening services
if command -v ss &>/dev/null; then
    while IFS= read -r line; do
        addr=$(echo "$line" | awk '{print $4}')
        proc=$(echo "$line" | awk '{print $6}')
        if echo "$addr" | grep -q "0.0.0.0\|::"; then
            emit_warn "External listener: $addr -- $proc"
        else
            emit_info "Local listener: $addr -- $proc"
        fi
    done < <(ss -tlnp 2>/dev/null | grep "LISTEN")
fi

# Critical: check if OpenClaw port is externally exposed
if echo "$listening_ports" | grep -q "0.0.0.0:18789\|:::18789"; then
    emit_fail "OpenClaw gateway (18789) is listening on ALL interfaces — CRITICAL" "Open Ports"
    emit_info "Bind to loopback only and use SSH tunnel for access"
else
    emit_pass "No critical port exposure detected" "Open Ports"
fi
}

# --- Check: linux_ssh_hardening ---

__meta_linux_ssh_hardening() {
    case "$1" in
        name) echo "SSH Hardening" ;;
        id)   echo "linux_ssh_hardening" ;;
    esac
}

__check_linux_ssh_hardening() {
# ============================================================================
# Clawkeeper Check: SSH Hardening
# Checks sshd_config for PermitRootLogin, PasswordAuthentication,
# X11Forwarding, and MaxAuthTries.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "SSH is the primary attack surface on a VPS. Hardening is critical."

sshd_config="/etc/ssh/sshd_config"

if [ ! -f "$sshd_config" ]; then
    emit_warn "sshd_config not found at $sshd_config"
    emit_fail "Cannot audit SSH configuration" "SSH Hardening"
return 0
fi

issues=0

# Check PermitRootLogin
root_login=$(grep -i "^PermitRootLogin" "$sshd_config" 2>/dev/null | awk '{print $2}' || echo "")
if [ -z "$root_login" ]; then
    root_login=$(grep -rhi "^PermitRootLogin" /etc/ssh/sshd_config.d/ 2>/dev/null | tail -1 | awk '{print $2}' || echo "")
fi
if [ "$root_login" = "no" ] || [ "$root_login" = "prohibit-password" ]; then
    emit_pass "PermitRootLogin = $root_login" "PermitRootLogin"
else
    issues=$((issues + 1))
    emit_fail "PermitRootLogin is '${root_login:-yes (default)}' -- should be 'no' or 'prohibit-password'" "PermitRootLogin"
fi

# Check PasswordAuthentication
pass_auth=$(grep -i "^PasswordAuthentication" "$sshd_config" 2>/dev/null | awk '{print $2}' || echo "")
if [ -z "$pass_auth" ]; then
    pass_auth=$(grep -rhi "^PasswordAuthentication" /etc/ssh/sshd_config.d/ 2>/dev/null | tail -1 | awk '{print $2}' || echo "")
fi
if [ "$pass_auth" = "no" ]; then
    emit_pass "PasswordAuthentication = no" "PasswordAuthentication"
else
    issues=$((issues + 1))
    emit_fail "PasswordAuthentication is '${pass_auth:-yes (default)}' -- should be 'no'" "PasswordAuthentication"
fi

# Check X11Forwarding
x11=$(grep -i "^X11Forwarding" "$sshd_config" 2>/dev/null | awk '{print $2}' || echo "")
if [ "$x11" = "no" ]; then
    emit_pass "X11Forwarding = no" "X11Forwarding"
elif [ "$x11" = "yes" ]; then
    issues=$((issues + 1))
    emit_fail "X11Forwarding is enabled -- should be 'no' on a headless server" "X11Forwarding"
fi

# Check MaxAuthTries
max_auth=$(grep -i "^MaxAuthTries" "$sshd_config" 2>/dev/null | awk '{print $2}' || echo "")
if [ -n "$max_auth" ] && [ "$max_auth" -le 3 ] 2>/dev/null; then
    emit_pass "MaxAuthTries = $max_auth" "MaxAuthTries"
elif [ -n "$max_auth" ] && [ "$max_auth" -gt 6 ] 2>/dev/null; then
    issues=$((issues + 1))
    emit_fail "MaxAuthTries is $max_auth -- recommend 3 or less" "MaxAuthTries"
fi

if [ "$issues" -eq 0 ]; then
    emit_pass "SSH configuration is hardened" "SSH Hardening"
else
    emit_prompt "Harden SSH configuration?" "harden_ssh" \
        "SSH is not fully hardened" \
        "SSH hardening deferred"
fi
}

__remediate_linux_ssh_hardening() {
# ============================================================================
# Clawkeeper Remediation: SSH Hardening
# Creates a drop-in config at /etc/ssh/sshd_config.d/99-clawkeeper-hardening.conf,
# validates configuration, and reloads sshd.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    harden_ssh)
        dropin_dir="/etc/ssh/sshd_config.d"
        sudo mkdir -p "$dropin_dir" 2>/dev/null || true

        sudo tee "$dropin_dir/99-clawkeeper-hardening.conf" > /dev/null << 'SSH_EOF'
# CLAW Keeper SSH hardening
PermitRootLogin prohibit-password
PasswordAuthentication no
X11Forwarding no
MaxAuthTries 3
AllowAgentForwarding no
SSH_EOF

        # Validate config before reloading
        if sudo sshd -t 2>/dev/null; then
            sudo systemctl reload sshd 2>/dev/null || sudo systemctl reload ssh 2>/dev/null || true
            emit_pass "SSH hardened (drop-in: $dropin_dir/99-clawkeeper-hardening.conf)" "SSH Hardening"
            emit_warn "IMPORTANT: Verify you can still SSH in from another terminal before closing this session!"
        else
            sudo rm -f "$dropin_dir/99-clawkeeper-hardening.conf"
            emit_fail "SSH config validation failed -- changes reverted" "SSH Hardening"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "SSH Hardening"
        ;;
esac
}

# --- Check: linux_unnecessary_services ---

__meta_linux_unnecessary_services() {
    case "$1" in
        name) echo "Unnecessary Services" ;;
        id)   echo "linux_unnecessary_services" ;;
    esac
}

__check_linux_unnecessary_services() {
# ============================================================================
# Clawkeeper Check: Unnecessary Services
# Checks for running services that are typically unnecessary on a server:
# cups, avahi-daemon, bluetooth, ModemManager, whoopsie, apport.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Reducing running services minimizes the attack surface."

declare -A checked_services=(
    ["cups"]="Printing (CUPS)"
    ["avahi-daemon"]="mDNS/Bonjour (Avahi)"
    ["bluetooth"]="Bluetooth"
    ["ModemManager"]="Modem Manager"
    ["whoopsie"]="Ubuntu error reporting"
    ["apport"]="Crash reporting"
)

# Preserve ordering with a separate array
service_order=("cups" "avahi-daemon" "bluetooth" "ModemManager" "whoopsie" "apport")

found_services=()

for svc_name in "${service_order[@]}"; do
    svc_desc="${checked_services[$svc_name]}"
    if systemctl is-active --quiet "$svc_name" 2>/dev/null; then
        found_services+=("$svc_name")
        emit_warn "$svc_desc ($svc_name) is running"
    fi
done

if [ ${#found_services[@]} -eq 0 ]; then
    emit_pass "No unnecessary services detected" "Unnecessary Services"
return 0
fi

emit_prompt "Disable ${#found_services[@]} unnecessary service(s)?" "disable_services" \
    "Unnecessary services running" \
    "Unnecessary services left running"
}

__remediate_linux_unnecessary_services() {
# ============================================================================
# Clawkeeper Remediation: Unnecessary Services
# Disables all detected unnecessary services.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_services)
        # Re-check which services are running and disable them
        declare -A checked_services=(
            ["cups"]="Printing (CUPS)"
            ["avahi-daemon"]="mDNS/Bonjour (Avahi)"
            ["bluetooth"]="Bluetooth"
            ["ModemManager"]="Modem Manager"
            ["whoopsie"]="Ubuntu error reporting"
            ["apport"]="Crash reporting"
        )

        service_order=("cups" "avahi-daemon" "bluetooth" "ModemManager" "whoopsie" "apport")
        disabled_count=0

        for svc_name in "${service_order[@]}"; do
            svc_desc="${checked_services[$svc_name]}"
            if systemctl is-active --quiet "$svc_name" 2>/dev/null; then
                sudo systemctl disable --now "$svc_name" 2>/dev/null || true
                emit_info "Disabled $svc_desc ($svc_name)"
                disabled_count=$((disabled_count + 1))
            fi
        done

        if [ "$disabled_count" -gt 0 ]; then
            emit_pass "Disabled $disabled_count unnecessary service(s)" "Unnecessary Services"
        else
            emit_pass "No unnecessary services found to disable" "Unnecessary Services"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Unnecessary Services"
        ;;
esac
}

# --- Check: linux_user_account ---

__meta_linux_user_account() {
    case "$1" in
        name) echo "User Account" ;;
        id)   echo "linux_user_account" ;;
    esac
}

__check_linux_user_account() {
# ============================================================================
# Clawkeeper Check: Linux User Account
# Detects whether running as root and checks docker group membership.
# User creation is interactive (password input) so we emit FAIL with
# instructions rather than a prompt.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "OpenClaw should run under a non-root user to limit blast radius."

current_user=$(whoami)

if [ "$current_user" = "root" ]; then
    emit_warn "You are running as root"
    emit_info "A compromised agent running as root has full system access."

    if id "openclaw" &>/dev/null; then
        emit_info "A dedicated 'openclaw' user already exists."
        emit_info "Switch to it: su - openclaw"
        emit_fail "Running as root (switch to 'openclaw' user)" "User Account"
    else
        emit_info "To create a dedicated 'openclaw' user, run the following manually:"
        if getent group docker &>/dev/null; then
            emit_info "  useradd -m -s /bin/bash -G docker openclaw"
        else
            emit_info "  useradd -m -s /bin/bash openclaw"
        fi
        emit_info "  passwd openclaw"
        emit_info "Then grant sudo access:"
        emit_info "  echo 'openclaw ALL=(ALL) NOPASSWD:ALL' > /etc/sudoers.d/openclaw"
        emit_info "  chmod 440 /etc/sudoers.d/openclaw"
        emit_info "Create OpenClaw directories:"
        emit_info "  mkdir -p /home/openclaw/.openclaw/workspace"
        emit_info "  chown -R openclaw:openclaw /home/openclaw/.openclaw"
        emit_info "Then switch to the new user: su - openclaw"
        emit_fail "Running as root (create a dedicated 'openclaw' user)" "User Account"
    fi
else
    emit_pass "Running as non-root user: $current_user" "User Account"

    # Check docker group membership if Docker is available
    if command -v docker &>/dev/null; then
        if groups "$current_user" 2>/dev/null | grep -qw "docker"; then
            emit_pass "User is in 'docker' group" "Docker Group"
        else
            emit_warn "User is not in 'docker' group (needed for Docker deployment)"
            emit_info "To add yourself: sudo usermod -aG docker $current_user"
            emit_info "Log out and back in for group membership to take effect."
        fi
    fi
fi
}

# --- Check: location_services ---

__meta_location_services() {
    case "$1" in
        name) echo "Location Services" ;;
        id)   echo "location_services" ;;
    esac
}

__check_location_services() {
# ============================================================================
# Clawkeeper Check: Location Services
# Detects whether Location Services are enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Location data embeds in file metadata that OpenClaw might process or transmit."

ls_enabled=false

if command -v defaults &>/dev/null; then
    # Try reading without elevated access first
    ls_status=$(defaults read /var/db/locationd/Library/Preferences/ByHost/com.apple.locationd LocationServicesEnabled 2>/dev/null || echo "unknown")

    if [ "$ls_status" = "1" ]; then
        ls_enabled=true
    elif [ "$ls_status" = "0" ]; then
        ls_enabled=false
    else
        # Can't read the plist without elevated access — use launchctl as fallback
        if launchctl list 2>/dev/null | grep -q "locationd"; then
            # Service is running, likely enabled
            ls_enabled=true
        fi
    fi
fi

if [ "$ls_enabled" = false ]; then
    emit_pass "Location Services appear disabled" "Location Services"
return 0
fi

emit_warn "Location Services appear to be ENABLED"
emit_prompt "Attempt to disable Location Services?" "disable_location_services" \
    "Location Services are enabled" \
    "Location Services left enabled"
}

__remediate_location_services() {
# ============================================================================
# Clawkeeper Remediation: Location Services
# Disables Location Services on macOS (requires sudo).
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_location_services)
        sudo defaults write /var/db/locationd/Library/Preferences/ByHost/com.apple.locationd LocationServicesEnabled -bool false 2>/dev/null || true
        emit_pass "Location Services disabled" "Location Services"
        emit_info "Note: A restart may be required for this to fully take effect"
        emit_info "Verify in System Settings → Privacy & Security → Location Services"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Location Services"
        ;;
esac
}

# --- Check: mdns_bonjour ---

__meta_mdns_bonjour() {
    case "$1" in
        name) echo "mDNS / Bonjour (OpenClaw Discovery)" ;;
        id)   echo "mdns_bonjour" ;;
    esac
}

__check_mdns_bonjour() {
# ============================================================================
# Clawkeeper Check: mDNS / Bonjour (OpenClaw Discovery)
# Scans for OpenClaw mDNS broadcasts on the local network using dns-sd.
# Uses a 5-second timeout to detect any _openclaw-gw._tcp broadcasts.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "OpenClaw can broadcast its presence via mDNS. This should be disabled."
emit_info "Scanning for OpenClaw mDNS broadcasts (5 seconds)..."

# Use perl alarm to enforce a 5-second timeout on dns-sd browse
mdns_result=$(perl -e 'alarm 5; exec @ARGV' dns-sd -B _openclaw-gw._tcp 2>/dev/null || true)

if echo "$mdns_result" | grep -qi "openclaw"; then
    emit_fail "OpenClaw is broadcasting via mDNS — discoverable on the network" "mDNS"
    emit_info "Set OPENCLAW_DISABLE_BONJOUR=1 in your environment"
    emit_info "Set gateway.discover.mode = 'off' in openclaw.json"
else
    emit_pass "No OpenClaw mDNS broadcasts detected" "mDNS"
fi
}

# --- Check: native_openclaw ---

__meta_native_openclaw() {
    case "$1" in
        name) echo "OpenClaw (npm)" ;;
        id)   echo "native_openclaw" ;;
    esac
}

__check_native_openclaw() {
# ============================================================================
# Clawkeeper Check: OpenClaw (npm)
# Detects whether OpenClaw is available via global install or npx.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Checking if OpenClaw is available via npm..."

# Check direct command
if command -v openclaw &>/dev/null; then
    oc_version=$(openclaw --version 2>/dev/null || echo "unknown")
    emit_pass "OpenClaw is installed ($oc_version)" "OpenClaw npm"
return 0
fi

# Try npx
if command -v npx &>/dev/null; then
    npx_version=$(npx openclaw --version 2>/dev/null || echo "")
    if [ -n "$npx_version" ]; then
        emit_pass "OpenClaw available via npx ($npx_version)" "OpenClaw npm"
return 0
    fi
fi

# Not found
emit_warn "OpenClaw is not installed"

if ! command -v npm &>/dev/null; then
    emit_fail "npm not available — install Node.js first" "OpenClaw npm"
return 0
fi

emit_prompt "Install OpenClaw globally via npm?" "install_openclaw" \
    "OpenClaw not installed" \
    "OpenClaw not installed"
}

__remediate_native_openclaw() {
# ============================================================================
# Clawkeeper Remediation: OpenClaw (npm)
# Installs OpenClaw globally via npm.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    install_openclaw)
        emit_info "Installing openclaw..."

        npm install -g openclaw 2>&1 | tail -5 || {
            emit_fail "OpenClaw installation failed" "OpenClaw npm"
return 1
        }

        if command -v openclaw &>/dev/null; then
            new_version=$(openclaw --version 2>/dev/null || echo "installed")
            emit_pass "OpenClaw $new_version installed" "OpenClaw npm"
        else
            emit_fail "OpenClaw installed but not in PATH — restart your terminal" "OpenClaw npm"
return 1
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "OpenClaw npm"
        ;;
esac
}

# --- Check: network_isolation ---

__meta_network_isolation() {
    case "$1" in
        name) echo "Network Isolation" ;;
        id)   echo "network_isolation" ;;
    esac
}

__check_network_isolation() {
# ============================================================================
# Clawkeeper Check: Network Isolation
# Displays current network info (Wi-Fi SSID, gateway, local IP) so the user
# can manually verify this machine is on a dedicated isolated network.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Checking if this machine appears to be on an isolated network."

# Get current Wi-Fi SSID
ssid=$(networksetup -getairportnetwork en0 2>/dev/null | sed 's/Current Wi-Fi Network: //' || echo "unknown")
if [ "$ssid" = "unknown" ] || echo "$ssid" | grep -qi "not associated\|error\|not found"; then
    # Fallback to legacy airport binary (may not exist on newer macOS)
    ssid=$(/System/Library/PrivateFrameworks/Apple80211.framework/Versions/Current/Resources/airport -I 2>/dev/null | awk '/ SSID/ {print substr($0, index($0, $2))}' || echo "unknown")
fi

if [ "$ssid" != "unknown" ]; then
    emit_info "Connected to Wi-Fi: $ssid"
    emit_info "Verify this is your dedicated isolated network, not your primary Wi-Fi."
else
    emit_info "Could not determine Wi-Fi SSID"
fi

# Report gateway
gateway_ip=$(route -n get default 2>/dev/null | grep "gateway" | awk '{print $2}' || echo "unknown")
emit_info "Default gateway: $gateway_ip"

# Report local IP
local_ip=$(ipconfig getifaddr en0 2>/dev/null || ipconfig getifaddr en1 2>/dev/null || echo "unknown")
emit_info "Local IP: $local_ip"

emit_info "Manual verification required:"
emit_info "  1. Confirm this is NOT your primary network"
emit_info "  2. Test: ping a device on your primary network (should FAIL)"
emit_info "  3. Test: ping 8.8.8.8 (should SUCCEED)"

emit_pass "Network info displayed for manual verification" "Network Isolation"
}

# --- Check: node ---

__meta_node() {
    case "$1" in
        name) echo "Node.js" ;;
        id)   echo "node" ;;
    esac
}

__check_node() {
# ============================================================================
# Clawkeeper Check: Node.js
# Detects whether Node.js >= 22 is installed.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "OpenClaw requires Node.js 22 or higher."

if command -v node &>/dev/null; then
    node_version=$(node --version 2>/dev/null || echo "unknown")
    major_version=$(echo "$node_version" | sed 's/v//' | cut -d. -f1)

    if [ "$major_version" -ge 22 ] 2>/dev/null; then
        emit_pass "Node.js $node_version installed (meets v22+ requirement)" "Node.js"
return 0
    else
        emit_warn "Node.js $node_version is installed but OpenClaw needs v22+"
    fi
else
    emit_warn "Node.js is not installed"
fi

# Check if brew is available for the remediation
if ! command -v brew &>/dev/null; then
    emit_fail "Node.js 22+ not available (install Homebrew first)" "Node.js"
return 0
fi

emit_prompt "Install Node.js 22 via Homebrew?" "install_node" \
    "Node.js 22+ not installed" \
    "Node.js not installed"
}

__remediate_node() {
# ============================================================================
# Clawkeeper Remediation: Node.js
# Installs Node.js 22 via Homebrew.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    install_node)
        emit_info "Installing node@22..."

        brew install node@22 2>&1 | tail -3 || {
            emit_fail "Node.js installation failed" "Node.js"
return 1
        }

        # Link if needed
        brew link --overwrite node@22 2>/dev/null || true

        if command -v node &>/dev/null; then
            new_version=$(node --version 2>/dev/null)
            emit_pass "Node.js $new_version installed" "Node.js"
        else
            emit_fail "Node.js installed but not in PATH — restart your terminal" "Node.js"
return 1
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Node.js"
        ;;
esac
}

# --- Check: openclaw_config ---

__meta_openclaw_config() {
    case "$1" in
        name) echo "OpenClaw Configuration Audit" ;;
        id)   echo "openclaw_config" ;;
    esac
}

__check_openclaw_config() {
# ============================================================================
# Clawkeeper Check: OpenClaw Configuration Audit
# Audits ~/.openclaw directory permissions, openclaw.json file permissions,
# and key config values: gateway.bind, auth.mode, controlUI, discover.mode,
# exec.ask, redactSensitive, and credential exposure.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

config_file="$HOME/.openclaw/openclaw.json"
config_dir="$HOME/.openclaw"

# ---------- Check config directory exists ----------
if [ ! -d "$config_dir" ]; then
    emit_info "No OpenClaw config directory found (~/.openclaw)"
    emit_info "This is expected if OpenClaw isn't installed yet. Skipping config checks."
return 0
fi

# ---------- Check directory permissions ----------
dir_perms=$(stat -f "%OLp" "$config_dir" 2>/dev/null || stat -c "%a" "$config_dir" 2>/dev/null || echo "unknown")
if [ "$dir_perms" = "700" ]; then
    emit_pass "Config directory permissions are 700 (owner-only)" "Config Permissions"
else
    emit_prompt "Config directory permissions are $dir_perms — fix to 700?" \
        "fix_config_dir_perms" \
        "Config directory permissions are $dir_perms (should be 700)" \
        "Config directory permissions not changed"
fi

# ---------- Check config file exists ----------
if [ ! -f "$config_file" ]; then
    emit_info "No openclaw.json found. Skipping config content checks."
return 0
fi

# ---------- Check config file permissions ----------
file_perms=$(stat -f "%OLp" "$config_file" 2>/dev/null || stat -c "%a" "$config_file" 2>/dev/null || echo "unknown")
if [ "$file_perms" = "600" ]; then
    emit_pass "Config file permissions are 600" "Config File Permissions"
else
    emit_prompt "Config file permissions are $file_perms — fix to 600?" \
        "fix_config_file_perms" \
        "Config file permissions are $file_perms (should be 600)" \
        "Config file permissions not changed"
fi

# ---------- Parse key config values ----------
emit_info "Configuration audit:"

# gateway.bind
if grep -q '"bind".*"loopback"' "$config_file" 2>/dev/null; then
    emit_pass "gateway.bind = loopback" "gateway.bind"
elif grep -q '"bind"' "$config_file" 2>/dev/null; then
    emit_fail "gateway.bind is set but NOT to loopback" "gateway.bind"
else
    emit_warn "gateway.bind not explicitly set"
    emit_fail "gateway.bind not configured (should be 'loopback')" "gateway.bind"
fi

# gateway.auth.mode
if grep -q '"mode".*"token"' "$config_file" 2>/dev/null; then
    emit_pass "gateway.auth.mode = token" "gateway.auth"
else
    emit_fail "Token authentication not configured" "gateway.auth"
fi

# gateway.controlUI
if grep -q '"controlUI".*false' "$config_file" 2>/dev/null; then
    emit_pass "gateway.controlUI = false (web UI disabled)" "gateway.controlUI"
else
    emit_warn "gateway.controlUI may be enabled"
    emit_fail "Web control UI should be disabled (controlUI: false)" "gateway.controlUI"
fi

# gateway.discover.mode
if grep -q '"discover"' "$config_file" 2>/dev/null && grep -q '"mode".*"off"' "$config_file" 2>/dev/null; then
    emit_pass "gateway.discover.mode = off (mDNS disabled)" "gateway.discover"
else
    emit_fail "mDNS discovery should be disabled (discover.mode: off)" "gateway.discover"
fi

# exec.ask
if grep -q '"ask".*"on"' "$config_file" 2>/dev/null; then
    emit_pass "exec.ask = on (explicit consent mode)" "exec.ask"
else
    emit_fail "Explicit consent not enabled (exec.ask should be 'on')" "exec.ask"
fi

# logging.redactSensitive
if grep -q '"redactSensitive"' "$config_file" 2>/dev/null; then
    emit_pass "logging.redactSensitive is configured" "logging.redactSensitive"
else
    emit_fail "Sensitive log redaction not configured" "logging.redactSensitive"
fi

# Check for plain-text API keys in config
if grep -qiE "(api.key|api_key|apikey|sk-ant-|sk-)" "$config_file" 2>/dev/null; then
    emit_fail "CRITICAL: Possible plain-text API keys found in config file" "Credential Exposure"
    emit_info "Move API keys to environment variables or a .env file"
else
    emit_pass "No plain-text API keys detected in config" "Credential Exposure"
fi
}

__remediate_openclaw_config() {
# ============================================================================
# Clawkeeper Remediation: OpenClaw Configuration
# Fixes config directory and file permissions.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    fix_config_dir_perms)
        config_dir="$HOME/.openclaw"
        if [ -d "$config_dir" ]; then
            chmod 700 "$config_dir"
            emit_pass "Config directory set to 700" "Config Permissions"
        else
            emit_fail "Config directory not found: $config_dir" "Config Permissions"
        fi
        ;;
    fix_config_file_perms)
        config_file="$HOME/.openclaw/openclaw.json"
        if [ -f "$config_file" ]; then
            chmod 600 "$config_file"
            emit_pass "Config file set to 600" "Config File Permissions"
        else
            emit_fail "Config file not found: $config_file" "Config File Permissions"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "OpenClaw Config"
        ;;
esac
}

# --- Check: openclaw_hardening ---

__meta_openclaw_hardening() {
    case "$1" in
        name) echo "OpenClaw Hardening Audit" ;;
        id)   echo "openclaw_hardening" ;;
    esac
}

__check_openclaw_hardening() {
# ============================================================================
# Clawkeeper Check: OpenClaw Hardening Audit
# Advanced configuration checks: sandbox mode, exec host policy, DM scope,
# DM policy, filesystem restriction, and log redaction level.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

config_file="$HOME/.openclaw/openclaw.json"

if [ ! -f "$config_file" ]; then
    emit_info "No openclaw.json found — skipping hardening checks"
return 0
fi

emit_info "Advanced hardening checks:"

# ---------- Sandbox mode ----------
if grep -q '"sandbox"' "$config_file" 2>/dev/null && grep -q '"mode".*"all"' "$config_file" 2>/dev/null; then
    emit_pass "agents.defaults.sandbox.mode = all" "Sandbox Mode"
else
    emit_fail "Sandbox mode should be 'all' (agents.defaults.sandbox.mode)" "Sandbox Mode"
    emit_info "This ensures all agent actions run within the sandbox"
fi

# ---------- Exec host policy ----------
if grep -q '"exec"' "$config_file" 2>/dev/null && grep -q '"host".*"sandbox"' "$config_file" 2>/dev/null; then
    emit_pass "tools.exec.host = sandbox" "Exec Policy"
else
    emit_fail "Exec host should be 'sandbox' (not gateway/elevated)" "Exec Policy"
    emit_info "Prevents agents from executing on the gateway host directly"
fi

# ---------- DM scope ----------
if grep -q '"dmScope".*"per-channel-peer"' "$config_file" 2>/dev/null; then
    emit_pass "session.dmScope = per-channel-peer" "DM Scope"
else
    emit_fail "DM scope should be 'per-channel-peer' for isolation" "DM Scope"
fi

# ---------- DM policy ----------
if grep -q '"dmPolicy".*"pairing"' "$config_file" 2>/dev/null || grep -q '"dm".*"pairing"' "$config_file" 2>/dev/null; then
    emit_pass "DM policy = pairing (requires mutual opt-in)" "DM Policy"
else
    emit_fail "DM policy should be 'pairing' (not 'open')" "DM Policy"
    emit_info "Open DM policy allows any user to message the bot directly"
fi

# ---------- Filesystem restriction ----------
if grep -q '"workspaceOnly".*true' "$config_file" 2>/dev/null; then
    emit_pass "tools.fs.workspaceOnly = true" "Filesystem Restriction"
else
    emit_fail "Filesystem access should be restricted to workspace only" "Filesystem Restriction"
    emit_info "Set tools.fs.workspaceOnly = true in openclaw.json"
fi

# ---------- Log redaction level ----------
if grep -q '"redactSensitive".*"tools"' "$config_file" 2>/dev/null; then
    emit_pass "logging.redactSensitive = tools (full redaction)" "Log Redaction Level"
elif grep -q '"redactSensitive".*true' "$config_file" 2>/dev/null; then
    emit_warn "logging.redactSensitive is enabled but not set to 'tools'"
    emit_fail "Log redaction should be 'tools' for complete coverage" "Log Redaction Level"
else
    emit_fail "logging.redactSensitive not configured" "Log Redaction Level"
fi
}

# --- Check: openclaw_running ---

__meta_openclaw_running() {
    case "$1" in
        name) echo "OpenClaw Instance Detection" ;;
        id)   echo "openclaw_running" ;;
    esac
}

__check_openclaw_running() {
# ============================================================================
# Clawkeeper Check: OpenClaw Instance Detection
# Detects running OpenClaw instances via Docker containers, bare-metal
# processes, and port 18789 binding. If the gateway is bound to 0.0.0.0,
# it's a critical finding; 127.0.0.1 is safe.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Checking for running OpenClaw instances..."

found=false

# ---------- Check for OpenClaw Docker container ----------
if command -v docker &>/dev/null && docker info &>/dev/null 2>&1; then
    oc_containers=$(docker ps --format '{{.Names}} {{.Image}}' 2>/dev/null | grep -i "openclaw" || true)
    if [ -n "$oc_containers" ]; then
        found=true
        while IFS= read -r line; do
            emit_info "Found Docker container: $line"
        done <<< "$oc_containers"
    fi
fi

# ---------- Check for bare-metal process ----------
oc_process=$(pgrep -fl "openclaw|moltbot|clawdbot" 2>/dev/null || true)
if [ -n "$oc_process" ]; then
    found=true
    while IFS= read -r line; do
        emit_info "Found bare-metal process: $line"
    done <<< "$oc_process"
fi

# ---------- Check for gateway port 18789 ----------
port_check=""
if command -v lsof &>/dev/null; then
    port_check=$(lsof -i :18789 2>/dev/null || true)
elif command -v ss &>/dev/null; then
    port_check=$(ss -tlnp 2>/dev/null | grep ":18789" || true)
fi

if [ -n "$port_check" ]; then
    found=true
    emit_info "Port 18789 is in use"

    # Check binding address
    if echo "$port_check" | grep -q "0.0.0.0"; then
        emit_fail "Gateway bound to 0.0.0.0 (ALL interfaces) — CRITICAL" "OpenClaw Gateway"
        emit_info "This exposes the gateway to the entire network."
        emit_info "Fix: Set gateway.bind to 'loopback' in openclaw.json"
    elif echo "$port_check" | grep -q "127.0.0.1\|localhost"; then
        emit_pass "Gateway bound to localhost only" "OpenClaw Gateway"
    else
        emit_warn "Gateway binding could not be determined"
    fi
fi

if [ "$found" = false ]; then
    emit_info "No running OpenClaw instance detected"
    emit_info "This is expected if you haven't installed OpenClaw yet."
fi
}

# --- Check: remote_login ---

__meta_remote_login() {
    case "$1" in
        name) echo "Remote Login" ;;
        id)   echo "remote_login" ;;
    esac
}

__check_remote_login() {
# ============================================================================
# Clawkeeper Check: Remote Login (SSH)
# Detects whether Remote Login (SSH) is enabled on macOS via systemsetup.
# May require sudo to read the setting on some macOS versions.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "SSH is useful for managing this machine remotely. Verify it's intentional."

ssh_status=$(systemsetup -getremotelogin 2>&1 || echo "unknown")

# If the call requires admin privileges, skip — don't prompt for password
if echo "$ssh_status" | grep -qi "requires admin\|not authorized\|error"; then
    ssh_status="unknown"
fi

if echo "$ssh_status" | grep -qi "off"; then
    emit_pass "Remote Login (SSH) is off" "Remote Login"
    emit_info "Enable it if you need to manage this machine from your primary Mac."
return 0
elif echo "$ssh_status" | grep -qi "on"; then
    emit_warn "Remote Login (SSH) is ON"
    emit_info "This is expected if you manage this machine remotely."
    emit_info "Ensure only authorized keys are in ~/.ssh/authorized_keys"
    emit_pass "Remote Login (SSH) is on (verify this is intentional)" "Remote Login"
return 0
fi

# Could not determine status
emit_warn "Could not determine Remote Login status"
emit_skipped "Remote Login status unknown" "Remote Login"
}

# --- Check: screen_sharing ---

__meta_screen_sharing() {
    case "$1" in
        name) echo "Screen Sharing" ;;
        id)   echo "screen_sharing" ;;
    esac
}

__check_screen_sharing() {
# ============================================================================
# Clawkeeper Check: Screen Sharing
# Detects whether macOS Screen Sharing is enabled via launchctl.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Screen Sharing should only be enabled if you're accessing this Mac remotely."

screen_sharing=false

# Check if Screen Sharing is enabled via launchctl
if launchctl list 2>/dev/null | grep -q "com.apple.screensharing"; then
    screen_sharing=true
fi

if [ "$screen_sharing" = true ]; then
    emit_warn "Screen Sharing is ON"
    emit_info "This is expected if you access this Mac via Screen Sharing from your main Mac."
    emit_info "Ensure only authorized users have access."
    emit_pass "Screen Sharing is on (verify this is intentional)" "Screen Sharing"
else
    emit_pass "Screen Sharing is off" "Screen Sharing"
fi
}

# --- Check: siri ---

__meta_siri() {
    case "$1" in
        name) echo "Siri" ;;
        id)   echo "siri" ;;
    esac
}

__check_siri() {
# ============================================================================
# Clawkeeper Check: Siri
# Detects whether Siri and its assistant features are enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Siri indexes files, contacts, messages, and app activity locally."
emit_info "A compromised agent could query this index to enumerate sensitive data."

siri_enabled=false

# Check Siri assistant
if defaults read com.apple.assistant.support "Assistant Enabled" 2>/dev/null | grep -q "1"; then
    siri_enabled=true
fi

# Check Listen for Siri
if defaults read com.apple.Siri StatusMenuVisible 2>/dev/null | grep -q "1"; then
    siri_enabled=true
fi

if [ "$siri_enabled" = false ]; then
    emit_pass "Siri is disabled" "Siri"
return 0
fi

emit_warn "Siri is currently ENABLED"
emit_prompt "Disable Siri?" "disable_siri" "Siri is enabled" "Siri left enabled"
}

__remediate_siri() {
# ============================================================================
# Clawkeeper Remediation: Siri
# Disables Siri and related features on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_siri)
        defaults write com.apple.assistant.support "Assistant Enabled" -bool false 2>/dev/null || true
        defaults write com.apple.Siri StatusMenuVisible -bool false 2>/dev/null || true
        defaults write com.apple.Siri UserHasDeclinedEnable -bool true 2>/dev/null || true
        # Disable Siri suggestions
        defaults write com.apple.suggestions SuggestionsAllowFrom -int 0 2>/dev/null || true
        emit_pass "Siri disabled" "Siri" # FIXED status set by orchestrator
        emit_info "Note: You may need to also disable Siri in System Settings → Apple Intelligence & Siri"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Siri"
        ;;
esac
}

# --- Check: skills_security ---

__meta_skills_security() {
    case "$1" in
        name) echo "Skills Security Audit" ;;
        id)   echo "skills_security" ;;
    esac
}

__check_skills_security() {
# ============================================================================
# Clawkeeper Check: Skills Security Audit
# Scans skills directories for dangerous install commands, secret injection
# via apiKey/token/env blocks, and data exfiltration patterns.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

skills_dirs=(
    "$HOME/.openclaw/skills"
    "./skills"
)

found_skills=false

for skills_dir in "${skills_dirs[@]}"; do
    if [ ! -d "$skills_dir" ]; then
        continue
    fi
    found_skills=true

    # ---------- Check directory permissions ----------
    dir_perms=$(stat -f "%OLp" "$skills_dir" 2>/dev/null || stat -c "%a" "$skills_dir" 2>/dev/null || echo "unknown")
    if [ "$dir_perms" = "700" ]; then
        emit_pass "Skills directory ($skills_dir) permissions are 700" "Skills Directory Permissions"
    else
        emit_prompt "Skills directory ($skills_dir) permissions are $dir_perms — fix to 700?" \
            "fix_skills_dir_perms:${skills_dir}" \
            "Skills directory permissions are $dir_perms (should be 700)" \
            "Skills directory permissions not changed"
    fi

    # ---------- Scan each SKILL.md file ----------
    skill_files=$(find "$skills_dir" -name "SKILL.md" -o -name "skill.md" 2>/dev/null || true)
    if [ -z "$skill_files" ]; then
        emit_info "No SKILL.md files found in $skills_dir"
        continue
    fi

    emit_info "Scanning skills in $skills_dir:"

    install_flagged=false
    secret_flagged=false
    exfil_flagged=false

    while IFS= read -r skill_file; do
        [ -z "$skill_file" ] && continue
        skill_name=$(basename "$(dirname "$skill_file")")

        # 1. Install commands — check for dangerous patterns
        install_block=$(grep -iA5 "^install:" "$skill_file" 2>/dev/null || true)
        if [ -n "$install_block" ]; then
            if echo "$install_block" | grep -qiE 'curl\s|wget\s|eval\s|exec\s|bash\s+-c|base64|sh\s+-c|\|\s*sh|\|\s*bash'; then
                install_flagged=true
                emit_fail "CRITICAL: Skill '$skill_name' has dangerous install commands" "Skills Install Commands"
                emit_info "Found shell execution patterns in install block"
                emit_prompt "Quarantine skill '$skill_name'? (rename SKILL.md with .quarantined)" \
                    "quarantine_skill:${skill_file}" \
                    "Dangerous skill '$skill_name' not quarantined" \
                    "Skill '$skill_name' left as-is"
            fi
        fi

        # 2. Secret injection — skills using apiKey: or env: to inject secrets
        if grep -qiE '^\s*(apiKey|api_key|secret|token)\s*:' "$skill_file" 2>/dev/null; then
            secret_flagged=true
            emit_fail "Skill '$skill_name' injects secrets (apiKey/token)" "Skills Secret Injection"
            emit_info "Secrets injected via skills run in the host process context"
        fi
        if grep -qiE '^\s*env\s*:' "$skill_file" 2>/dev/null; then
            # Check if the env block references sensitive-looking vars
            env_block=$(grep -iA3 '^\s*env\s*:' "$skill_file" 2>/dev/null || true)
            if echo "$env_block" | grep -qiE 'KEY|SECRET|TOKEN|PASSWORD|CREDENTIAL'; then
                secret_flagged=true
                emit_fail "Skill '$skill_name' injects sensitive env vars" "Skills Secret Injection"
            fi
        fi

        # 3. Data exfiltration — curl/wget/nc with external URLs in body
        body_content=$(sed -n '/^---$/,/^---$/d; p' "$skill_file" 2>/dev/null || true)
        if echo "$body_content" | grep -qiE '(curl|wget|nc|ncat)\s+(https?://|[0-9]+\.[0-9]+\.[0-9]+)'; then
            exfil_flagged=true
            emit_fail "Skill '$skill_name' may exfiltrate data (external network call)" "Skills Data Exfiltration"
            emit_info "Review: $skill_file"
        fi

    done <<< "$skill_files"

    if [ "$install_flagged" = false ]; then
        emit_pass "No dangerous install commands found" "Skills Install Commands"
    fi
    if [ "$secret_flagged" = false ]; then
        emit_pass "No secret injection detected" "Skills Secret Injection"
    fi
    if [ "$exfil_flagged" = false ]; then
        emit_pass "No data exfiltration patterns found" "Skills Data Exfiltration"
    fi
done

if [ "$found_skills" = false ]; then
    emit_info "No skills directories found — skipping skills audit"
    emit_info "Checked: ~/.openclaw/skills/ and ./skills/"
fi
}

__remediate_skills_security() {
# ============================================================================
# Clawkeeper Remediation: Skills Security
# Quarantines dangerous skills by renaming SKILL.md and fixes directory perms.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    quarantine_skill:*)
        skill_file="${REMEDIATION_ID#quarantine_skill:}"
        if [ -f "$skill_file" ]; then
            skill_name=$(basename "$(dirname "$skill_file")")
            mv "$skill_file" "${skill_file}.quarantined"
            emit_pass "Skill '$skill_name' quarantined" "Skills Install Commands"
        else
            emit_fail "Skill file not found: $skill_file" "Skills Install Commands"
        fi
        ;;
    fix_skills_dir_perms:*)
        skills_dir="${REMEDIATION_ID#fix_skills_dir_perms:}"
        if [ -d "$skills_dir" ]; then
            chmod 700 "$skills_dir"
            emit_pass "Skills directory set to 700 ($skills_dir)" "Skills Directory Permissions"
        else
            emit_fail "Skills directory not found: $skills_dir" "Skills Directory Permissions"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Skills Security"
        ;;
esac
}

# --- Check: soul_security ---

__meta_soul_security() {
    case "$1" in
        name) echo "SOUL.md Security Audit" ;;
        id)   echo "soul_security" ;;
    esac
}

__check_soul_security() {
# ============================================================================
# Clawkeeper Check: SOUL.md Security Audit
# Checks SOUL.md permissions, sensitive data (credentials/PII), prompt
# injection patterns, base64-encoded blocks, invisible Unicode characters,
# and file size anomalies.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

soul_files=(
    "$HOME/.openclaw/SOUL.md"
    "./SOUL.md"
)

found_soul=false

for soul_file in "${soul_files[@]}"; do
    if [ ! -f "$soul_file" ]; then
        continue
    fi
    found_soul=true
    emit_info "Checking: $soul_file"

    # ---------- 1. Permissions — should be 600 ----------
    perms=$(stat -f "%OLp" "$soul_file" 2>/dev/null || stat -c "%a" "$soul_file" 2>/dev/null || echo "unknown")
    if [ "$perms" = "600" ]; then
        emit_pass "SOUL.md permissions are 600 ($soul_file)" "SOUL.md Permissions"
    else
        emit_prompt "SOUL.md permissions are $perms — fix to 600? ($soul_file)" \
            "fix_soul_perms:${soul_file}" \
            "SOUL.md permissions are $perms (should be 600)" \
            "SOUL.md permissions not changed"
    fi

    # ---------- 2. Sensitive data — credential/PII patterns ----------
    cred_patterns='(sk-ant-api|sk-[A-Za-z0-9]{20,}|ghp_|xoxb-|AKIA[0-9A-Z]|AIza[A-Za-z0-9]|password\s*[:=]\s*\S+)'
    soul_cred=$(grep -oiE "$cred_patterns" "$soul_file" 2>/dev/null | head -1 || true)
    if [ -n "$soul_cred" ]; then
        truncated=$(echo "$soul_cred" | cut -c1-4)
        emit_fail "Sensitive data found in SOUL.md (${truncated}****)" "SOUL.md Sensitive Data"
        emit_info "SOUL.md is loaded into every conversation — remove secrets immediately"
    else
        emit_pass "No sensitive data detected in SOUL.md" "SOUL.md Sensitive Data"
    fi

    # ---------- 3. Prompt injection / integrity ----------
    injection_hit=false

    # Check for common prompt injection patterns
    if grep -qiE '(you are now|ignore previous|disregard all|forget your instructions|new instructions|system prompt override|jailbreak)' "$soul_file" 2>/dev/null; then
        injection_hit=true
        emit_fail "Potential prompt injection detected in SOUL.md" "SOUL.md Integrity"
        emit_info "Found override/jailbreak language — review file for tampering"
    fi

    # Check for base64-encoded blocks (suspicious in a personality file)
    if grep -qE '[A-Za-z0-9+/]{40,}={0,2}$' "$soul_file" 2>/dev/null; then
        injection_hit=true
        emit_fail "Suspicious base64-encoded content in SOUL.md" "SOUL.md Integrity"
        emit_info "Base64 blocks in SOUL.md may hide malicious instructions"
    fi

    # Check for unusual Unicode (zero-width chars, RTL override, homoglyphs)
    if grep -qP '[\x{200B}-\x{200F}\x{202A}-\x{202E}\x{2060}\x{FEFF}]' "$soul_file" 2>/dev/null; then
        injection_hit=true
        emit_fail "Invisible Unicode characters found in SOUL.md" "SOUL.md Integrity"
        emit_info "Zero-width or directional override chars can hide injected text"
    fi

    if [ "$injection_hit" = false ]; then
        emit_pass "No prompt injection patterns detected" "SOUL.md Integrity"
    fi

    # ---------- 4. File size — over 10KB is suspicious ----------
    file_size=$(wc -c < "$soul_file" 2>/dev/null | tr -d ' ')
    if [ "$file_size" -gt 10240 ] 2>/dev/null; then
        emit_fail "SOUL.md is unusually large ($(( file_size / 1024 ))KB — over 10KB)" "SOUL.md Size"
        emit_info "Large SOUL.md files may contain hidden instructions or data"
    else
        emit_pass "SOUL.md size is reasonable ($(( file_size / 1024 ))KB)" "SOUL.md Size"
    fi
done

if [ "$found_soul" = false ]; then
    emit_info "No SOUL.md files found — skipping SOUL.md audit"
    emit_info "Checked: ~/.openclaw/SOUL.md and ./SOUL.md"
fi
}

__remediate_soul_security() {
# ============================================================================
# Clawkeeper Remediation: SOUL.md Security
# Fixes SOUL.md file permissions to 600.
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    fix_soul_perms:*)
        soul_file="${REMEDIATION_ID#fix_soul_perms:}"
        if [ -f "$soul_file" ]; then
            chmod 600 "$soul_file"
            emit_pass "SOUL.md set to 600 ($soul_file)" "SOUL.md Permissions"
        else
            emit_fail "SOUL.md file not found: $soul_file" "SOUL.md Permissions"
        fi
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "SOUL.md Permissions"
        ;;
esac
}

# --- Check: spotlight ---

__meta_spotlight() {
    case "$1" in
        name) echo "Spotlight Indexing" ;;
        id)   echo "spotlight" ;;
    esac
}

__check_spotlight() {
# ============================================================================
# Clawkeeper Check: Spotlight Indexing
# Detects whether Spotlight indexing is enabled on macOS.
# Outputs JSON lines to stdout.
# ============================================================================


MODE="scan"
while [[ $# -gt 0 ]]; do
    case "$1" in
        --mode) MODE="$2"; shift 2 ;;
        *) shift ;;
    esac
done

emit_info "Spotlight indexes file contents and metadata. Reduces what's queryable by a compromised agent."

spotlight_on=false

spotlight_status=$(mdutil -s / 2>/dev/null || echo "unknown")

if echo "$spotlight_status" | grep -qi "indexing enabled"; then
    spotlight_on=true
elif echo "$spotlight_status" | grep -qi "indexing disabled"; then
    spotlight_on=false
else
    # Assume it's on by default
    spotlight_on=true
fi

if [ "$spotlight_on" = false ]; then
    emit_pass "Spotlight indexing is disabled" "Spotlight Indexing"
return 0
fi

emit_warn "Spotlight indexing is ENABLED"
emit_prompt "Disable Spotlight indexing entirely?" "disable_spotlight" \
    "Spotlight indexing is enabled" \
    "Spotlight left enabled"
}

__remediate_spotlight() {
# ============================================================================
# Clawkeeper Remediation: Spotlight Indexing
# Disables Spotlight indexing on macOS (requires sudo).
# Outputs JSON lines to stdout.
# ============================================================================


REMEDIATION_ID="${1:-}"

case "$REMEDIATION_ID" in
    disable_spotlight)
        sudo mdutil -a -i off &>/dev/null || true
        emit_pass "Spotlight indexing disabled" "Spotlight Indexing"
        emit_info "Consider excluding OpenClaw directories later: System Settings → Siri & Spotlight → Spotlight Privacy"
        ;;
    *)
        emit_fail "Unknown remediation: $REMEDIATION_ID" "Spotlight Indexing"
        ;;
esac
}

# === Orchestrator ========================================================

# ============================================================================
# CLAW Keeper Orchestrator
# CLI entrypoint, phase management, grading, and non-extracted checks.
# This file is concatenated by bundle.sh — do NOT add a shebang here.
#
# By RAD Security — https://rad.security
# ============================================================================

# set -uo pipefail is added by bundle.sh

# --- Colors & Formatting ---------------------------------------------------
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
CYAN='\033[0;36m'
BOLD='\033[1m'
DIM='\033[2m'
RESET='\033[0m'

# --- Counters ---------------------------------------------------------------
PASS=0
FAIL=0
FIXED=0
SKIPPED=0
TOTAL=0

# --- State ------------------------------------------------------------------
NEEDS_SUDO=false
SUDO_AUTHENTICATED=false
INTERACTIVE=true
SCAN_ONLY=false
REPORT_FILE=""
REPORT_LINES=()
HOMEBREW_FAILED=false
CAN_INSTALL_SOFTWARE=true

# --- Platform Detection -----------------------------------------------------
PLATFORM=""
ARCH=""
MACOS_VERSION=""
DEPLOY_MODE=""
LINUX_DISTRO=""
LINUX_DISTRO_VERSION=""
LINUX_DISTRO_NAME=""
IS_VPS=false

# --- Platform Detection Function --------------------------------------------

detect_platform() {
    local kernel
    kernel=$(uname -s 2>/dev/null || echo "unknown")

    case "$kernel" in
        Darwin)
            PLATFORM="macos"
            ;;
        Linux)
            PLATFORM="linux"
            # Detect distro
            if [ -f /etc/os-release ]; then
                # shellcheck disable=SC1091
                . /etc/os-release
                LINUX_DISTRO="${ID:-unknown}"
                LINUX_DISTRO_VERSION="${VERSION_ID:-unknown}"
                LINUX_DISTRO_NAME="${PRETTY_NAME:-$ID}"
            elif [ -f /etc/debian_version ]; then
                LINUX_DISTRO="debian"
                LINUX_DISTRO_VERSION=$(cat /etc/debian_version)
                LINUX_DISTRO_NAME="Debian $LINUX_DISTRO_VERSION"
            elif [ -f /etc/redhat-release ]; then
                LINUX_DISTRO="rhel"
                LINUX_DISTRO_VERSION=$(grep -oP '\d+' /etc/redhat-release | head -1)
                LINUX_DISTRO_NAME=$(cat /etc/redhat-release)
            else
                LINUX_DISTRO="unknown"
                LINUX_DISTRO_VERSION="unknown"
                LINUX_DISTRO_NAME="Linux (unknown distro)"
            fi
            # Detect if running on a VPS/VM
            if command -v systemd-detect-virt &>/dev/null; then
                local virt_type
                virt_type=$(systemd-detect-virt 2>/dev/null || echo "none")
                if [ "$virt_type" != "none" ] && [ -n "$virt_type" ]; then
                    IS_VPS=true
                fi
            fi
            ;;
        MINGW*|MSYS*|CYGWIN*)
            echo ""
            echo -e "${CYAN}${BOLD}  Clawkeeper${RESET}"
            echo ""
            echo -e "  ${YELLOW}Clawkeeper supports macOS and Linux.${RESET}"
            echo -e "  ${DIM}Windows: install WSL2, then run Clawkeeper from within WSL.${RESET}"
            echo ""
            exit 0
            ;;
        *)
            echo ""
            echo -e "${CYAN}${BOLD}  Clawkeeper${RESET}"
            echo ""
            echo -e "  ${YELLOW}Clawkeeper supports macOS and Linux.${RESET}"
            echo -e "  ${DIM}Detected platform: $kernel${RESET}"
            echo ""
            exit 0
            ;;
    esac

    # Detect architecture
    local machine
    machine=$(uname -m 2>/dev/null || echo "unknown")
    case "$machine" in
        arm64|aarch64) ARCH="arm64" ;;
        x86_64)        ARCH="x86_64" ;;
        *)             ARCH="$machine" ;;
    esac

    # Detect OS version
    if [ "$PLATFORM" = "macos" ]; then
        MACOS_VERSION=$(sw_vers -productVersion 2>/dev/null || echo "unknown")
    fi
}

# --- Helpers ----------------------------------------------------------------
print_platform_info() {
    local arch_label="$ARCH"
    if [ "$PLATFORM" = "macos" ]; then
        [ "$ARCH" = "arm64" ] && arch_label="Apple Silicon"
        [ "$ARCH" = "x86_64" ] && arch_label="Intel"
        echo -e "  ${DIM}macOS $MACOS_VERSION ($arch_label)${RESET}"
    elif [ "$PLATFORM" = "linux" ]; then
        echo -e "  ${DIM}$LINUX_DISTRO_NAME ($arch_label)${RESET}"
        if [ "$IS_VPS" = true ]; then
            local virt_type
            virt_type=$(systemd-detect-virt 2>/dev/null || echo "")
            echo -e "  ${DIM}Virtualization: $virt_type (VPS/VM)${RESET}"
        fi
    fi
    if [ -n "$DEPLOY_MODE" ]; then
        local mode_label="Docker"
        [ "$DEPLOY_MODE" = "native" ] && mode_label="Native (npm)"
        echo -e "  ${DIM}Deployment mode: $mode_label${RESET}"
    fi
}

print_banner() {
    echo ""
    echo -e "${CYAN}${BOLD}"
    echo "   ┌────────────────────────────────────────┐"
    echo "   │                                        │"
    echo "   │        Clawkeeper Setup Wizard         │"
    echo "   │                                        │"
    echo "   │   Harden your host. Deploy securely.   │"
    echo "   │                                        │"
    echo "   └────────────────────────────────────────┘"
    echo -e "${RESET}"
    print_platform_info
}

print_scan_banner() {
    echo ""
    echo -e "${CYAN}${BOLD}"
    echo "   ┌────────────────────────────────────────┐"
    echo "   │                                        │"
    echo "   │       Clawkeeper Security Scan         │"
    echo "   │                                        │"
    echo "   └────────────────────────────────────────┘"
    echo -e "${RESET}"
    print_platform_info
}

log_result() {
    # $1 = status (PASS, FAIL, FIXED, SKIPPED)
    # $2 = step name
    # $3 = detail
    REPORT_LINES+=("$1|$2|$3")
}

# Phase tracking for per-phase summaries
PHASE_PASS=0
PHASE_FAIL=0
PHASE_FIXED=0
PHASE_SKIPPED=0

reset_phase_counters() {
    PHASE_PASS=$PASS
    PHASE_FAIL=$FAIL
    PHASE_FIXED=$FIXED
    PHASE_SKIPPED=$SKIPPED
}

print_phase_summary() {
    local p=$((PASS - PHASE_PASS))
    local x=$((FAIL - PHASE_FAIL))
    local f=$((FIXED - PHASE_FIXED))
    local s=$((SKIPPED - PHASE_SKIPPED))
    local total_in_phase=$((p + x + f + s))

    # Don't print anything if no checks ran in this phase
    if [ "$total_in_phase" -eq 0 ]; then
        return
    fi

    echo ""
    echo -ne "  ${DIM}──"
    [ "$p" -gt 0 ] && echo -ne " ${GREEN}$p passed${RESET}${DIM}"
    [ "$f" -gt 0 ] && echo -ne " ${GREEN}$f fixed${RESET}${DIM}"
    [ "$x" -gt 0 ] && echo -ne " ${RED}$x failed${RESET}${DIM}"
    [ "$s" -gt 0 ] && echo -ne " ${YELLOW}$s skipped${RESET}${DIM}"
    echo -e " ──${RESET}"
}

print_expectations() {
    echo ""
    echo -e "  ${DIM}This wizard walks you through 5 phases:${RESET}"
    echo -e "  ${DIM}  1. Host Hardening   — reduce your attack surface${RESET}"
    echo -e "  ${DIM}  2. Network          — verify network security${RESET}"
    echo -e "  ${DIM}  3. Prerequisites    — install required software${RESET}"
    echo -e "  ${DIM}  4. OpenClaw         — deploy with hardened defaults${RESET}"
    echo -e "  ${DIM}  5. Security Audit   — verify everything is locked down${RESET}"
    echo ""
    echo -e "  ${DIM}Every change requires your approval. Nothing runs without ${RESET}${BOLD}[Y/n]${RESET}${DIM}.${RESET}"
}

step_header() {
    TOTAL=$((TOTAL + 1))
    echo ""
    echo -e "${BOLD}Step ${TOTAL}: $1${RESET}"
}

pass() {
    PASS=$((PASS + 1))
    echo -e "  ${GREEN}✓${RESET} $1"
    log_result "PASS" "$2" "$1"
}

fail() {
    FAIL=$((FAIL + 1))
    echo -e "  ${RED}✗${RESET} $1"
    log_result "FAIL" "$2" "$1"
}

fixed() {
    FIXED=$((FIXED + 1))
    echo -e "  ${GREEN}✓${RESET} $1 ${DIM}(just fixed)${RESET}"
    log_result "FIXED" "$2" "$1"
    # After the 3rd fix, a subtle "at scale" hint
    if [ "$FIXED" -eq 3 ]; then
        echo -e "  ${DIM}Track drift across hosts: ${RESET}${CYAN}clawkeeper.sh agent --install${RESET}"
    fi
}

skipped() {
    SKIPPED=$((SKIPPED + 1))
    echo -e "  ${YELLOW}⊘${RESET} $1 ${DIM}(accepted risk)${RESET}"
    log_result "SKIPPED" "$2" "$1"
}

warn() {
    echo -e "  ${YELLOW}⚠${RESET} $1"
}

info() {
    echo -e "  ${DIM}→ $1${RESET}"
}

ask_yn() {
    # $1 = prompt
    # Returns 0 for yes, 1 for no
    if [ "$INTERACTIVE" = false ] || [ "$SCAN_ONLY" = true ]; then
        return 1
    fi
    local answer
    echo -ne "  ${BLUE}→${RESET} $1 ${DIM}[Y/n]${RESET} "
    read -r answer
    case "$answer" in
        [nN]|[nN][oO]) return 1 ;;
        *) return 0 ;;
    esac
}

# --- Agent (inline) --------------------------------------------------------
# Merged from cli/agent.sh — no external files needed.

AGENT_VERSION="1.0.0"
AGENT_CONFIG_DIR="$HOME/.clawkeeper"
AGENT_CONFIG_FILE="$AGENT_CONFIG_DIR/config"
AGENT_PLIST_LABEL="com.clawkeeper.agent"
AGENT_API_URL="https://clawkeeper.dev/api/v1/scans"

agent_log() {
    echo "[$(date -u +"%Y-%m-%dT%H:%M:%SZ")] $*"
}

# Report a lifecycle event to the Clawkeeper API (fire-and-forget)
report_event() {
    local event_type="$1"
    local event_hostname="${2:-$(hostname)}"

    # Load config if not already loaded
    local api_key="${CLAWKEEPER_API_KEY:-}"
    local api_url="${CLAWKEEPER_API_URL:-$AGENT_API_URL}"

    if [ -z "$api_key" ] && [ -f "$AGENT_CONFIG_FILE" ]; then
        # shellcheck disable=SC1090
        source "$AGENT_CONFIG_FILE"
        api_key="${CLAWKEEPER_API_KEY:-}"
        api_url="${CLAWKEEPER_API_URL:-$AGENT_API_URL}"
    fi

    # Silently skip if no API key
    [ -z "$api_key" ] && return 0

    # Derive events URL from scans URL
    local events_url="${api_url%/scans}/events"

    curl -s -o /dev/null \
        -X POST "$events_url" \
        -H "Authorization: Bearer $api_key" \
        -H "Content-Type: application/json" \
        -d "{\"event_type\":\"$event_type\",\"hostname\":\"$event_hostname\"}" \
        2>/dev/null &
}

agent_load_config() {
    if [ ! -f "$AGENT_CONFIG_FILE" ]; then
        echo -e "${RED}Error:${RESET} Agent not configured. Run: clawkeeper.sh agent --install"
        exit 1
    fi
    # shellcheck disable=SC1090
    source "$AGENT_CONFIG_FILE"
}

agent_generate_plist() {
    local script_path="$1"
    local dest="$HOME/Library/LaunchAgents/$AGENT_PLIST_LABEL.plist"
    mkdir -p "$HOME/Library/LaunchAgents"
    cat > "$dest" <<PLISTEOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>$AGENT_PLIST_LABEL</string>
    <key>ProgramArguments</key>
    <array>
        <string>$script_path</string>
        <string>agent</string>
        <string>run</string>
    </array>
    <key>StartInterval</key>
    <integer>3600</integer>
    <key>RunAtLoad</key>
    <true/>
    <key>StandardOutPath</key>
    <string>$HOME/.clawkeeper/agent.log</string>
    <key>StandardErrorPath</key>
    <string>$HOME/.clawkeeper/agent.err</string>
    <key>EnvironmentVariables</key>
    <dict>
        <key>PATH</key>
        <string>/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin</string>
    </dict>
</dict>
</plist>
PLISTEOF
    echo "$dest"
}

agent_generate_systemd() {
    local script_path="$1"
    local service_dir="$HOME/.config/systemd/user"
    mkdir -p "$service_dir"

    cat > "$service_dir/clawkeeper-agent.service" <<SVCEOF
[Unit]
Description=Clawkeeper Security Agent
After=network-online.target
Wants=network-online.target

[Service]
Type=oneshot
ExecStart=$script_path agent run
Environment=PATH=/usr/local/bin:/usr/bin:/bin:/usr/sbin:/sbin

[Install]
WantedBy=default.target
SVCEOF

    cat > "$service_dir/clawkeeper-agent.timer" <<TMREOF
[Unit]
Description=Run Clawkeeper agent hourly

[Timer]
OnBootSec=5min
OnUnitActiveSec=1h
Persistent=true

[Install]
WantedBy=timers.target
TMREOF

    systemctl --user daemon-reload 2>/dev/null || true
    systemctl --user enable --now clawkeeper-agent.timer 2>/dev/null || true
    echo "$service_dir/clawkeeper-agent.timer"
}

agent_install() {
    echo ""
    echo -e "${CYAN}${BOLD}  Clawkeeper Agent Setup${RESET}"
    echo ""

    # Prompt for API key (with helpful fallback if skipped)
    echo -e "  To upload scan results to your dashboard, you need an API key."
    echo -e "  Get one free at: ${CYAN}https://clawkeeper.dev/signup${RESET}"
    echo ""
    echo -e "  Enter your API key (or press Enter to scan locally without uploading):"
    printf "  > "
    read -r api_key

    if [ -z "$api_key" ]; then
        echo ""
        echo -e "  ${DIM}No API key entered. To connect later:${RESET}"
        echo -e "  ${DIM}  1. Sign up at ${RESET}${CYAN}https://clawkeeper.dev/signup${RESET}"
        echo -e "  ${DIM}  2. Run ${RESET}${CYAN}clawkeeper.sh agent --install${RESET}"
        echo ""
        echo -e "  ${DIM}To scan locally without uploading:${RESET} ${CYAN}clawkeeper.sh scan${RESET}"
        echo ""
        exit 0
    fi

    # Validate key format
    if [[ ! "$api_key" =~ ^ck_live_ ]]; then
        echo -e "  ${YELLOW}Warning:${RESET} Key doesn't start with ck_live_ — are you sure this is correct?"
        printf "  Continue? [y/N] "
        read -r confirm
        if [[ ! "$confirm" =~ ^[yY] ]]; then
            exit 1
        fi
    fi

    # Optional: custom API URL
    local api_url="${CLAWKEEPER_API_URL:-$AGENT_API_URL}"
    echo ""
    echo -e "  ${DIM}API endpoint: $api_url${RESET}"
    echo -e "  ${DIM}(Set CLAWKEEPER_API_URL env var to override)${RESET}"

    # Create config directory
    mkdir -p "$AGENT_CONFIG_DIR"

    # Write config
    cat > "$AGENT_CONFIG_FILE" <<EOF
# Clawkeeper Agent Configuration
# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")
CLAWKEEPER_API_KEY="$api_key"
CLAWKEEPER_API_URL="$api_url"
EOF
    chmod 600 "$AGENT_CONFIG_FILE"

    echo ""
    echo -e "  ${GREEN}✓${RESET} Config saved to $AGENT_CONFIG_FILE"

    # Resolve our own path for the scheduler
    local self_path
    self_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

    # Platform-specific scheduler
    if [ "$(uname -s)" = "Darwin" ]; then
        local plist_dest
        plist_dest=$(agent_generate_plist "$self_path")
        launchctl unload "$plist_dest" 2>/dev/null || true
        launchctl load "$plist_dest"
        echo -e "  ${GREEN}✓${RESET} LaunchAgent installed and loaded"
        echo -e "  ${DIM}  Runs hourly. Plist: $plist_dest${RESET}"
    elif [ "$(uname -s)" = "Linux" ]; then
        local timer_path
        timer_path=$(agent_generate_systemd "$self_path")
        echo -e "  ${GREEN}✓${RESET} Systemd user timer installed and enabled"
        echo -e "  ${DIM}  Runs hourly. Timer: $timer_path${RESET}"
    else
        echo -e "  ${YELLOW}⚠${RESET} Unsupported platform for scheduled scans."
        echo -e "  ${DIM}  The agent still works manually: clawkeeper.sh agent run${RESET}"
    fi

    # Run first scan
    echo ""
    echo -e "  ${CYAN}Running first scan...${RESET}"
    echo ""
    agent_run

    report_event "agent.installed"

    echo ""
    echo -e "  ${GREEN}${BOLD}Agent installed successfully!${RESET}"
    echo -e "  ${DIM}View your dashboard at ${RESET}${CYAN}clawkeeper.dev${RESET}"
    echo ""
}

agent_run() {
    agent_load_config

    local api_url="${CLAWKEEPER_API_URL:-$AGENT_API_URL}"
    local api_key="${CLAWKEEPER_API_KEY:-}"

    if [ -z "$api_key" ]; then
        agent_log "ERROR: No API key configured"
        exit 1
    fi

    # Resolve our own path
    local self_path
    self_path="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)/$(basename "${BASH_SOURCE[0]}")"

    # Run scan and capture report
    local report_file
    report_file=$(mktemp /tmp/clawkeeper-report.XXXXXX)

    report_event "agent.started"

    agent_log "Running clawkeeper scan..."

    # Run scan in non-interactive mode, capture output
    "$self_path" scan --report "$report_file" --non-interactive 2>/dev/null || true

    if [ ! -f "$report_file" ]; then
        agent_log "ERROR: Scan did not produce a report file"
        exit 1
    fi

    # Parse the report file
    local hostname platform os_version
    hostname=$(hostname)
    platform="unknown"
    os_version="unknown"

    case "$(uname -s)" in
        Darwin)
            platform="macos"
            os_version=$(sw_vers -productVersion 2>/dev/null || echo "unknown")
            ;;
        Linux)
            platform="linux"
            os_version=$(grep -oP 'VERSION_ID="\K[^"]+' /etc/os-release 2>/dev/null || echo "unknown")
            ;;
    esac

    # Extract metrics from the report
    local score=0 passed=0 failed=0 fixed_count=0 skipped_count=0 grade="F"

    if grep -q "^Score:" "$report_file"; then
        score=$(grep "^Score:" "$report_file" | head -1 | sed 's/Score: *\([0-9]*\).*/\1/')
    fi
    if grep -q "^Passed:" "$report_file"; then
        passed=$(grep "^Passed:" "$report_file" | head -1 | sed 's/Passed: *//')
    fi
    if grep -q "^Failed:" "$report_file"; then
        failed=$(grep "^Failed:" "$report_file" | head -1 | sed 's/Failed: *//')
    fi
    if grep -q "^Fixed:" "$report_file"; then
        fixed_count=$(grep "^Fixed:" "$report_file" | head -1 | sed 's/Fixed: *//')
    fi
    if grep -q "^Accepted risks:" "$report_file"; then
        skipped_count=$(grep "^Accepted risks:" "$report_file" | head -1 | sed 's/Accepted risks: *//')
    fi

    # Calculate grade
    if [ "$score" -ge 95 ]; then grade="A"
    elif [ "$score" -ge 85 ]; then grade="B"
    elif [ "$score" -ge 70 ]; then grade="C"
    elif [ "$score" -ge 50 ]; then grade="D"
    else grade="F"
    fi

    # Parse individual checks from report (STATUS | CHECK_NAME | DETAIL)
    local checks_json="["
    local first=true
    while IFS='|' read -r status check_name detail; do
        # Trim whitespace
        status=$(echo "$status" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        check_name=$(echo "$check_name" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')
        detail=$(echo "$detail" | sed 's/^[[:space:]]*//;s/[[:space:]]*$//')

        # Skip empty or header lines
        [ -z "$status" ] && continue
        case "$status" in PASS|FAIL|FIXED|SKIPPED) ;; *) continue ;; esac

        # Escape JSON special characters
        detail=$(printf '%s' "$detail" | sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g')
        check_name=$(printf '%s' "$check_name" | sed 's/\\/\\\\/g; s/"/\\"/g')

        if [ "$first" = true ]; then
            first=false
        else
            checks_json="$checks_json,"
        fi

        checks_json="$checks_json{\"status\":\"$status\",\"check_name\":\"$check_name\",\"detail\":\"$detail\"}"
    done < <(grep -E '^\s*(PASS|FAIL|FIXED|SKIPPED)\s*\|' "$report_file" || true)
    checks_json="$checks_json]"

    # Read raw report — escape for JSON embedding
    local raw_report
    raw_report=$(sed 's/\\/\\\\/g; s/"/\\"/g; s/	/\\t/g' "$report_file" | awk '{printf "%s\\n", $0}' | sed 's/\\n$//')

    local scanned_at
    scanned_at=$(date -u +"%Y-%m-%dT%H:%M:%SZ")

    # Build JSON payload (no jq dependency)
    # Use heredoc to avoid printf interpretation of % in report content
    local payload
    payload="{
  \"hostname\": \"$hostname\",
  \"platform\": \"$platform\",
  \"os_version\": \"$os_version\",
  \"score\": $score,
  \"grade\": \"$grade\",
  \"passed\": $passed,
  \"failed\": $failed,
  \"fixed\": $fixed_count,
  \"skipped\": $skipped_count,
  \"checks\": $checks_json,
  \"raw_report\": \"$raw_report\",
  \"scanned_at\": \"$scanned_at\",
  \"agent_version\": \"$AGENT_VERSION\"
}"

    # Upload
    agent_log "Uploading scan to $api_url..."

    local http_code
    http_code=$(curl -s -o /tmp/clawkeeper-upload-response.json -w "%{http_code}" \
        -X POST "$api_url" \
        -H "Authorization: Bearer $api_key" \
        -H "Content-Type: application/json" \
        -d "$payload" 2>/dev/null || echo "000")

    if [ "$http_code" = "200" ]; then
        agent_log "Upload successful (HTTP $http_code)"
        echo -e "  ${GREEN}✓${RESET} Scan uploaded successfully"
    else
        agent_log "Upload failed (HTTP $http_code)"
        echo -e "  ${RED}✗${RESET} Upload failed (HTTP $http_code)"
        if [ -f /tmp/clawkeeper-upload-response.json ]; then
            local err_body
            err_body=$(cat /tmp/clawkeeper-upload-response.json)
            agent_log "Response: $err_body"
            # Try to extract "error" field from JSON response
            local err_msg
            err_msg=$(echo "$err_body" | sed -n 's/.*"error" *: *"\([^"]*\)".*/\1/p')
            if [ -n "$err_msg" ]; then
                echo -e "  ${DIM}$err_msg${RESET}"
            fi
        fi
    fi

    report_event "agent.stopped"

    # Cleanup
    rm -f "$report_file" /tmp/clawkeeper-upload-response.json
}

agent_uninstall() {
    echo ""
    echo -e "${CYAN}${BOLD}  Clawkeeper Agent Uninstall${RESET}"
    echo ""

    report_event "agent.uninstalled"

    if [ "$(uname -s)" = "Darwin" ]; then
        local plist_dest="$HOME/Library/LaunchAgents/$AGENT_PLIST_LABEL.plist"
        if [ -f "$plist_dest" ]; then
            launchctl unload "$plist_dest" 2>/dev/null || true
            rm -f "$plist_dest"
            echo -e "  ${GREEN}✓${RESET} LaunchAgent removed"
        else
            echo -e "  ${DIM}No LaunchAgent found${RESET}"
        fi
    elif [ "$(uname -s)" = "Linux" ]; then
        local service_dir="$HOME/.config/systemd/user"
        if [ -f "$service_dir/clawkeeper-agent.timer" ]; then
            systemctl --user disable --now clawkeeper-agent.timer 2>/dev/null || true
            rm -f "$service_dir/clawkeeper-agent.service" "$service_dir/clawkeeper-agent.timer"
            systemctl --user daemon-reload 2>/dev/null || true
            echo -e "  ${GREEN}✓${RESET} Systemd timer removed"
        else
            echo -e "  ${DIM}No systemd timer found${RESET}"
        fi
    fi

    if [ -d "$AGENT_CONFIG_DIR" ]; then
        rm -rf "$AGENT_CONFIG_DIR"
        echo -e "  ${GREEN}✓${RESET} Config directory removed ($AGENT_CONFIG_DIR)"
    fi

    echo ""
    echo -e "  ${GREEN}Agent uninstalled.${RESET}"
    echo ""
}

agent_status() {
    echo ""
    echo -e "${CYAN}${BOLD}  Clawkeeper Agent Status${RESET}"
    echo ""

    # Config
    if [ -f "$AGENT_CONFIG_FILE" ]; then
        echo -e "  ${GREEN}✓${RESET} Config: $AGENT_CONFIG_FILE"
        # shellcheck disable=SC1090
        source "$AGENT_CONFIG_FILE"
        echo -e "  ${DIM}  API URL: ${CLAWKEEPER_API_URL:-$AGENT_API_URL}${RESET}"
        echo -e "  ${DIM}  API Key: ${CLAWKEEPER_API_KEY:0:16}...${RESET}"
    else
        echo -e "  ${RED}✗${RESET} Not configured. Run: clawkeeper.sh agent --install"
        return
    fi

    # Platform-specific scheduler status
    if [ "$(uname -s)" = "Darwin" ]; then
        local plist_dest="$HOME/Library/LaunchAgents/$AGENT_PLIST_LABEL.plist"
        if [ -f "$plist_dest" ]; then
            echo -e "  ${GREEN}✓${RESET} LaunchAgent: installed"
            local launchd_status
            launchd_status=$(launchctl list 2>/dev/null | grep "$AGENT_PLIST_LABEL" || true)
            if [ -n "$launchd_status" ]; then
                echo -e "  ${GREEN}✓${RESET} LaunchAgent: loaded"
            else
                echo -e "  ${YELLOW}⚠${RESET} LaunchAgent: not loaded"
            fi
        else
            echo -e "  ${YELLOW}⚠${RESET} LaunchAgent: not installed"
        fi
    elif [ "$(uname -s)" = "Linux" ]; then
        local timer_status
        timer_status=$(systemctl --user is-active clawkeeper-agent.timer 2>/dev/null || echo "inactive")
        if [ "$timer_status" = "active" ]; then
            echo -e "  ${GREEN}✓${RESET} Systemd timer: active"
        else
            echo -e "  ${YELLOW}⚠${RESET} Systemd timer: $timer_status"
        fi
    fi

    # Last run
    local log_file="$AGENT_CONFIG_DIR/agent.log"
    if [ -f "$log_file" ]; then
        local last_line
        last_line=$(tail -1 "$log_file")
        echo -e "  ${DIM}  Last log: $last_line${RESET}"
    fi

    echo ""
}

agent_main() {
    local subcmd="${1:-}"
    shift 2>/dev/null || true

    case "$subcmd" in
        --install|install)
            agent_install
            ;;
        run)
            agent_run
            ;;
        --uninstall|uninstall)
            agent_uninstall
            ;;
        --status|status)
            agent_status
            ;;
        --help|help|"")
            echo "Usage: clawkeeper.sh agent [--install|run|--uninstall|--status]"
            echo ""
            echo "  --install     Configure API key and install scheduled scans"
            echo "  run           Run scan and upload (used by scheduler)"
            echo "  --uninstall   Remove agent and config"
            echo "  --status      Show agent status"
            exit 1
            ;;
    esac
}

# --- Sudo helper ------------------------------------------------------------

ensure_sudo() {
    if [ "$SUDO_AUTHENTICATED" = true ]; then
        return 0
    fi
    echo ""
    echo -e "  ${YELLOW}Some fixes require administrator privileges.${RESET}"
    echo -ne "  ${BLUE}→${RESET} Enter your password if prompted: "
    echo ""
    if sudo -v 2>/dev/null; then
        SUDO_AUTHENTICATED=true
        return 0
    else
        echo -e "  ${RED}Could not get sudo access. Some fixes will be skipped.${RESET}"
        return 1
    fi
}

# --- Run Check (extracted checks dispatcher) --------------------------------
# Runs a check.sh from checks/<id>/, parses its JSON output, and renders
# terminal output using the standard pass/fail/fixed/skipped/info/warn helpers.
# For prompt actions, calls remediate.sh if the user accepts.

run_check() {
    local check_id="$1"
    local check_func="__check_${check_id}"
    local remediate_func="__remediate_${check_id}"

    # Read metadata from the __meta_<id> function (set by bundle) or fallback
    local check_name="$check_id"
    if type "__meta_${check_id}" &>/dev/null; then
        check_name=$("__meta_${check_id}" name)
    fi

    local mode="scan"
    [ "$SCAN_ONLY" != true ] && mode="setup"

    step_header "$check_name"

    # Run the check function and capture JSON output
    local json_output
    json_output=$("$check_func" --mode "$mode" 2>/dev/null)

    # Process each JSON line
    while IFS= read -r line; do
        [ -z "$line" ] && continue

        local j_status j_type j_detail j_action j_message j_rid j_fail j_skip j_check
        j_status=$(_jval "$line" "status")
        j_type=$(_jval "$line" "type")
        j_detail=$(_jval "$line" "detail")
        j_action=$(_jval "$line" "action")
        j_message=$(_jval "$line" "message")
        j_rid=$(_jval "$line" "remediation_id")
        j_fail=$(_jval "$line" "fail_detail")
        j_skip=$(_jval "$line" "skip_detail")
        j_check=$(_jval "$line" "check_name")
        [ -z "$j_check" ] && j_check="$check_name"

        if [ -n "$j_type" ]; then
            case "$j_type" in
                info) info "$j_message" ;;
                warn) warn "$j_message" ;;
            esac
        elif [ "$j_action" = "prompt" ]; then
            if ask_yn "$j_message"; then
                # Run remediation
                local rem_output
                rem_output=$("$remediate_func" "$j_rid" 2>/dev/null)
                while IFS= read -r rem_line; do
                    [ -z "$rem_line" ] && continue
                    local r_status r_type r_detail r_message r_check
                    r_status=$(_jval "$rem_line" "status")
                    r_type=$(_jval "$rem_line" "type")
                    r_detail=$(_jval "$rem_line" "detail")
                    r_message=$(_jval "$rem_line" "message")
                    r_check=$(_jval "$rem_line" "check_name")
                    [ -z "$r_check" ] && r_check="$j_check"

                    if [ -n "$r_type" ]; then
                        case "$r_type" in
                            info) info "$r_message" ;;
                            warn) warn "$r_message" ;;
                        esac
                    elif [ -n "$r_status" ]; then
                        case "$r_status" in
                            PASS)  fixed "$r_detail" "$r_check" ;;
                            FIXED) fixed "$r_detail" "$r_check" ;;
                            FAIL)  fail "$r_detail" "$r_check" ;;
                        esac
                    fi
                done <<< "$rem_output"
            else
                # User declined — FAIL in scan mode, SKIPPED in setup mode
                if [ "$SCAN_ONLY" = true ]; then
                    local fail_msg="${j_fail:-$j_message}"
                    fail "$fail_msg" "$j_check"
                else
                    local skip_msg="${j_skip:-${j_fail:-$j_message}}"
                    skipped "$skip_msg" "$j_check"
                fi
            fi
        elif [ -n "$j_status" ]; then
            case "$j_status" in
                PASS)    pass "$j_detail" "$j_check" ;;
                FAIL)    fail "$j_detail" "$j_check" ;;
                FIXED)   fixed "$j_detail" "$j_check" ;;
                SKIPPED) skipped "$j_detail" "$j_check" ;;
            esac
        fi
    done <<< "$json_output"
}

# --- Checks -----------------------------------------------------------------

# check_siri — extracted to checks/siri/{check.sh,remediate.sh}

# check_location_services — extracted to checks/location_services/

# check_bluetooth — extracted to checks/bluetooth/

# check_airdrop — extracted to checks/airdrop/

# check_analytics — extracted to checks/analytics/

# check_spotlight — extracted to checks/spotlight/

# check_firewall — extracted to checks/firewall/

# check_filevault — extracted to checks/filevault/

# check_admin_user — extracted to checks/admin_user/

# check_icloud — extracted to checks/icloud/

# check_remote_login — extracted to checks/remote_login/

# check_screen_sharing — extracted to checks/screen_sharing/

# check_automatic_login — extracted to checks/automatic_login/

# --- Admin / Install Capability Check ---------------------------------------

detect_install_capability() {
    # Determines if the current user can install software (needs admin/sudo).
    # Called before Phase 3 to warn the user early instead of failing mid-install.
    CAN_INSTALL_SOFTWARE=true

    if [ "$PLATFORM" = "macos" ]; then
        local current_user
        current_user=$(whoami)
        if ! groups "$current_user" 2>/dev/null | grep -qw "admin"; then
            # Standard (non-admin) user on macOS — cannot install via Homebrew/sudo
            CAN_INSTALL_SOFTWARE=false
        fi
    elif [ "$PLATFORM" = "linux" ]; then
        # Check if user can sudo (member of sudo/wheel group, or has NOPASSWD)
        if ! sudo -n true 2>/dev/null; then
            local current_user
            current_user=$(whoami)
            if ! groups "$current_user" 2>/dev/null | grep -qwE "sudo|wheel|admin"; then
                CAN_INSTALL_SOFTWARE=false
            fi
        fi
    fi
}

print_install_capability_warning() {
    # Shows a clear warning when a standard user can't install software,
    # with actionable instructions for what to do.
    if [ "$CAN_INSTALL_SOFTWARE" = true ]; then
        return
    fi

    local current_user
    current_user=$(whoami)

    echo ""
    echo -e "  ${YELLOW}${BOLD}Note: You're running as standard user '$current_user' (no admin/sudo).${RESET}"
    echo -e "  ${DIM}This is good for security, but installing new software requires admin.${RESET}"
    echo ""

    if [ "$PLATFORM" = "macos" ]; then
        if [ "$DEPLOY_MODE" = "native" ]; then
            echo -e "  ${DIM}To install prerequisites, ask an admin to run:${RESET}"
            echo -e "  ${CYAN}  1. Install Homebrew:  /bin/bash -c \"\$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\"${RESET}"
            echo -e "  ${CYAN}  2. Install Node.js:   brew install node@22 && brew link --overwrite node@22${RESET}"
        else
            echo -e "  ${DIM}To install Docker, ask an admin to either:${RESET}"
            echo -e "  ${CYAN}  • Download Docker Desktop from https://docker.com/products/docker-desktop${RESET}"
            echo -e "  ${CYAN}  • Or install via Homebrew: brew install --cask docker${RESET}"
        fi
        echo ""
        echo -e "  ${DIM}Then re-run this script as '$current_user' — the security checks will pass.${RESET}"
    elif [ "$PLATFORM" = "linux" ]; then
        echo -e "  ${DIM}Ask an admin to install prerequisites, then re-run as '$current_user'.${RESET}"
    fi

    echo ""
    echo -e "  ${DIM}Checking what's already available...${RESET}"
}

# --- Prerequisites ----------------------------------------------------------

# check_homebrew — extracted to checks/homebrew/

# check_node — extracted to checks/node/

# --- Deployment Mode Selection -----------------------------------------------

select_deployment_mode() {
    # For scan mode, auto-detect based on what's present
    if [ "$SCAN_ONLY" = true ]; then
        if command -v docker &>/dev/null && docker ps --format '{{.Names}}' 2>/dev/null | grep -q "openclaw"; then
            DEPLOY_MODE="docker"
        elif pgrep -fl "openclaw" &>/dev/null; then
            DEPLOY_MODE="native"
        else
            DEPLOY_MODE="docker"  # default for scan
        fi
        return
    fi

    echo ""
    echo -e "  ${BOLD}How would you like to run OpenClaw?${RESET}"
    echo ""
    echo -e "  ${CYAN}1)${RESET} Native ${DIM}(npm)${RESET}"
    echo -e "     ${DIM}Runs directly on your OS. Simpler setup, shares your filesystem.${RESET}"
    echo ""
    echo -e "  ${CYAN}2)${RESET} Docker ${DIM}(recommended)${RESET}"
    echo -e "     ${DIM}Runs in an isolated container. Limits what a compromised agent can access.${RESET}"
    echo ""
    local choice
    echo -ne "  ${BLUE}→${RESET} Enter 1 or 2 ${DIM}(default: 2)${RESET}: "
    read -r choice

    case "$choice" in
        1)
            DEPLOY_MODE="native"
            echo -e "  ${GREEN}✓${RESET} Selected: ${BOLD}Native (npm)${RESET} deployment"
            ;;
        *)
            DEPLOY_MODE="docker"
            echo -e "  ${GREEN}✓${RESET} Selected: ${BOLD}Docker${RESET} deployment"
            ;;
    esac
}

# --- Native (npm/npx) Deployment -------------------------------------------

OPENCLAW_NATIVE_DIR="$HOME/.openclaw"
OPENCLAW_NATIVE_WORKSPACE="$HOME/openclaw/workspace"

# check_native_openclaw_installed — extracted to checks/native_openclaw/

setup_native_openclaw_directories() {
    step_header "OpenClaw Directory Structure (Native)"
    info "Creating directories with secure permissions."

    for dir in "$OPENCLAW_NATIVE_DIR" "$OPENCLAW_NATIVE_WORKSPACE"; do
        if [ -d "$dir" ]; then
            local perms
            perms=$(stat -f "%OLp" "$dir" 2>/dev/null || stat -c "%a" "$dir" 2>/dev/null || echo "unknown")
            if [ "$perms" = "700" ]; then
                echo -e "  ${GREEN}✓${RESET} $dir exists (permissions: 700)"
            else
                echo -e "  ${YELLOW}⚠${RESET} $dir exists but permissions are $perms"
                chmod 700 "$dir"
                echo -e "  ${GREEN}✓${RESET} Fixed permissions to 700"
            fi
        else
            mkdir -p "$dir"
            chmod 700 "$dir"
            echo -e "  ${GREEN}✓${RESET} Created $dir (permissions: 700)"
        fi
    done

    pass "Directory structure ready" "Native Directories"
}

setup_native_env_file() {
    step_header "Environment & Secrets (.env)"
    info "API keys and tokens should live in the .env file, never in config files."

    local env_file="$OPENCLAW_NATIVE_DIR/.env"

    if [ -f "$env_file" ]; then
        info ".env file already exists at $env_file"
        local perms
        perms=$(stat -f "%OLp" "$env_file" 2>/dev/null || stat -c "%a" "$env_file" 2>/dev/null || echo "unknown")
        if [ "$perms" != "600" ]; then
            chmod 600 "$env_file"
            info "Fixed .env permissions to 600"
        fi

        if grep -q "GATEWAY_TOKEN=" "$env_file" 2>/dev/null; then
            pass ".env file exists with gateway token" "Native .env"
        else
            warn ".env exists but has no GATEWAY_TOKEN"
            local token
            token=$(generate_gateway_token)
            if [ -n "$token" ]; then
                echo "GATEWAY_TOKEN=$token" >> "$env_file"
                fixed "Generated and added GATEWAY_TOKEN" "Native .env"
                echo ""
                echo -e "  ${YELLOW}${BOLD}SAVE THIS TOKEN — you need it to connect clients:${RESET}"
                echo -e "  ${CYAN}$token${RESET}"
                echo ""
            fi
        fi

        if grep -qE "(ANTHROPIC_API_KEY|OPENAI_API_KEY)=" "$env_file" 2>/dev/null; then
            pass "LLM API key configured in .env" "Native API Key"
        else
            warn "No LLM API key found in .env"
            if ask_yn "Add your Anthropic API key now?"; then
                echo -ne "  ${BLUE}→${RESET} Paste your Anthropic API key (sk-ant-...): "
                read -rs api_key
                echo ""
                if [ -n "$api_key" ]; then
                    echo "ANTHROPIC_API_KEY=$api_key" >> "$env_file"
                    fixed "Anthropic API key added to .env" "Native API Key"
                    unset api_key
                else
                    fail "No key provided" "Native API Key"
                fi
            else
                info "You can add it later: echo 'ANTHROPIC_API_KEY=sk-ant-...' >> $env_file"
                skipped "No LLM API key configured" "Native API Key"
            fi
        fi
        return
    fi

    # Create new .env file
    info "Creating .env file with gateway token..."
    local token
    token=$(generate_gateway_token)

    if [ -z "$token" ]; then
        fail "Could not generate gateway token" "Native .env"
        return
    fi

    {
        echo "# CLAW Keeper — OpenClaw native environment"
        echo "# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        echo ""
        echo "# Gateway authentication token (required)"
        echo "GATEWAY_TOKEN=$token"
        echo ""
        echo "# LLM API key — uncomment and fill in your provider"
        echo "# ANTHROPIC_API_KEY=sk-ant-..."
        echo "# OPENAI_API_KEY=sk-..."
    } > "$env_file"

    chmod 600 "$env_file"

    echo ""
    echo -e "  ${YELLOW}${BOLD}SAVE THIS GATEWAY TOKEN — you need it to connect clients:${RESET}"
    echo -e "  ${CYAN}$token${RESET}"
    echo ""

    if ask_yn "Add your Anthropic API key now?"; then
        echo -ne "  ${BLUE}→${RESET} Paste your Anthropic API key (sk-ant-...): "
        read -rs api_key
        echo ""
        if [ -n "$api_key" ]; then
            sed -i.bak "s|# ANTHROPIC_API_KEY=sk-ant-...|ANTHROPIC_API_KEY=$api_key|" "$env_file" 2>/dev/null || {
                echo "ANTHROPIC_API_KEY=$api_key" >> "$env_file"
            }
            rm -f "${env_file}.bak"
            fixed "Anthropic API key added" "Native API Key"
            unset api_key
        else
            info "Skipped — add it later by editing $env_file"
        fi
    else
        info "Add your API key later: edit $env_file"
    fi

    fixed ".env file created (permissions: 600)" "Native .env"
}

setup_native_launchd() {
    step_header "Auto-Start (launchd)"
    info "A LaunchAgent can start OpenClaw automatically when you log in."

    local plist_dir="$HOME/Library/LaunchAgents"
    local plist_file="$plist_dir/com.openclaw.agent.plist"

    if [ -f "$plist_file" ]; then
        pass "LaunchAgent already exists at $plist_file" "LaunchAgent"
        return
    fi

    if ! ask_yn "Create a LaunchAgent to auto-start OpenClaw on login?"; then
        skipped "LaunchAgent not created" "LaunchAgent"
        return
    fi

    mkdir -p "$plist_dir"

    local openclaw_bin
    openclaw_bin=$(command -v openclaw 2>/dev/null || echo "/usr/local/bin/openclaw")

    local env_file="$OPENCLAW_NATIVE_DIR/.env"
    local gateway_token=""
    if [ -f "$env_file" ]; then
        gateway_token=$(grep "^GATEWAY_TOKEN=" "$env_file" 2>/dev/null | cut -d= -f2 || echo "")
    fi

    cat > "$plist_file" << PLIST_EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.openclaw.agent</string>
    <key>ProgramArguments</key>
    <array>
        <string>${openclaw_bin}</string>
        <string>--gateway</string>
    </array>
    <key>WorkingDirectory</key>
    <string>${OPENCLAW_NATIVE_WORKSPACE}</string>
    <key>EnvironmentVariables</key>
    <dict>
        <key>OPENCLAW_DISABLE_BONJOUR</key>
        <string>1</string>
        <key>GATEWAY_TOKEN</key>
        <string>${gateway_token}</string>
    </dict>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
    <key>StandardOutPath</key>
    <string>${HOME}/.openclaw/openclaw.log</string>
    <key>StandardErrorPath</key>
    <string>${HOME}/.openclaw/openclaw-error.log</string>
</dict>
</plist>
PLIST_EOF

    chmod 644 "$plist_file"
    fixed "LaunchAgent created at $plist_file" "LaunchAgent"
    info "It will auto-start OpenClaw next time you log in."

    if ask_yn "Load and start OpenClaw now?"; then
        launchctl load "$plist_file" 2>/dev/null || true
        info "OpenClaw is starting..."
        sleep 3
        if pgrep -f "openclaw" &>/dev/null; then
            fixed "OpenClaw is running" "LaunchAgent Start"
        else
            warn "OpenClaw may still be starting — check with: launchctl list | grep openclaw"
        fi
    fi
}

# --- Docker -----------------------------------------------------------------

# check_docker_installed — extracted to checks/docker_installed/

harden_docker_desktop() {
    # Check and fix Docker Desktop settings
    local docker_settings="$HOME/Library/Group Containers/group.com.docker/settings.json"

    if [ ! -f "$docker_settings" ]; then
        info "Docker Desktop settings file not found — using defaults"
        return
    fi

    local issues=()

    # Check telemetry
    if grep -q '"analyticsEnabled".*true' "$docker_settings" 2>/dev/null; then
        issues+=("telemetry")
    fi

    # Check resource limits (warn if very high or unlimited)
    local mem_limit
    mem_limit=$(grep -o '"memoryMiB"[[:space:]]*:[[:space:]]*[0-9]*' "$docker_settings" 2>/dev/null | grep -o '[0-9]*' || echo "0")
    if [ "$mem_limit" -gt 8192 ] 2>/dev/null; then
        issues+=("memory")
    fi

    local cpu_limit
    cpu_limit=$(grep -o '"cpus"[[:space:]]*:[[:space:]]*[0-9]*' "$docker_settings" 2>/dev/null | grep -o '[0-9]*' || echo "0")
    if [ "$cpu_limit" -gt 4 ] 2>/dev/null; then
        issues+=("cpu")
    fi

    if [ ${#issues[@]} -eq 0 ]; then
        pass "Docker Desktop settings look reasonable" "Docker Settings"
        return
    fi

    echo ""
    echo -e "  ${CYAN}Docker Desktop hardening:${RESET}"

    for issue in "${issues[@]}"; do
        case "$issue" in
            telemetry)
                warn "Docker Desktop analytics/telemetry is enabled"
                info "Disable: Docker Desktop → Settings → General → uncheck 'Send usage statistics'"
                ;;
            memory)
                warn "Docker memory limit is high (${mem_limit}MB)"
                info "Recommend 4096MB max: Docker Desktop → Settings → Resources → Memory"
                ;;
            cpu)
                warn "Docker CPU limit is high (${cpu_limit} CPUs)"
                info "Recommend 2 CPUs max: Docker Desktop → Settings → Resources → CPUs"
                ;;
        esac
    done

    fail "Docker Desktop settings need hardening (adjust manually in Docker Desktop → Settings)" "Docker Settings"
}

# check_openclaw_running — extracted to checks/openclaw_running/

# --- OpenClaw Docker Deployment ---------------------------------------------

OPENCLAW_DIR="$HOME/openclaw-docker"
OPENCLAW_CONFIG_DIR="$HOME/.openclaw"
OPENCLAW_WORKSPACE="$HOME/openclaw/workspace"

setup_openclaw_directories() {
    step_header "OpenClaw Directory Structure"
    info "Creating directories with secure permissions."

    local dirs_ok=true

    for dir in "$OPENCLAW_CONFIG_DIR" "$OPENCLAW_WORKSPACE" "$OPENCLAW_DIR"; do
        if [ -d "$dir" ]; then
            local perms
            perms=$(stat -f "%OLp" "$dir" 2>/dev/null || stat -c "%a" "$dir" 2>/dev/null || echo "unknown")
            if [ "$perms" = "700" ]; then
                echo -e "  ${GREEN}✓${RESET} $dir exists (permissions: 700)"
            else
                echo -e "  ${YELLOW}⚠${RESET} $dir exists but permissions are $perms"
                chmod 700 "$dir"
                echo -e "  ${GREEN}✓${RESET} Fixed permissions to 700"
            fi
        else
            mkdir -p "$dir"
            chmod 700 "$dir"
            echo -e "  ${GREEN}✓${RESET} Created $dir (permissions: 700)"
        fi
    done

    pass "Directory structure ready" "Directories"
}

generate_gateway_token() {
    # Generate a cryptographically strong token
    local token
    token=$(openssl rand -hex 24 2>/dev/null || LC_ALL=C tr -dc 'a-f0-9' < /dev/urandom | head -c 48 2>/dev/null || echo "")

    if [ -z "$token" ]; then
        warn "Could not generate random token"
        return 1
    fi

    echo "$token"
}

setup_env_file() {
    step_header "Environment & Secrets (.env)"
    info "API keys and tokens should live in the .env file, never in config files."

    local env_file="$OPENCLAW_DIR/.env"

    if [ -f "$env_file" ]; then
        info ".env file already exists at $env_file"
        local perms
        perms=$(stat -f "%OLp" "$env_file" 2>/dev/null || stat -c "%a" "$env_file" 2>/dev/null || echo "unknown")
        if [ "$perms" != "600" ]; then
            chmod 600 "$env_file"
            info "Fixed .env permissions to 600"
        fi

        # Check if GATEWAY_TOKEN exists
        if grep -q "GATEWAY_TOKEN=" "$env_file" 2>/dev/null; then
            pass ".env file exists with gateway token" ".env Setup"
        else
            warn ".env exists but has no GATEWAY_TOKEN"
            local token
            token=$(generate_gateway_token)
            if [ -n "$token" ]; then
                echo "GATEWAY_TOKEN=$token" >> "$env_file"
                fixed "Generated and added GATEWAY_TOKEN" ".env Setup"
                echo ""
                echo -e "  ${YELLOW}${BOLD}SAVE THIS TOKEN — you need it to connect clients:${RESET}"
                echo -e "  ${CYAN}$token${RESET}"
                echo ""
            fi
        fi

        # Check for API key
        if grep -qE "(ANTHROPIC_API_KEY|OPENAI_API_KEY)=" "$env_file" 2>/dev/null; then
            pass "LLM API key configured in .env" "API Key"
        else
            warn "No LLM API key found in .env"
            if ask_yn "Add your Anthropic API key now?"; then
                echo -ne "  ${BLUE}→${RESET} Paste your Anthropic API key (sk-ant-...): "
                read -rs api_key
                echo ""
                if [ -n "$api_key" ]; then
                    echo "ANTHROPIC_API_KEY=$api_key" >> "$env_file"
                    fixed "Anthropic API key added to .env" "API Key"
                    unset api_key
                else
                    fail "No key provided" "API Key"
                fi
            else
                info "You can add it later: echo 'ANTHROPIC_API_KEY=sk-ant-...' >> $env_file"
                skipped "No LLM API key configured" "API Key"
            fi
        fi
        return
    fi

    # Create new .env file
    info "Creating .env file with gateway token..."
    local token
    token=$(generate_gateway_token)

    if [ -z "$token" ]; then
        fail "Could not generate gateway token" ".env Setup"
        return
    fi

    echo "# CLAW Keeper — OpenClaw Docker environment" > "$env_file"
    echo "# Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")" >> "$env_file"
    echo "" >> "$env_file"
    echo "# Gateway authentication token (required)" >> "$env_file"
    echo "GATEWAY_TOKEN=$token" >> "$env_file"
    echo "" >> "$env_file"
    echo "# LLM API key — uncomment and fill in your provider" >> "$env_file"
    echo "# ANTHROPIC_API_KEY=sk-ant-..." >> "$env_file"
    echo "# OPENAI_API_KEY=sk-..." >> "$env_file"

    chmod 600 "$env_file"

    echo ""
    echo -e "  ${YELLOW}${BOLD}SAVE THIS GATEWAY TOKEN — you need it to connect clients:${RESET}"
    echo -e "  ${CYAN}$token${RESET}"
    echo ""

    if ask_yn "Add your Anthropic API key now?"; then
        echo -ne "  ${BLUE}→${RESET} Paste your Anthropic API key (sk-ant-...): "
        read -rs api_key
        echo ""
        if [ -n "$api_key" ]; then
            # Replace the placeholder line
            sed -i.bak "s|# ANTHROPIC_API_KEY=sk-ant-...|ANTHROPIC_API_KEY=$api_key|" "$env_file" 2>/dev/null || {
                echo "ANTHROPIC_API_KEY=$api_key" >> "$env_file"
            }
            rm -f "${env_file}.bak"
            fixed "Anthropic API key added" "API Key"
            unset api_key
        else
            info "Skipped — add it later by editing $env_file"
        fi
    else
        info "Add your API key later: edit $env_file"
    fi

    fixed ".env file created (permissions: 600)" ".env Setup"
}

setup_docker_compose() {
    step_header "Docker Compose Configuration"
    info "Generating hardened docker-compose.yml for OpenClaw."

    local compose_file="$OPENCLAW_DIR/docker-compose.yml"

    if [ -f "$compose_file" ]; then
        info "docker-compose.yml already exists at $compose_file"

        if ask_yn "Overwrite with hardened configuration? (backup will be saved)"; then
            cp "$compose_file" "${compose_file}.backup.$(date +%s)"
            info "Backup saved"
        else
            pass "Existing docker-compose.yml kept" "Docker Compose"
            return
        fi
    fi

    cat > "$compose_file" << 'COMPOSE_EOF'
services:
  openclaw:
    image: ghcr.io/openclaw/openclaw:latest
    container_name: openclaw
    restart: unless-stopped

    # --- Security: Run as non-root ---
    user: "1000:1000"

    # --- Security: Drop all capabilities, add only what's needed ---
    cap_drop:
      - ALL
    cap_add:
      - NET_BIND_SERVICE

    # --- Security: Prevent privilege escalation ---
    security_opt:
      - no-new-privileges:true

    # --- Security: Read-only root filesystem ---
    read_only: true

    # --- Security: Resource limits (prevent runaway agent behavior) ---
    deploy:
      resources:
        limits:
          cpus: "2.0"
          memory: 4g
        reservations:
          cpus: "0.25"
          memory: 512m

    # --- Security: Bind to localhost ONLY ---
    ports:
      - "127.0.0.1:18789:18789"
      - "127.0.0.1:18790:18790"

    # --- Volumes ---
    volumes:
      - ${HOME}/.openclaw:/home/node/.openclaw:rw
      - ${HOME}/openclaw/workspace:/home/node/.openclaw/workspace:rw

    # --- Writable tmpfs for paths that need it (read-only root FS) ---
    tmpfs:
      - /tmp:size=100m,noexec,nosuid
      - /home/node/.npm:size=100m,noexec,nosuid

    # --- Environment: Secrets injected from .env ---
    environment:
      - OPENCLAW_DISABLE_BONJOUR=1
      - OPENCLAW_GATEWAY_TOKEN=${GATEWAY_TOKEN}
      # Uncomment your LLM provider:
      # - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}
      # - OPENAI_API_KEY=${OPENAI_API_KEY}

    # --- Security: Isolated Docker network ---
    networks:
      - openclaw-isolated

    # --- Health check ---
    healthcheck:
      test: ["CMD", "curl", "-sf", "http://localhost:18789/health", "-o", "/dev/null"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 15s

networks:
  openclaw-isolated:
    driver: bridge
    internal: false  # Needs internet for LLM APIs
COMPOSE_EOF

    # Dynamically uncomment the correct API key line based on .env
    local env_file="$OPENCLAW_DIR/.env"
    if [ -f "$env_file" ]; then
        if grep -q "^ANTHROPIC_API_KEY=" "$env_file" 2>/dev/null; then
            sed -i.bak 's|# - ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}|- ANTHROPIC_API_KEY=${ANTHROPIC_API_KEY}|' "$compose_file" 2>/dev/null || true
            rm -f "${compose_file}.bak"
        fi
        if grep -q "^OPENAI_API_KEY=" "$env_file" 2>/dev/null; then
            sed -i.bak 's|# - OPENAI_API_KEY=${OPENAI_API_KEY}|- OPENAI_API_KEY=${OPENAI_API_KEY}|' "$compose_file" 2>/dev/null || true
            rm -f "${compose_file}.bak"
        fi
    fi

    fixed "Hardened docker-compose.yml generated" "Docker Compose"

    echo ""
    echo -e "  ${CYAN}Security features enabled:${RESET}"
    echo -e "  ${DIM}  • Non-root user (1000:1000)${RESET}"
    echo -e "  ${DIM}  • All capabilities dropped (only NET_BIND_SERVICE added)${RESET}"
    echo -e "  ${DIM}  • no-new-privileges enforced${RESET}"
    echo -e "  ${DIM}  • Read-only root filesystem${RESET}"
    echo -e "  ${DIM}  • CPU (2) and memory (4GB) limits${RESET}"
    echo -e "  ${DIM}  • Ports bound to 127.0.0.1 only${RESET}"
    echo -e "  ${DIM}  • tmpfs with noexec,nosuid${RESET}"
    echo -e "  ${DIM}  • Bonjour/mDNS disabled${RESET}"
    echo -e "  ${DIM}  • Isolated Docker network${RESET}"
}

setup_openclaw_config() {
    step_header "OpenClaw Security Configuration"
    info "Generating hardened openclaw.json."

    local config_file="$OPENCLAW_CONFIG_DIR/openclaw.json"

    if [ -f "$config_file" ]; then
        info "openclaw.json already exists at $config_file"

        if ask_yn "Overwrite with hardened configuration? (backup will be saved)"; then
            cp "$config_file" "${config_file}.backup.$(date +%s)"
            info "Backup saved"
        else
            pass "Existing openclaw.json kept" "OpenClaw Config"
            return
        fi
    fi

    cat > "$config_file" << 'CONFIG_EOF'
{
  "gateway": {
    "port": 18789,
    "bind": "loopback",
    "auth": {
      "mode": "token",
      "allowTailscale": false
    },
    "controlUI": false,
    "discover": {
      "mode": "off"
    }
  },
  "exec": {
    "ask": "on"
  },
  "tools": {
    "exec": {
      "applyPatch": {
        "workspaceOnly": true
      }
    }
  },
  "logging": {
    "redactSensitive": "tools"
  }
}
CONFIG_EOF

    chmod 600 "$config_file"
    fixed "Hardened openclaw.json generated (permissions: 600)" "OpenClaw Config"

    echo ""
    echo -e "  ${CYAN}Configuration:${RESET}"
    echo -e "  ${DIM}  • gateway.bind = loopback (localhost only)${RESET}"
    echo -e "  ${DIM}  • gateway.auth.mode = token (required for every connection)${RESET}"
    echo -e "  ${DIM}  • gateway.controlUI = false (web UI disabled)${RESET}"
    echo -e "  ${DIM}  • gateway.discover.mode = off (no mDNS broadcast)${RESET}"
    echo -e "  ${DIM}  • exec.ask = on (agent asks before every command)${RESET}"
    echo -e "  ${DIM}  • applyPatch.workspaceOnly = true (agent can't write outside workspace)${RESET}"
    echo -e "  ${DIM}  • logging.redactSensitive = tools (keys redacted in logs)${RESET}"
}

deploy_openclaw_docker() {
    step_header "Deploy OpenClaw Container"

    if ! command -v docker &>/dev/null || ! docker info &>/dev/null; then
        fail "Docker is not available — install and start Docker first" "Deploy"
        return
    fi

    local compose_file="$OPENCLAW_DIR/docker-compose.yml"
    if [ ! -f "$compose_file" ]; then
        fail "No docker-compose.yml found — run setup steps first" "Deploy"
        return
    fi

    # Check if already running
    if docker ps --format '{{.Names}}' 2>/dev/null | grep -q "^openclaw$"; then
        warn "OpenClaw container is already running"

        if ask_yn "Restart with current configuration?"; then
            info "Restarting container..."
            cd "$OPENCLAW_DIR" && docker compose down 2>/dev/null || true
            cd "$OPENCLAW_DIR" && docker compose up -d 2>&1 | tail -5
            fixed "OpenClaw container restarted" "Deploy"
        else
            pass "OpenClaw container running (not restarted)" "Deploy"
        fi
        return
    fi

    if ask_yn "Pull the latest OpenClaw image and start the container?"; then
        info "Pulling latest OpenClaw image..."
        cd "$OPENCLAW_DIR" && docker compose pull 2>&1 | tail -3

        info "Starting container..."
        cd "$OPENCLAW_DIR" && docker compose up -d 2>&1 | tail -5

        # Wait for healthy
        info "Waiting for OpenClaw to start (up to 30 seconds)..."
        local waited=0
        while [ $waited -lt 30 ]; do
            if docker ps --format '{{.Names}} {{.Status}}' 2>/dev/null | grep "openclaw" | grep -qi "healthy\|Up"; then
                echo ""
                fixed "OpenClaw container is running" "Deploy"

                # Show logs briefly
                echo ""
                echo -e "  ${CYAN}Recent container logs:${RESET}"
                docker logs --tail 10 openclaw 2>&1 | while read -r line; do
                    echo -e "  ${DIM}  $line${RESET}"
                done
                return
            fi
            sleep 3
            waited=$((waited + 3))
            echo -ne "  ${DIM}  Waiting... (${waited}s)${RESET}\r"
        done
        echo ""
        warn "Container started but may still be initializing"
        info "Check logs: docker logs -f openclaw"
        pass "OpenClaw container started (verify with docker logs)" "Deploy"
    else
        skipped "OpenClaw container not started" "Deploy"
    fi
}

# --- Docker Container Hardening Audit ---------------------------------------

# audit_container_security — extracted to checks/container_security/

# --- OpenClaw Config Audit (existing, enhanced) ----------------------------

# check_openclaw_config — extracted to checks/openclaw_config/

# check_env_file — extracted to checks/env_file/

# --- Deep OpenClaw Security Checks -----------------------------------------

# check_openclaw_hardening — extracted to checks/openclaw_hardening/

# check_credential_exposure — extracted to checks/credential_exposure/

# check_skills_security — extracted to checks/skills_security/

# check_soul_security — extracted to checks/soul_security/

# --- Network Checks --------------------------------------------------------

# check_network_isolation — extracted to checks/network_isolation/

# --- OpenClaw Installation Detection -----------------------------------------

OPENCLAW_INSTALLED=false
OPENCLAW_INSTALL_TYPE=""

detect_openclaw_installed() {
    OPENCLAW_INSTALLED=false
    OPENCLAW_INSTALL_TYPE=""

    # Check for Docker-based installation
    if command -v docker &>/dev/null && docker info &>/dev/null 2>&1; then
        # Running container
        if docker ps --format '{{.Names}}' 2>/dev/null | grep -q "openclaw"; then
            OPENCLAW_INSTALLED=true
            OPENCLAW_INSTALL_TYPE="docker"
            return
        fi
        # Stopped container
        if docker ps -a --format '{{.Names}}' 2>/dev/null | grep -q "openclaw"; then
            OPENCLAW_INSTALLED=true
            OPENCLAW_INSTALL_TYPE="docker"
            return
        fi
        # Image present
        if docker images --format '{{.Repository}}' 2>/dev/null | grep -qi "openclaw"; then
            OPENCLAW_INSTALLED=true
            OPENCLAW_INSTALL_TYPE="docker"
            return
        fi
    fi

    # Check for Docker Compose setup file
    if [ -f "$HOME/openclaw-docker/docker-compose.yml" ]; then
        OPENCLAW_INSTALLED=true
        OPENCLAW_INSTALL_TYPE="docker"
        return
    fi

    # Check for native npm installation
    if command -v openclaw &>/dev/null; then
        OPENCLAW_INSTALLED=true
        OPENCLAW_INSTALL_TYPE="native"
        return
    fi

    # Check for running process
    if pgrep -fl "openclaw" &>/dev/null 2>&1; then
        OPENCLAW_INSTALLED=true
        OPENCLAW_INSTALL_TYPE="native"
        return
    fi

    # Check for LaunchAgent (indicates prior native install)
    if [ -f "$HOME/Library/LaunchAgents/com.openclaw.agent.plist" ]; then
        OPENCLAW_INSTALLED=true
        OPENCLAW_INSTALL_TYPE="native"
        return
    fi
}

# check_mdns_bonjour — extracted to checks/mdns_bonjour/

# === Linux Hardening Checks =================================================

# linux_check_ssh_hardening — extracted to checks/linux_ssh_hardening/

# linux_check_firewall — extracted to checks/linux_firewall/

# linux_check_user_account — extracted to checks/linux_user_account/

# linux_check_auto_updates — extracted to checks/linux_auto_updates/

# linux_check_fail2ban — extracted to checks/linux_fail2ban/

# linux_check_unnecessary_services — extracted to checks/linux_unnecessary_services/

# linux_check_disk_encryption — extracted to checks/linux_disk_encryption/

# === Linux Network Checks ==================================================

# linux_check_network — extracted to checks/linux_network/

# linux_check_open_ports — extracted to checks/linux_open_ports/

# === Linux Prerequisites ===================================================

# linux_check_essentials — extracted to checks/linux_essentials/

# linux_check_node — extracted to checks/linux_node/

# linux_check_docker — extracted to checks/linux_docker/

# --- Report -----------------------------------------------------------------

print_report() {
    echo ""
    echo -e "${CYAN}${BOLD}════════════════════════════════════════════════════${RESET}"
    echo ""

    # Calculate grade — SKIPPED = accepted risk (not penalized like FAIL)
    local scored_checks=$((PASS + FAIL + FIXED))
    local effective_pass=$((PASS + FIXED))
    local score=0

    if [ "$scored_checks" -gt 0 ]; then
        score=$(( (effective_pass * 100) / scored_checks ))
    fi

    local grade="F"
    local grade_color="$RED"
    if [ "$score" -ge 95 ]; then
        grade="A"; grade_color="$GREEN"
    elif [ "$score" -ge 85 ]; then
        grade="B"; grade_color="$GREEN"
    elif [ "$score" -ge 70 ]; then
        grade="C"; grade_color="$YELLOW"
    elif [ "$score" -ge 50 ]; then
        grade="D"; grade_color="$YELLOW"
    fi

    echo -e "  ${BOLD}Security Grade: ${grade_color}${BOLD}$grade${RESET} ${DIM}(${score}% of checks passing)${RESET}"
    echo ""
    echo -e "  ${GREEN}✓ Passed:${RESET}  $PASS"
    if [ "$FIXED" -gt 0 ]; then
        echo -e "  ${GREEN}✓ Fixed:${RESET}   $FIXED ${DIM}(improved during this session)${RESET}"
    fi
    echo -e "  ${RED}✗ Failed:${RESET}  $FAIL"
    if [ "$SKIPPED" -gt 0 ]; then
        echo -e "  ${YELLOW}⊘ Accepted:${RESET} $SKIPPED ${DIM}(conscious risk decisions)${RESET}"
    fi
    echo ""

    if [ "$FAIL" -gt 0 ]; then
        echo -e "  ${RED}${BOLD}Failed checks:${RESET}"
        for line in "${REPORT_LINES[@]}"; do
            local status step detail
            status=$(echo "$line" | cut -d'|' -f1)
            step=$(echo "$line" | cut -d'|' -f2)
            detail=$(echo "$line" | cut -d'|' -f3)
            if [ "$status" = "FAIL" ]; then
                echo -e "    ${RED}✗${RESET} ${BOLD}[$step]${RESET} $detail"
            fi
        done
        echo ""
    fi

    if [ "$SKIPPED" -gt 0 ]; then
        echo -e "  ${YELLOW}Accepted risks:${RESET}"
        for line in "${REPORT_LINES[@]}"; do
            local status step detail
            status=$(echo "$line" | cut -d'|' -f1)
            step=$(echo "$line" | cut -d'|' -f2)
            detail=$(echo "$line" | cut -d'|' -f3)
            if [ "$status" = "SKIPPED" ]; then
                echo -e "    ${YELLOW}⊘${RESET} [$step] $detail"
            fi
        done
        echo ""
    fi

    echo -e "${CYAN}${BOLD}════════════════════════════════════════════════════${RESET}"

    if [ "$FAIL" -gt 0 ]; then
        echo ""
        echo -e "  Run ${CYAN}${BOLD}$(basename "$0") setup${RESET} to fix failed checks interactively."
    fi

    if [ "$PLATFORM" = "linux" ] && [ "$IS_VPS" = true ]; then
        echo ""
        local vps_ip
        vps_ip=$(curl -sf --max-time 3 https://ifconfig.me 2>/dev/null || echo "your-vps-ip")
        echo -e "  ${CYAN}VPS access:${RESET} ${DIM}ssh -N -L 18789:127.0.0.1:18789 user@${vps_ip}${RESET}"
    fi

    # CTA: check if agent is actually connected (has API key), not just config file
    echo ""
    local has_api_key=false
    if [ -f "$AGENT_CONFIG_FILE" ] && grep -q 'CLAWKEEPER_API_KEY="ck_' "$AGENT_CONFIG_FILE" 2>/dev/null; then
        has_api_key=true
    fi

    if [ "$has_api_key" = true ]; then
        echo -e "  ${GREEN}✓${RESET} Agent connected — view your dashboard at ${CYAN}clawkeeper.dev${RESET}"
    else
        echo -e "  Track your score over time with a free dashboard:"
        echo -e "  → Sign up at ${CYAN}https://clawkeeper.dev/signup${RESET}"
        echo -e "  → Then run ${CYAN}clawkeeper.sh agent --install${RESET} to connect"
    fi
    echo ""
}

save_report() {
    if [ -z "$REPORT_FILE" ]; then
        return
    fi

    local os_info
    if [ "$PLATFORM" = "macos" ]; then
        os_info="macOS $(sw_vers -productVersion 2>/dev/null || echo 'unknown')"
    elif [ "$PLATFORM" = "linux" ]; then
        os_info="$LINUX_DISTRO_NAME"
    else
        os_info="$PLATFORM"
    fi

    local scored_checks=$((PASS + FAIL + FIXED))
    local effective_pass=$((PASS + FIXED))
    local score=0
    if [ "$scored_checks" -gt 0 ]; then
        score=$(( (effective_pass * 100) / scored_checks ))
    fi

    {
        echo "CLAW Keeper Security Report"
        echo "Generated: $(date -u +"%Y-%m-%dT%H:%M:%SZ")"
        echo "Hostname: $(hostname)"
        echo "OS: $os_info"
        echo "User: $(whoami)"
        echo ""
        echo "---"
        echo ""
        echo "Score: ${score}%"
        echo "Passed: $PASS"
        echo "Fixed: $FIXED"
        echo "Failed: $FAIL"
        echo "Accepted risks: $SKIPPED"
        echo ""
        echo "---"
        echo ""

        for line in "${REPORT_LINES[@]}"; do
            local status step detail
            status=$(echo "$line" | cut -d'|' -f1)
            step=$(echo "$line" | cut -d'|' -f2)
            detail=$(echo "$line" | cut -d'|' -f3)
            printf "%-8s | %-25s | %s\n" "$status" "$step" "$detail"
        done

        echo ""
        echo "---"
        echo ""
        echo "This is a point-in-time snapshot. Settings drift over time."
        echo "For continuous monitoring, drift detection, and compliance reporting:"
        echo "https://clawkeeper.dev"
    } > "$REPORT_FILE"

    echo -e "  ${DIM}Report saved to: $REPORT_FILE${RESET}"
}

# --- Secure Uninstall -------------------------------------------------------

uninstall_openclaw() {
    print_banner
    echo ""
    echo -e "  ${RED}${BOLD}OpenClaw Secure Removal${RESET}"
    echo ""
    echo -e "  ${DIM}This will permanently remove OpenClaw and securely wipe sensitive data.${RESET}"
    echo -e "  ${DIM}Every step requires your confirmation. Nothing runs without ${RESET}${BOLD}[Y/n]${RESET}${DIM}.${RESET}"
    echo ""

    detect_platform

    # Detect what's installed
    detect_openclaw_installed

    if [ "$OPENCLAW_INSTALLED" = false ]; then
        echo -e "  ${YELLOW}⚠${RESET} No OpenClaw installation detected."
        echo ""
        echo -e "  ${DIM}Checked: Docker containers/images, npm global, LaunchAgents, processes${RESET}"
        echo ""
        if ! ask_yn "Continue anyway to clean up leftover config/data files?"; then
            echo -e "  ${DIM}Nothing to do. Exiting.${RESET}"
            exit 0
        fi
    fi

    local removed_something=false

    # ── Step 1: Stop running instances ──
    echo ""
    echo -e "  ${CYAN}${BOLD}── Step 1: Stop Running Instances ──${RESET}"

    # Docker containers
    if command -v docker &>/dev/null && docker info &>/dev/null 2>&1; then
        local running_containers
        running_containers=$(docker ps --format '{{.Names}}' 2>/dev/null | grep -i "openclaw" || true)
        if [ -n "$running_containers" ]; then
            echo -e "  ${YELLOW}⚠${RESET} Found running OpenClaw containers:"
            echo "$running_containers" | while read -r c; do echo -e "    ${DIM}$c${RESET}"; done
            if ask_yn "Stop these containers?"; then
                echo "$running_containers" | while read -r c; do
                    docker stop "$c" 2>/dev/null && echo -e "  ${GREEN}✓${RESET} Stopped container: $c"
                done
                removed_something=true
            fi
        else
            echo -e "  ${DIM}→ No running OpenClaw containers${RESET}"
        fi
    fi

    # Native processes
    local oc_pids
    oc_pids=$(pgrep -f "openclaw" 2>/dev/null || true)
    if [ -n "$oc_pids" ]; then
        echo -e "  ${YELLOW}⚠${RESET} Found OpenClaw processes:"
        ps -p "$(echo "$oc_pids" | tr '\n' ',')" -o pid,command 2>/dev/null | tail -n +2 | while read -r line; do
            echo -e "    ${DIM}$line${RESET}"
        done
        if ask_yn "Kill these processes?"; then
            echo "$oc_pids" | while read -r pid; do
                kill "$pid" 2>/dev/null && echo -e "  ${GREEN}✓${RESET} Killed PID $pid"
            done
            sleep 1
            # Force kill any survivors
            local remaining
            remaining=$(pgrep -f "openclaw" 2>/dev/null || true)
            if [ -n "$remaining" ]; then
                echo "$remaining" | while read -r pid; do
                    kill -9 "$pid" 2>/dev/null || true
                done
                echo -e "  ${GREEN}✓${RESET} Force-killed remaining processes"
            fi
            removed_something=true
        fi
    else
        echo -e "  ${DIM}→ No running OpenClaw processes${RESET}"
    fi

    # ── Step 2: Remove LaunchAgent (macOS) ──
    if [ "$PLATFORM" = "macos" ]; then
        echo ""
        echo -e "  ${CYAN}${BOLD}── Step 2: Remove LaunchAgents ──${RESET}"

        local plist_file="$HOME/Library/LaunchAgents/com.openclaw.agent.plist"
        if [ -f "$plist_file" ]; then
            echo -e "  ${YELLOW}⚠${RESET} Found LaunchAgent: $plist_file"
            if ask_yn "Unload and remove this LaunchAgent?"; then
                launchctl unload "$plist_file" 2>/dev/null || true
                rm -f "$plist_file"
                echo -e "  ${GREEN}✓${RESET} LaunchAgent unloaded and removed"
                removed_something=true
            fi
        else
            echo -e "  ${DIM}→ No OpenClaw LaunchAgent found${RESET}"
        fi
    fi

    # ── Step 3: Remove Docker resources ──
    if command -v docker &>/dev/null && docker info &>/dev/null 2>&1; then
        echo ""
        echo -e "  ${CYAN}${BOLD}── Step 3: Remove Docker Resources ──${RESET}"

        # Containers (stopped)
        local all_containers
        all_containers=$(docker ps -a --format '{{.Names}}' 2>/dev/null | grep -i "openclaw" || true)
        if [ -n "$all_containers" ]; then
            echo -e "  ${YELLOW}⚠${RESET} Found OpenClaw containers (including stopped):"
            echo "$all_containers" | while read -r c; do echo -e "    ${DIM}$c${RESET}"; done
            if ask_yn "Remove these containers?"; then
                echo "$all_containers" | while read -r c; do
                    docker rm -f "$c" 2>/dev/null && echo -e "  ${GREEN}✓${RESET} Removed container: $c"
                done
                removed_something=true
            fi
        else
            echo -e "  ${DIM}→ No OpenClaw containers to remove${RESET}"
        fi

        # Images
        local oc_images
        oc_images=$(docker images --format '{{.Repository}}:{{.Tag}} ({{.ID}})' 2>/dev/null | grep -i "openclaw" || true)
        if [ -n "$oc_images" ]; then
            echo -e "  ${YELLOW}⚠${RESET} Found OpenClaw images:"
            echo "$oc_images" | while read -r img; do echo -e "    ${DIM}$img${RESET}"; done
            if ask_yn "Remove these images?"; then
                docker images --format '{{.ID}} {{.Repository}}' 2>/dev/null | grep -i "openclaw" | awk '{print $1}' | while read -r id; do
                    docker rmi -f "$id" 2>/dev/null && echo -e "  ${GREEN}✓${RESET} Removed image: $id"
                done
                removed_something=true
            fi
        else
            echo -e "  ${DIM}→ No OpenClaw images to remove${RESET}"
        fi

        # Volumes
        local oc_volumes
        oc_volumes=$(docker volume ls --format '{{.Name}}' 2>/dev/null | grep -i "openclaw" || true)
        if [ -n "$oc_volumes" ]; then
            echo -e "  ${YELLOW}⚠${RESET} Found OpenClaw volumes:"
            echo "$oc_volumes" | while read -r v; do echo -e "    ${DIM}$v${RESET}"; done
            if ask_yn "Remove these volumes? (DATA WILL BE LOST)"; then
                echo "$oc_volumes" | while read -r v; do
                    docker volume rm "$v" 2>/dev/null && echo -e "  ${GREEN}✓${RESET} Removed volume: $v"
                done
                removed_something=true
            fi
        else
            echo -e "  ${DIM}→ No OpenClaw volumes to remove${RESET}"
        fi
    fi

    # ── Step 4: Remove npm global package ──
    echo ""
    echo -e "  ${CYAN}${BOLD}── Step 4: Remove npm Package ──${RESET}"

    if command -v openclaw &>/dev/null; then
        echo -e "  ${YELLOW}⚠${RESET} OpenClaw is installed globally via npm"
        if ask_yn "Uninstall openclaw npm package?"; then
            npm uninstall -g openclaw 2>&1 | tail -3
            if ! command -v openclaw &>/dev/null; then
                echo -e "  ${GREEN}✓${RESET} OpenClaw npm package removed"
            else
                echo -e "  ${YELLOW}⚠${RESET} openclaw still in PATH — may need manual removal"
            fi
            removed_something=true
        fi
    else
        echo -e "  ${DIM}→ No global OpenClaw npm package found${RESET}"
    fi

    # ── Step 5: Securely wipe data directories ──
    echo ""
    echo -e "  ${CYAN}${BOLD}── Step 5: Secure Data Wipe ──${RESET}"
    echo ""
    echo -e "  ${DIM}The following directories may contain secrets, session logs, and config:${RESET}"

    local data_dirs=(
        "$HOME/.openclaw"
        "$HOME/openclaw-docker"
        "$HOME/openclaw"
    )

    local dirs_to_wipe=()
    for dir in "${data_dirs[@]}"; do
        if [ -d "$dir" ]; then
            local dir_size
            dir_size=$(du -sh "$dir" 2>/dev/null | awk '{print $1}' || echo "?")
            echo -e "  ${YELLOW}⚠${RESET} $dir (${dir_size})"
            dirs_to_wipe+=("$dir")
        fi
    done

    if [ ${#dirs_to_wipe[@]} -eq 0 ]; then
        echo -e "  ${DIM}→ No OpenClaw data directories found${RESET}"
    else
        echo ""
        echo -e "  ${RED}${BOLD}WARNING: This permanently deletes all OpenClaw data including:${RESET}"
        echo -e "  ${DIM}  • Configuration files (openclaw.json, .env)${RESET}"
        echo -e "  ${DIM}  • Session logs and conversation history${RESET}"
        echo -e "  ${DIM}  • MEMORY.md, SOUL.md, skills${RESET}"
        echo -e "  ${DIM}  • API keys and credentials stored in these directories${RESET}"
        echo ""

        if ask_yn "Securely wipe these directories? (THIS CANNOT BE UNDONE)"; then
            for dir in "${dirs_to_wipe[@]}"; do
                echo -e "  ${DIM}→ Wiping $dir...${RESET}"

                # Overwrite sensitive files before deletion
                # Find files that likely contain secrets and overwrite them
                while IFS= read -r sensitive_file; do
                    [ -z "$sensitive_file" ] && continue
                    if [ -f "$sensitive_file" ]; then
                        local fsize
                        fsize=$(wc -c < "$sensitive_file" 2>/dev/null | tr -d ' ')
                        if [ "$fsize" -gt 0 ] 2>/dev/null; then
                            dd if=/dev/urandom bs=1 count="$fsize" of="$sensitive_file" conv=notrunc 2>/dev/null || true
                        fi
                    fi
                done < <(find "$dir" -type f \( \
                    -name "*.json" -o -name "*.jsonl" -o -name ".env" -o \
                    -name "*.md" -o -name "*.yml" -o -name "*.yaml" -o \
                    -name "*.pem" -o -name "*.key" -o -name "*.token" -o \
                    -name "*.log" -o -name "*.sqlite" -o -name "*.db" \
                \) 2>/dev/null)

                # Remove the directory
                rm -rf "$dir"

                if [ ! -d "$dir" ]; then
                    echo -e "  ${GREEN}✓${RESET} Securely wiped: $dir"
                else
                    echo -e "  ${RED}✗${RESET} Failed to remove: $dir"
                fi
            done
            removed_something=true
        else
            echo -e "  ${DIM}→ Data directories preserved${RESET}"
        fi
    fi

    # ── Step 6: Clean up docker-compose file ──
    local compose_file="$HOME/openclaw-docker/docker-compose.yml"
    if [ -f "$compose_file" ]; then
        # Already handled above in data dirs, but just in case
        :
    fi

    # ── Summary ──
    echo ""
    echo -e "  ${CYAN}${BOLD}════════════════════════════════════════════════════${RESET}"
    echo ""
    if [ "$removed_something" = true ]; then
        echo -e "  ${GREEN}${BOLD}OpenClaw removal complete.${RESET}"
        echo ""
        echo -e "  ${DIM}What was cleaned:${RESET}"
        echo -e "  ${DIM}  • Running processes and containers stopped${RESET}"
        echo -e "  ${DIM}  • Docker images/volumes/containers removed${RESET}"
        echo -e "  ${DIM}  • LaunchAgents unloaded${RESET}"
        echo -e "  ${DIM}  • Sensitive files overwritten before deletion${RESET}"
        echo -e "  ${DIM}  • Data directories removed${RESET}"
    else
        echo -e "  ${DIM}No changes were made.${RESET}"
    fi
    echo ""
    echo -e "  ${DIM}Remaining manual steps (if applicable):${RESET}"
    echo -e "  ${DIM}  • Check shell history for pasted API keys: history | grep sk-${RESET}"
    echo -e "  ${DIM}  • Revoke any API keys generated for OpenClaw${RESET}"
    echo -e "  ${DIM}  • Remove any firewall rules added for OpenClaw${RESET}"
    echo ""
}

# --- Main -------------------------------------------------------------------

usage() {
    local prog
    prog=$(basename "$0")
    echo "Usage: $prog [command] [options]"
    echo ""
    echo "Commands:"
    echo "  setup       Guided wizard: harden host + install OpenClaw (default)"
    echo "  deploy      Force full deployment even if already installed"
    echo "  scan        Read-only security audit (no changes, just a report)"
    echo "  uninstall   Securely remove OpenClaw and wipe sensitive data"
    echo "  agent       Manage the Clawkeeper SaaS agent"
    echo "  help        Show this help"
    echo ""
    echo "Deployment modes (chosen interactively):"
    echo "  native      Run OpenClaw directly via npm — simpler"
    echo "  docker      Run OpenClaw in Docker — better isolation (recommended)"
    echo ""
    echo "Options:"
    echo "  --non-interactive    Don't prompt for fixes (same as scan)"
    echo "  --report FILE        Save report to FILE"
    echo ""
    echo "Examples:"
    echo "  $prog setup              # Interactive hardening wizard"
    echo "  $prog deploy             # Full install + deployment"
    echo "  $prog scan               # Read-only security audit"
    echo "  $prog scan --report r.txt # Audit with saved report"
    echo "  $prog uninstall          # Securely remove OpenClaw"
    echo "  $prog agent --install    # Install SaaS monitoring agent"
    echo "  $prog agent --status     # Check agent status"
    echo ""
}

main() {
    local command="${1:-start}"

    # Save all args after command for agent passthrough
    local agent_args=()
    shift 2>/dev/null || true
    agent_args=("$@")

    # Agent command handles its own args — skip main's parse loop
    if [ "$command" != "agent" ]; then
        while [[ $# -gt 0 ]]; do
            case "$1" in
                --non-interactive)
                    INTERACTIVE=false
                    ;;
                --report)
                    shift
                    REPORT_FILE="${1:-}"
                    ;;
                --help|-h)
                    usage
                    exit 0
                    ;;
                *)
                    ;;
            esac
            shift 2>/dev/null || true
        done
    fi

    # Detect platform before anything else
    detect_platform

    case "$command" in
        start)
            # Interactive menu — default when no command given
            print_banner
            echo ""
            echo -e "  What would you like to do?"
            echo ""
            echo -e "  ${BOLD}1)${RESET} ${CYAN}Scan existing OpenClaw${RESET}  — audit your current installation (read-only)"
            echo -e "  ${BOLD}2)${RESET} ${CYAN}Deploy OpenClaw securely${RESET} — full setup wizard with hardened defaults"
            echo -e "  ${BOLD}3)${RESET} ${RED}Uninstall OpenClaw${RESET}      — securely remove and wipe all data"
            echo ""
            printf "  Choose [1/2/3]: "
            read -r choice
            case "$choice" in
                2)
                    command="setup"
                    SCAN_ONLY=false
                    INTERACTIVE=true
                    print_expectations
                    select_deployment_mode
                    ;;
                3)
                    uninstall_openclaw
                    exit 0
                    ;;
                *)
                    command="scan"
                    SCAN_ONLY=true
                    INTERACTIVE=false
                    echo ""
                    echo -e "  ${DIM}Read-only audit. No changes will be made.${RESET}"
                    select_deployment_mode
                    ;;
            esac
            ;;
        setup|deploy)
            SCAN_ONLY=false
            INTERACTIVE=true
            print_banner
            print_expectations
            select_deployment_mode
            ;;
        scan)
            SCAN_ONLY=true
            INTERACTIVE=false
            print_scan_banner
            select_deployment_mode
            echo -e "  ${DIM}Read-only audit. No changes will be made.${RESET}"
            ;;
        uninstall|remove)
            uninstall_openclaw
            exit 0
            ;;
        agent)
            agent_main "${agent_args[@]+"${agent_args[@]}"}"
            exit 0
            ;;
        help|--help|-h)
            usage
            exit 0
            ;;
        *)
            echo "Unknown command: $command"
            usage
            exit 1
            ;;
    esac

    # ── Phase 1 of 5: Host Hardening ──
    reset_phase_counters
    echo ""
    if [ "$PLATFORM" = "macos" ]; then
        echo -e "${CYAN}${BOLD}═══ Phase 1 of 5: macOS Host Hardening ═══${RESET}"
        run_check "siri"
        run_check "location_services"
        run_check "bluetooth"
        run_check "airdrop"
        run_check "analytics"
        run_check "spotlight"
        run_check "firewall"
        run_check "filevault"
        run_check "admin_user"
        run_check "icloud"
        run_check "automatic_login"
    elif [ "$PLATFORM" = "linux" ]; then
        echo -e "${CYAN}${BOLD}═══ Phase 1 of 5: Linux Host Hardening ═══${RESET}"
        run_check "linux_user_account"
        run_check "linux_ssh_hardening"
        run_check "linux_firewall"
        run_check "linux_auto_updates"
        run_check "linux_fail2ban"
        run_check "linux_unnecessary_services"
        run_check "linux_disk_encryption"
    fi
    print_phase_summary
    echo -e "  ${DIM}These settings can drift. Track them: ${RESET}${CYAN}clawkeeper.sh agent --install${RESET}"

    # ── Phase 2 of 5: Network ──
    reset_phase_counters
    echo ""
    echo -e "${CYAN}${BOLD}═══ Phase 2 of 5: Network ═══${RESET}"

    if [ "$PLATFORM" = "macos" ]; then
        run_check "network_isolation"
        run_check "screen_sharing"
        run_check "remote_login"
        run_check "mdns_bonjour"
    elif [ "$PLATFORM" = "linux" ]; then
        run_check "linux_network"
        run_check "linux_open_ports"
    fi
    print_phase_summary

    # ── Phase 3 of 5: Prerequisites ──
    reset_phase_counters
    detect_install_capability
    echo ""
    if [ "$PLATFORM" = "macos" ]; then
        print_install_capability_warning
        if [ "$DEPLOY_MODE" = "native" ]; then
            echo -e "${CYAN}${BOLD}═══ Phase 3 of 5: Prerequisites (Homebrew + Node.js) ═══${RESET}"
            run_check "homebrew"
            if ! command -v brew &>/dev/null; then
                # Node.js install depends on Homebrew — skip with clear guidance
                step_header "Node.js"
                info "Skipped — Homebrew is required to install Node.js."
                fail "Node.js 22+ not available (Homebrew required)" "Node.js"
            else
                run_check "node"
            fi
        else
            echo -e "${CYAN}${BOLD}═══ Phase 3 of 5: Prerequisites (Docker) ═══${RESET}"
            # Docker mode: only Docker is needed (OpenClaw runs inside the container)
            # Check if Docker is already installed before requiring Homebrew
            if command -v docker &>/dev/null; then
                run_check "docker_installed"
            else
                # Need Homebrew to install Docker Desktop
                run_check "homebrew"
                if ! command -v brew &>/dev/null; then
                    step_header "Docker Desktop"
                    info "Skipped — Homebrew is required to install Docker Desktop."
                    info "Alternatively, download Docker Desktop directly from https://docker.com/products/docker-desktop"
                    fail "Docker not available (install Homebrew or download Docker Desktop directly)" "Docker"
                else
                    run_check "docker_installed"
                fi
            fi
        fi
    elif [ "$PLATFORM" = "linux" ]; then
        print_install_capability_warning
        if [ "$DEPLOY_MODE" = "native" ]; then
            echo -e "${CYAN}${BOLD}═══ Phase 3 of 5: Prerequisites (Node.js) ═══${RESET}"
            run_check "linux_essentials"
            run_check "linux_node"
        else
            echo -e "${CYAN}${BOLD}═══ Phase 3 of 5: Prerequisites (Docker) ═══${RESET}"
            # Docker mode on Linux: check Docker first, Node.js not needed
            if command -v docker &>/dev/null; then
                run_check "linux_docker"
            else
                run_check "linux_essentials"
                run_check "linux_docker"
            fi
        fi
    fi
    print_phase_summary

    # If prerequisites failed because user can't install software, show clear next steps
    if [ "$CAN_INSTALL_SOFTWARE" = false ] && [ "$FAIL" -gt "$PHASE_FAIL" ]; then
        echo ""
        echo -e "  ${YELLOW}${BOLD}What to do next:${RESET}"
        if [ "$PLATFORM" = "macos" ]; then
            echo -e "  ${DIM}1. Log into an admin account on this Mac${RESET}"
            if [ "$DEPLOY_MODE" = "native" ]; then
                echo -e "  ${DIM}2. Install Homebrew and Node.js (see commands above)${RESET}"
            else
                echo -e "  ${DIM}2. Install Docker Desktop (see options above)${RESET}"
            fi
            echo -e "  ${DIM}3. Log back in as '$(whoami)' and re-run this script${RESET}"
        else
            echo -e "  ${DIM}1. Ask an admin to install the required packages${RESET}"
            echo -e "  ${DIM}2. Re-run this script${RESET}"
        fi
    fi

    # ── Phase 4 of 5: OpenClaw Installation & Deployment ──
    reset_phase_counters
    detect_openclaw_installed

    if [ "$command" = "scan" ]; then
        # Scan mode: report installation status only
        echo ""
        echo -e "${CYAN}${BOLD}═══ Phase 4 of 5: OpenClaw Installation Status ═══${RESET}"
        step_header "OpenClaw Detection"
        if [ "$OPENCLAW_INSTALLED" = true ]; then
            local install_label="native (npm)"
            [ "$OPENCLAW_INSTALL_TYPE" = "docker" ] && install_label="Docker"
            pass "OpenClaw is installed ($install_label)" "OpenClaw Detection"
        else
            fail "OpenClaw is not installed" "OpenClaw Detection"
            info "Run '$(basename "$0") setup' to install OpenClaw with hardened defaults."
        fi

    elif [ "$command" = "setup" ]; then
        # Setup mode: detect and offer to install if missing
        echo ""
        echo -e "${CYAN}${BOLD}═══ Phase 4 of 5: OpenClaw Installation ═══${RESET}"

        if [ "$OPENCLAW_INSTALLED" = true ]; then
            step_header "OpenClaw Detection"
            local install_label="native (npm)"
            [ "$OPENCLAW_INSTALL_TYPE" = "docker" ] && install_label="Docker"
            pass "OpenClaw is already installed ($install_label)" "OpenClaw Detection"
        else
            step_header "OpenClaw Detection"
            warn "OpenClaw is not installed on this system"
            info "The setup wizard can install OpenClaw with secure, hardened defaults."
            if [ "$DEPLOY_MODE" = "native" ]; then
                info "Selected mode: Native (npm) — runs directly on this Mac"
            else
                info "Selected mode: Docker — runs in an isolated container (recommended)"
            fi
            echo ""

            if ask_yn "Install OpenClaw now?"; then
                if [ "$DEPLOY_MODE" = "native" ]; then
                    echo ""
                    echo -e "  ${CYAN}${BOLD}Installing OpenClaw (Native/npm)...${RESET}"
                    if command -v node &>/dev/null; then
                        setup_native_openclaw_directories
                        run_check "native_openclaw"
                        setup_native_env_file
                        setup_openclaw_config
                        setup_native_launchd
                    else
                        echo ""
                        warn "Node.js is not available — cannot install OpenClaw"
                        info "Re-run this wizard after installing Node.js (Phase 3)."
                        fail "Skipped installation (Node.js not available)" "Deploy"
                    fi
                else
                    echo ""
                    echo -e "  ${CYAN}${BOLD}Installing OpenClaw (Docker)...${RESET}"
                    if command -v docker &>/dev/null && docker info &>/dev/null; then
                        setup_openclaw_directories
                        setup_env_file
                        setup_docker_compose
                        setup_openclaw_config
                        deploy_openclaw_docker
                    else
                        echo ""
                        warn "Docker is not available — cannot install OpenClaw"
                        info "Re-run this wizard after installing Docker Desktop (Phase 3)."
                        fail "Skipped installation (Docker not available)" "Deploy"
                    fi
                fi
            else
                skipped "OpenClaw installation deferred" "OpenClaw Installation"
                info "Run '$(basename "$0") deploy' when you're ready to install."
            fi
        fi

    elif [ "$command" = "deploy" ]; then
        # Deploy mode: always run full deployment
        echo ""
        if [ "$DEPLOY_MODE" = "native" ]; then
            echo -e "${CYAN}${BOLD}═══ Phase 4 of 5: OpenClaw Native Deployment ═══${RESET}"

            if command -v node &>/dev/null; then
                setup_native_openclaw_directories
                run_check "native_openclaw"
                setup_native_env_file
                setup_openclaw_config
                setup_native_launchd
            else
                echo ""
                warn "Node.js is not available — cannot deploy OpenClaw"
                info "Install Node.js first, then re-run: $(basename "$0") deploy"
                fail "Skipped deployment (Node.js not available)" "Deploy"
            fi
        else
            echo -e "${CYAN}${BOLD}═══ Phase 4 of 5: OpenClaw Docker Deployment ═══${RESET}"

            if command -v docker &>/dev/null && docker info &>/dev/null; then
                setup_openclaw_directories
                setup_env_file
                setup_docker_compose
                setup_openclaw_config
                deploy_openclaw_docker
            else
                echo ""
                warn "Docker is not available — cannot deploy OpenClaw"
                info "Install and start Docker Desktop first, then re-run: $(basename "$0") deploy"
                fail "Skipped deployment (Docker not available)" "Deploy"
            fi
        fi
    fi

    print_phase_summary

    # ── Phase 5 of 5: Security Audit (all modes) ──
    reset_phase_counters
    echo ""
    echo -e "${CYAN}${BOLD}═══ Phase 5 of 5: Security Audit ═══${RESET}"

    run_check "openclaw_running"

    if [ "$DEPLOY_MODE" = "native" ]; then
        run_check "openclaw_config"
        run_check "openclaw_hardening"
        run_check "env_file"
        run_check "credential_exposure"
        run_check "skills_security"
        run_check "soul_security"
    else
        run_check "container_security"
        run_check "openclaw_config"
        run_check "openclaw_hardening"
        run_check "env_file"
        run_check "credential_exposure"
        run_check "skills_security"
        run_check "soul_security"
    fi
    print_phase_summary

    # Final report
    print_report
    save_report
}

# Run
main "$@"
