import "server-only";

export interface CVEFeedItem {
  id: string;
  description: string;
  cvssScore: number;
  severity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";
  cweIds: string[];
  publishedDate: string;
  nvdUrl: string;
}

export interface CVEFeed {
  generatedAt: string;
  totalResults: number;
  items: CVEFeedItem[];
}

const NVD_API = "https://services.nvd.nist.gov/rest/json/cves/2.0";
const KEYWORDS = ["node.js", "docker engine", "websocket"];
const MAX_ITEMS = 50;

export function getSeverityFromScore(
  score: number
): "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" {
  if (score >= 9.0) return "CRITICAL";
  if (score >= 7.0) return "HIGH";
  if (score >= 4.0) return "MEDIUM";
  return "LOW";
}

interface NVDResponse {
  totalResults: number;
  vulnerabilities: Array<{
    cve: {
      id: string;
      published: string;
      descriptions: Array<{ lang: string; value: string }>;
      metrics?: {
        cvssMetricV31?: Array<{
          cvssData: { baseScore: number; baseSeverity: string };
        }>;
        cvssMetricV30?: Array<{
          cvssData: { baseScore: number; baseSeverity: string };
        }>;
      };
      weaknesses?: Array<{
        description: Array<{ lang: string; value: string }>;
      }>;
    };
  }>;
}

function sleep(ms: number): Promise<void> {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

async function fetchKeywordFromNVD(keyword: string): Promise<CVEFeedItem[]> {
  const now = new Date();
  const ninetyDaysAgo = new Date(now.getTime() - 90 * 24 * 60 * 60 * 1000);

  const params = new URLSearchParams({
    keywordSearch: keyword,
    pubStartDate: ninetyDaysAgo.toISOString(),
    pubEndDate: now.toISOString(),
  });

  const url = `${NVD_API}?${params}`;

  const res = await fetch(url, {
    headers: { "User-Agent": "Clawkeeper-CVE-Feed/1.0" },
    next: { revalidate: 86400 },
  });

  if (!res.ok) return [];

  const data: NVDResponse = await res.json();

  return data.vulnerabilities
    .map((v) => {
      const cve = v.cve;
      const desc =
        cve.descriptions.find((d) => d.lang === "en")?.value ?? "";

      const metrics =
        cve.metrics?.cvssMetricV31?.[0] ?? cve.metrics?.cvssMetricV30?.[0];
      const cvssScore = metrics?.cvssData.baseScore ?? 0;

      const cweIds: string[] = [];
      for (const w of cve.weaknesses ?? []) {
        for (const d of w.description) {
          if (d.value.startsWith("CWE-")) {
            cweIds.push(d.value);
          }
        }
      }

      return {
        id: cve.id,
        description: desc,
        cvssScore,
        severity: getSeverityFromScore(cvssScore),
        cweIds: [...new Set(cweIds)],
        publishedDate: cve.published,
        nvdUrl: `https://nvd.nist.gov/vuln/detail/${cve.id}`,
      };
    })
    .filter((item) => item.cvssScore >= 4.0);
}

export async function fetchCVEFeed(): Promise<CVEFeedItem[]> {
  const allItems: CVEFeedItem[] = [];

  for (let i = 0; i < KEYWORDS.length; i++) {
    if (i > 0) await sleep(7000);
    const items = await fetchKeywordFromNVD(KEYWORDS[i]);
    allItems.push(...items);
  }

  // Deduplicate by CVE ID
  const seen = new Set<string>();
  const deduped = allItems.filter((item) => {
    if (seen.has(item.id)) return false;
    seen.add(item.id);
    return true;
  });

  // Sort by published date descending, cap at MAX_ITEMS
  deduped.sort(
    (a, b) =>
      new Date(b.publishedDate).getTime() -
      new Date(a.publishedDate).getTime()
  );

  return deduped.slice(0, MAX_ITEMS);
}

export async function getCVEFeed(): Promise<CVEFeed> {
  try {
    const items = await fetchCVEFeed();
    if (items.length > 0) {
      return {
        generatedAt: new Date().toISOString(),
        totalResults: items.length,
        items,
      };
    }
  } catch {
    // Fall through to seed file
  }

  // Fallback: read seed file
  try {
    const seedData = await import("@/data/cve-feed.json");
    return seedData.default as CVEFeed;
  } catch {
    return {
      generatedAt: new Date().toISOString(),
      totalResults: 0,
      items: [],
    };
  }
}
