import "server-only";

export interface CVEFeedItem {
  id: string;
  description: string;
  cvssScore: number;
  severity: "CRITICAL" | "HIGH" | "MEDIUM" | "LOW";
  cweIds: string[];
  publishedDate: string;
  nvdUrl: string;
  ghsaUrl?: string;
  affectedVersions?: string[];
  packages?: string[];
}

export interface CVEFeed {
  generatedAt: string;
  totalResults: number;
  items: CVEFeedItem[];
}

const CVES_URL =
  "https://raw.githubusercontent.com/jgamblin/OpenClawCVEs/main/cves.json";
const GHSA_URL =
  "https://raw.githubusercontent.com/jgamblin/OpenClawCVEs/main/ghsa-advisories.json";

interface RepoCVE {
  cve_id: string;
  severity: string;
  cvss: number;
  title: string;
  date_published: string;
  ghsa_id: string;
}

interface RepoGHSA {
  ghsa_id: string;
  cve_id: string;
  severity: string;
  title: string;
  published: string;
  html_url: string;
  packages: string[];
  affected_versions: string[];
  cwes: string[];
}

export function getSeverityFromScore(
  score: number
): "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" {
  if (score >= 9.0) return "CRITICAL";
  if (score >= 7.0) return "HIGH";
  if (score >= 4.0) return "MEDIUM";
  return "LOW";
}

function normalizeSeverity(
  s: string
): "CRITICAL" | "HIGH" | "MEDIUM" | "LOW" {
  const upper = s.toUpperCase();
  if (upper === "CRITICAL" || upper === "HIGH" || upper === "MEDIUM" || upper === "LOW") {
    return upper;
  }
  return "MEDIUM";
}

export async function fetchCVEFeed(): Promise<CVEFeedItem[]> {
  const [cvesRes, ghsaRes] = await Promise.all([
    fetch(CVES_URL, { next: { revalidate: 86400 } }),
    fetch(GHSA_URL, { next: { revalidate: 86400 } }),
  ]);

  if (!cvesRes.ok) throw new Error(`Failed to fetch cves.json: ${cvesRes.status}`);

  const cves: RepoCVE[] = await cvesRes.json();

  // Build GHSA lookup by CVE ID
  const ghsaMap = new Map<string, RepoGHSA>();
  if (ghsaRes.ok) {
    const ghsas: RepoGHSA[] = await ghsaRes.json();
    for (const g of ghsas) {
      if (g.cve_id) ghsaMap.set(g.cve_id, g);
    }
  }

  const items: CVEFeedItem[] = cves.map((cve) => {
    const advisory = ghsaMap.get(cve.cve_id);
    const severity = cve.cvss
      ? getSeverityFromScore(cve.cvss)
      : normalizeSeverity(cve.severity);

    const item: CVEFeedItem = {
      id: cve.cve_id,
      description: cve.title,
      cvssScore: cve.cvss ?? 0,
      severity,
      cweIds: advisory?.cwes ?? [],
      publishedDate: cve.date_published,
      nvdUrl: `https://nvd.nist.gov/vuln/detail/${cve.cve_id}`,
    };

    if (advisory) {
      item.ghsaUrl = advisory.html_url;
      if (advisory.affected_versions?.length) {
        item.affectedVersions = advisory.affected_versions;
      }
      if (advisory.packages?.length) {
        item.packages = advisory.packages;
      }
      // Prefer GHSA CWEs if available
      if (advisory.cwes?.length) {
        item.cweIds = advisory.cwes;
      }
    }

    return item;
  });

  // Sort by published date descending
  items.sort(
    (a, b) =>
      new Date(b.publishedDate).getTime() -
      new Date(a.publishedDate).getTime()
  );

  return items;
}

export async function getCVEFeed(): Promise<CVEFeed> {
  try {
    const items = await fetchCVEFeed();
    if (items.length > 0) {
      return {
        generatedAt: new Date().toISOString(),
        totalResults: items.length,
        items,
      };
    }
  } catch {
    // Fall through to seed file
  }

  // Fallback: read seed file
  try {
    const seedData = await import("@/data/cve-feed.json");
    return seedData.default as CVEFeed;
  } catch {
    return {
      generatedAt: new Date().toISOString(),
      totalResults: 0,
      items: [],
    };
  }
}
